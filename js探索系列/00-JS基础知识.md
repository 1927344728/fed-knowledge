## JS基础知识

### 控制页面滚动

H5 页面上的滚动，可分为窗口滚动和元素（加了`overflow: scroll | auto`）滚动。

JavaScript 有以下方法和属性可以控制页面滚动：

#### 常用的滚动方法

##### scrollTo

使界面滚动到给定元素的**指定坐标位置**。

```js
scrollTo(x-coord, y-coord)
scrollTo(options)
```

##### scroll

使界面滚动到给定元素的**指定坐标位置**。window.scrollTo 实际上和该方法是相同的。

```js
window.scroll(x-coord, y-coord) 
window.scroll(options)
```

##### scrollBy

使页面相对当前的位置滚动多少距离。

```js
window.scrollBy(x-coord, y-coord)
window.scrollBy(options) 
```
* `x-coord` 是期望滚动到位置水平轴上距元素左上角的像素
* `y-coord` 是期望滚动到位置竖直轴上距元素左上角的像素

* options 是一个 ScrollToOptions 对象。
  * top：指定 window 或元素 Y 轴方向滚动的像素数。
  * left：指定 window 或元素 X 轴方向滚动的像素数。
  * behavior：指定滚动是否应该平滑进行，还是立即跳到指定位置。取值：smooth (平滑滚动) | instant  (瞬间滚动) | auto。默认值 `auto`，效果等同于 `instant`。

##### scrollIntoView

让当前的元素滚动到浏览器窗口的可视区域内。

```js
element.scrollIntoView(); // 等同于element.scrollIntoView(true) 
element.scrollIntoView(alignToTop); // Boolean型参数 
element.scrollIntoView(scrollIntoViewOptions); // Object型参数
```
* alignToTop：一个 Boolean 值。true 表示元素的顶端将和其所在滚动区的可视区域的顶端对齐；false 表示元素的底端将和其所在滚动区的可视区域的底端对齐。
* scrollIntoViewOptions：一个包含下列属性的对象：
  * behavior：定义动画过渡效果。取值：auto | smooth。默认为 auto。
  * block：定义垂直方向的对齐。取值：start | center | end | nearest。默认为 start。
  * inline：定义水平方向的对齐。取值：start | center | end | nearest。默认为 nearest。

**这是一个实验中的功能**
此功能某些浏览器尚在开发。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。

#### 常用的滚动属性

##### scrollLeft

读取或设置元素滚动条到元素左边的距离。

```js
Element.scrollLeft
```

注意：如果这个元素的内容排列方向 direction 是`rtl` (right-to-left) ，那么滚动条会位于最右侧（内容开始处），并且`scrollLeft`值为0。此时，当你从右到左拖动滚动条时，scrollLeft会从0变为负数。

`scrollLeft` 可以是任意整数，然而：

- 如果元素不能滚动（比如：元素没有溢出），那么`scrollLeft` 的值是0。
- 如果给`scrollLeft` 设置的值小于0，那么`scrollLeft` 的值将变为0。
- 如果给`scrollLeft` 设置的值大于元素内容最大宽度，那么`scrollLeft` 的值将被设为元素最大宽度。

##### scrollTop

获取或设置一个元素的内容垂直滚动的像素数。

```js
Element.scrollTop
```

一个元素的 `scrollTop` 值是这个元素的**内容顶部**（卷起来的）到它的视口可见内容（的顶部）的距离的度量。

其他与 scrollLeft 类似。

#### 其他方法

`window.scrollByLines()`： 按给定的行数滚动文档。注：目前仅Firefox浏览器支持。

`window.scrollByPages()`： 在当前文档页面按照指定的页数翻页。注：目前仅Firefox浏览器支持。

#### 注意问题

1. 低版本 IE 浏览器可能不支持  `scrollTo()、scrollBy()` 等方法。
2. `scrollTo()、scrollBy()、scrollBy()`  都可以用于 `window` 和 `element` 控制滚动。 但部分手机（比如：华为 麦芒4，系统版本：6.0.1），不支持 `element.scrollTo()`。可以使用 `element.scrollLeft` 属性。
3. window 对象没有 `scrollTop 、scrollLeft` 属性，但可以用  `document.documentElement.scrollTop、document.documentElement.scrollLeft` 实现窗口滚动。



### 蒙层底部页面跟随滚动

弹窗是一种常见的交互方式，而蒙层是弹窗必不可少的元素，用于隔断页面与弹窗区块，暂时阻断页面的交互。但是，在蒙层元素中滑动的时候，滑到内容的尽头时，再继续滑动，蒙层底部的页面会开始滚动，显然这不是我们想要的效果，因此需要阻止这种行为。  

#### 解决方案一

打开蒙层时，给body添加样式：

```css
/*在某些机型下，你可能还需要给根节点添加此样式。关闭蒙层时，移除些样式*/
body {
    height: 100%;
    overflow: hidden;
}
```

**优点：**简单方便，只需添加css样式，没有复杂的逻辑。
**缺点：**兼容性不好，适用于pc，移动端就尴尬了。部分安卓机型以及safari中，无法无法阻止底部页面滚动。  

#### 解决方案二

就是利用移动端的touch事件，来阻止默认行为（这里可以理解为页面滚动就是默认行为）。

```js
// node为蒙层容器dom节点
node.addEventListener('touchstart', e => {
    e.preventDefault()
}, false)
```

简单粗暴，滚动时底部页面也无法动弹了。假如你的蒙层内容不会有滚动条，那么上述方法prefect。
但是，最怕空气突然安静，假如蒙层内容有滚动条的话，那么它再也无法动弹了。因此我们需要写一些js逻辑来判断要不要阻止默认行为，复杂程度明显增加。

**具体思路：**判定蒙层内容是否滚动到尽头，是则阻止默认行为，反之任它横行。

#### **解决方案三**(推荐使用)  

**具体思路：**要阻止页面滚动，那么何不将其固定在视窗（即position: fixed），这样它就无法滚动了，当蒙层关闭时再释放。
当然还有一些细节要考虑，将页面固定视窗后，内容会回头最顶端，需要记录一下同步top值。

```js
let top = 0
function stopBodyScroll (isFixed) {
    let bodyEl = document.body
    if (isFixed) {
        top = window.scrollY

        bodyEl.style.position = 'fixed'
        bodyEl.style.top = -top + 'px'
    } else {
        bodyEl.style.position = ''
        bodyEl.style.top = ''
        window.scrollTo(0, top) // 回到原先的top
    }
}
```



### iphone X 适配问题 

#### 安全区域

iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。以下是解决方法：

1. 新增 `meta` 标签：

   ```html
   <meta name="viewport" content="width=device-width, viewport-fit=cover">
   ```

   iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式。可设置三个值：

   * contain: 可视窗口完全包含网页内容
   * cover：网页内容完全覆盖可视窗口 
   * auto：默认值，跟 contain 表现一致  

2. 样式中引用变量：

   ```css
   body {
     /*页面主体内容限定在安全区域内*/
     padding-bottom: constant(safe-area-inset-bottom);
     padding-bottom: env(safe-area-inset-bottom);
   }
   
   {
     /*fixed 元素的适配*/
     padding-bottom: constant(safe-area-inset-bottom);
     padding-bottom: env(safe-area-inset-bottom);
   }
   
   /*使用 @supports 隔离兼容样式*/
   @supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(
   safe-area-inset-bottom)) {
     div {
       margin-bottom: constant(safe-area-inset-bottom);
       margin-bottom: env(safe-area-inset-bottom);
     }
   }
   ```


#### 常见问题

1. iphone X 下，fixed 元素在页面滑动底部时，会往上滑动移动一点。这是由于**页面高度不足一屏(或者撑开页面高度的元素加了fixed，脱离文档流)**引起的。

   **解决方法：**

   * body 或者主元素中加 `min-height`
   * 加空的 div 或伪元素撑高页面

2. 元素使用 `padding-bottom` 预留底部小黑条区域，必需设置`box-sizing: content-box`



### 限制input输入

`input` 元素只允许输入数字、中文、字母等。

**实现思路：**`Js`监听键盘事件，通过正则匹配或键码值对比，将不符合校验的值替换或者将事件对象的`returnValue`置为`false`。

三个键盘事件：`keydown、keypress、keyup`

常见的限制类型：

* 只能输入或粘贴数字

  ```html
  <!--this.可以不加-->
  <input onkeyup="this.value = this.value.replace(/\D/g,'')" onafterpaste="this.value = this.value.replace(/\D/g,'')">
  ```

* 只能输入数字**(无闪动)**

  ```html
  <input type="text" onkeypress="if ((event.keyCode<48 || event.keyCode>57)) event.returnValue=false" /> 
  ```

* 只能输入或粘贴数字和小数点

  ```html
  <input onkeyup="if(isNaN(value)) execCommand('undo')" onafterpaste="if(isNaN(value)) execCommand('undo')">
  ```

* 只能输入或粘贴英文字母和数字，不能输入中文

  ```html
  <input onkeyup="this.value = this.value.replace(/[^\w\.\/]/g,'')" onafterpaste="this.value = this.value.replace(/[^\w\.\/]/g,'')">
  ```

* 只能输入或粘贴中文

  ```html
  <input type="text" onkeyup="this.value = this.value.replace(/[^\u4e00-\u9fa5]/g,'')" onafterpaste="this.value = this.value.replace(/[^\u4e00-\u9fa5]/g,'')">  
  ```

* 只能输入或粘贴英文

  ```html
  <input type="text" onkeyup="this.value = this.value.replace(/[^a-zA-Z]/g,'')" onafterpaste="this.value = this.value.replace(/[^a-zA-Z]/g,'')"> 
  ```

* 简易禁止输入汉字

  ```html
  <!--无效？？-->
  <input style="ime-mode:disabled">
  ```

* 只读文本框

  ```html
  <input readonly />
  ```

