{"./":{"url":"./","title":"Introduction","keywords":"","body":" 本文档主要用于： 整理前端开发中遇到的各种bug 对一些浏览过、探索过、实践过的前端技术做一些笔记 项目运行 安装项目: gitbook install 本地启动：sh serve 根目录下有个名serve的shell文件，是为了解决gitbook serve热加载出现中断的问题和指定输出路径。 本地启动项目的核心命令是：gitbook serve [--input] [--output] [--port 4000] 。 --input是需要编译的项目地址。可不传，默认当前根目录下。 --output是编译后的输出路径。可不传，默认_book。指定输出目录为./docs，是因为GitHub Pages的静态网站指定的目录是master 分支下的./docs文件夹。 --port是端口号。可不传，默认4000 生成文件：sh build 项目git push之前，需要sh build更新SUMMARY.md文件。 根目录下有个名build的shell文件。是为了解决自动生成SUMMARY.md时不编译docs目录下的文件和指定输出路径。 生成文件的核心命令是：gitbook build[--input] [--output] --input是需要编译的项目地址。可不传，默认当前根目录下。 --output是编译后的输出路径。可不传，默认_book。指定输出目录为./docs，是因为GitHub Pages的静态网站指定的目录是master 分支下的./docs文件夹。 本文有两个访问地址 Gitbook.io Github Page 已知问题 Gitbook不支持原生的html、css语法 GitBook doesn't render plane HTML or CSS so the workaround would be to wrap them into a code block by adding '```' We don't plan on supporting plain HTML or CSS I'm afraid Gitbook.com中引入了gitalk做评论插件。目前遇到问题，无法正常显示 项目引入是基于gitalk的mygitalk插件。已向作者提issue，暂未回复。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-01 23:13:46 "},"bugs/00-前端调试随笔.html":{"url":"bugs/00-前端调试随笔.html","title":"前端调试随笔","keywords":"","body":"前端Debug随笔 Debug指南 异步问题 前端出现异步的因素有：动画、HTTP 请求、DOM 渲染、定时器等。 缓存问题 浏览器缓存、CDN缓存、路由器的缓存。 实例一：CDN 中缓存的 JQuery 文件不完整，导致部分用户打开页面出错。(因为是部分CDN缓存出错，前端非常难定位问题。) 实例二：本地的 localStorage 缓存，在某些情况下不能再用时，没有定义有效的清除机制。 网络问题 第三方插件链接出错、部分地区网络出错、是否正确使用 http 和 https。 实例一：微信好友分享，由于使用了默认协议 //，导入分享不成功。 es6语法支持 是否使用了 canvas\\promise 或者使用了 es6 中的一些语法，但是没有用 babel 转换或者没有引入 polifyfill。 Babel 最核心的依赖： @babel/cli、@babel/core、@babel/polyfill、@babel/register、core-js。 \"@babel/cli\": Babel 自带了一个内置的 CLI 命令行工具，可通过命令行编译文件。 \"@babel/core\": `babel`的核心，一些转码操作都是基于它完成的 \"@babel/polyfill\": Babel默认只转换新的JavaScript语法，但是不转换新的API，比如：`Iterator`、`Generator`、`Set`、`Maps`、`Proxy`、`Reflect`、 `Symbol`、`Promise` 等全局对象，以及一些定义在全局对象上的方法（比如 `Object.assign`、`Array.findIndex` ）都不会转码。而`@babel/polyfill`就可以做到。 \"@babel/register\": 让webpack.config.babel.js也支持ES6语法 实例一：JS 中用了 findIndex 方法，由于某些原因，该 JS 文件没有经过 babel 转换，导致在一些低端手机执行 JS 出错，而控制台没有详细的报错信息，问题定位困难。 Cookie问题 请求无法携带 cookie 问题：浏览器是否标禁用了 cookie、跨站导致 cookie 无法发送成功、HTTP 请求未设置允许跨站。 浏览器中的 cookie 是可以重写的，使用时要特别注意。 实例一：由于开启了 Mock.JS，导出 cookie 无法携带，HTTP 请求报跨域错误。 实例二：联调本地页面时，IOS 设备上出现循环登录现象。原因是 Cookie 无法跨域携带。解决方案：原生开发放开 APP 禁止跨网站发送的限制，比如，设置 -> 找到【APP】 -> 开启【允许跨网站跟踪】。 实例三：页面反复出现未登录提示。原因是前端根据 URL 链接中的参数，用 JavaScript 重写的 Cookie 的 token 的值（还有一种，同域名下有两个不同项目，登录体系不一样，但都依赖 token，导致相互重写），同时，由于服务端的一些逻辑，并未判断该用户未登录，返回的不是约定的 401 状态，而是其他错误状态。 调试工具 Chrome DevTools，Chrome 浏览器内置的 Web 开发和调试工具。 vConsole，针对手机网页的前端开发者调试面板。 Eruda ：一个用于移动浏览器的控制台，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获 XHR 请求、显示本地存储和 Cookie 信息等等。 Firefox DevTools，Firefox 浏览器内置的 Web 开发工具，用来检查、编辑和调试 HTML、CSS 和 JavaScript。 IETester，一款免费的 WebBrowser，允许在 Windows 8、Windows 7、Vista、XP 上拥有 IE 5.5~11 的渲染和 JavaScript 引擎，可以于调试不同版本的 IE 浏览器的兼容性。 微信开发者工具，为了帮助开发者简单和高效地开发和调试微信小程序，在原有的公众号网页调试工具的基础上，推出了全新的 微信开发者工具，集成了公众号网页调试和小程序调试两种开发模式。 Fiddler，是最强大最好用的 Web 调试工具之一， 它能记录所有客户端和服务器的 http 和 https 请求。允许监视、设置断点、甚至修改输入输出数据。 Charles ，是一个 HTTP 代理 / HTTP 监视器 / 反向代理，它使开发人员能够查看他们的机器和 Internet 之间的所有 HTTP 和 SSL / HTTPS 通信。 这包括请求、响应和 HTTP 报头（其中包含 cookie 和缓存信息）。 Debugbar，是一个 IE 的 Web 开发栏，分为工具栏和侧边栏。 它的目的是帮助您调试您的网站更快或快速分析任何网页。 mockjs，用于生成随机数据，拦截 Ajax 请求。 移动端真机调试 IOS真机调试 IOS 设备可以通过 safari 调试，但必须满足如下条件： safari 打开开发者模式：Safari浏览器 -> 偏好设置 -> 高级 -> 在菜单栏中显示“开发”菜单； IOS 设置 safari ，允许调试； 原生打开允许 app 的调试的限制，即，安装的应用是可调试版本的； 需要原生将该设备加入白名单。 使用数据线连接设备和电脑，Safari 点开开发者调试。 Andriod真机调试 Andriod 设备可以通过 Chrome 调试，但必须满足如下条件： Android 设备系统版本为 4.4 以上； 开启开发者模式：设置 -> 关于手机 -> 连续点击系统版本。（不同机型开启模式有异差） 系统安全 -> 未知来源 -> 允许； 选择开发者选项：允许 USB 调试。 电脑连接手机：Mac 电脑使用 【Android File Transfer for mac】管理安卓机文件（需自行下载，并在加接手机前运行该软件）。 使用数据线连接设备和电脑，Chrome打开：chrome://inspect/#devices © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-05-21 13:48:33 "},"bugs/01-浏览器常见问题概览.html":{"url":"bugs/01-浏览器常见问题概览.html","title":"浏览器常见问题概览","keywords":"","body":"浏览器常见问题概览 如何清理Chrome的favicon缓存？ cd /Users/$USERNAME/Library/Application\\ Support/Google/Chrome/Default rm Favicons Favicons-journal #重启chrome 如何在Chrome禁用/启用JavaScript？ 点击屏幕右上角的菜单图标（三个点） -> 设置 -> 隐私设置和安全性 -> 网站设置 -> JavaScript -> 选择 ”网站可以使用JavaScript“ 或者 ”不允许网站使用JavaScript“。 如何在Chrome禁用/启用CSS？ 安装 Chrome 插件：Web Developer。Web Developer 扩展向浏览器添加了一个带有各种 Web 开发工具的工具栏按钮。 禁用 Javascript、通知、弹层等 Cookies 管理：禁用、增删查改等 禁用 Css、修改盒子模型、查看Css等 表单、图片、信息等管理 vue debugger 定位不准确 浏览器调试界面，断点停下来的地方并不是 debugger 那一行。有时候差一点，有时候差很多。 解决： 在 vue.config.js 添加： module.exports = { chainWebpack: config => { if (!isProductionEnv) { config.devtool('source-map') } } } a 标签的资源链接无法跳转或下载？ 原因一： 资源链接权限问题。 原因二： 链接协议问题。比如：当前访问链接是 https，资料链接是 http。 vue检查hostname 由于新版的 webpack-dev-server 出于安全考虑，默认检查 hostname，如果 hostname 不是配置内的，将中断访问。 解决方法如下： devServer: { disableHostCheck: true, } Chrome 开发者工具报错（touch） Chrome 报错： [Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive. See 这是 Chrome 为了提高页面的滑动流畅度而新折腾出来的一个东西。 由于浏览器必须要在执行事件处理函数之后，才能知道有没有掉用过 preventDefault() ，这就导致了浏览器不能及时响应滚动，略有延迟。 所以为了让页面滚动的效果如丝般顺滑，从 Chrome56 开始，在 window、document 和 body 上注册的 touchstart 和 touchmove 事件处理函数，会默认为是 passive: true。 浏览器忽略 preventDefault() 就可以第一时间滚动了。 解决方法一： body { touch-action: none; } 解决方法二： window.addEventListener('touchstart', function(event) { event.preventDefault(); }); 解决方法三（不推荐）： window.addEventListener('touchstart', function() {}, { passive:false }) 相关链接： vue问题解决] chrome浏览器Unable to preventDefault inside passive event listener due to target being treated as passive. Easy fix for: Unable to preventDefault inside passive event listener due to target being treated as passive Unable to preventDefault inside passive event listener HTTP 请求错误：net::ERR_CONNECTION_RESET net::ERR_CONNECTION_RESET 是 Chrome 浏览器抛出的错误，在其他浏览器，比如，Firefox，则抛出 The connection was reset 错误。 连接重置（Connection reset）是在访问网站时，浏览器无法建立连接时发生的。连接被“重置”，这意味着服务器不能将数据传输到您的浏览器。 在大多数情况下，是网络连接的问题： 虚拟专用网络（VPN）出现问题，比如，没配置公网解析； 防火墙或防病毒程序阻止了到远程服务器的连接； 代理设置有问题； 浏览器缓存有问题。 How to Fix the “ERR_CONNECTION_RESET” Error (5 Ways) IOS：发生了SSL错误，无法建立与该服务器的安全连接 私钥与证书不匹配 似乎 cPanel 找不到为此 SSL 证书创建的私钥。私钥与 CSR Key 一起生成。可能错误地删除了此密钥。如果您在同一台服务器上安装了多个 CSR 密钥和私钥，cPanel 将无法找到正确的私钥。 解决方法：可以手动查找随 CSR Key 一起生成的原始私钥并将其粘贴到私钥框中。 可能安装了默认的自签名证书 因为主流浏览器不信任或不支持自签名 SSL 证书，但服务器 WHM / cPanel 设置可能配置了默认的 WHM 自签名 SSL。在常规实践中，所有 WHM 配置都设置自签名，并为此 SSL 中配置的所有域账户设置为共享 SSL。 解决方法：安信 SSL 证书建议使用 SSL 保护的域名购买专用的 SSL 证书。此专用SSL证书将由受信任的证书颁发机构（如Symantec、GeoTrust等）颁发，并在 SSL 中包含您的域名。因此，Web 浏览器将信任此 SSL，并且不会显示更多警告或消息。 网站证书不是由受信任的机构颁发 这是因为证书不在浏览器厂商的受信任的列表中。 ssl证书包含域名与网址不一致 每一个 ssl 证书所对应的域名都具有唯一性，是一个全域名 FQDN。当网站出具的证书所包含的域名和网站域名不一致，系统就会自动发出报告，提示证书域名不匹配。 解决方法： 需要重新申请 ssl 证书。如有相同主域名的多站点，则要申请多域名 ssl 证书。 网站证书已过期或还未生效 出现这种情况一般是电脑系统日期错误，另一种就是证书过了有效期，则需要续费。 解决方法： 可查看该证书信息的有效起止日期，确定证书是否在有效期内，如在的话需查看电脑日期是否正确。否则就是第二种原因，ssl 证书不在有效期内，需尽快联系证书颁发厂商，进行续费。 系统时间不正确 如果系统时钟从通用时间选项中被删除，或者时间设置意外地改变了，使得你的系统时间错误，可能会导致 SSL 错误问题。 解决方法： 将系统时间设置回到正确的日期和时间，那就可以继续正确连接。 页面包含有不安全的内容 目前都提倡每一个页面使用 HTTPS，则网站所有内容都必须是 HTTPS。如果遇到图片、Js 脚本，FLASH 插件是通过 HTTP 方式去调用的，就会发生这种错误。 解决方法： 将调用的元素 http 改成 HTTPS 即可，然后刷新测试 ssl 问题是否已经解决。 浏览器错误 有时浏览器可能会出错配置，或者插件可能会导致某些方面的工作方式有所不同，从而导致连接到其他合法网站时出现 SSL 错误问题。 解决方法： 需要准确诊断当前浏览器需要调整的内容，此外最快方法是：将浏览器重置为默认设置并禁用所有插件。当然，有更简单的方法：只需尝试其他浏览器即可。 中间人（代理器） 中间人（MITM）不只是黑客，许多程序和设备拦截流量以进行检查，然后将其发送到应用程序服务器。这也构成了 MITM，都可能导致 SSL/TLS 协议错误。它可能类似于阻止连接的网络防火墙，或者可能是服务器端网络上边缘设备上的配置。 ssl 错误无法建立安全连接什么情况？ © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-07-03 11:54:30 "},"bugs/02-浏览器兼容问题概览.html":{"url":"bugs/02-浏览器兼容问题概览.html","title":"浏览器兼容问题概览","keywords":"","body":"浏览器兼容问题 IE浏览器 1.Symbol 未定义 解决：添加 babel-polyfill 或者直接引入 https://cdn.bootcdn.net/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js。 备注：polyfill 文件需要在其他 .js 文件（尤其是报错的js文件）之前引入。 2. SCRIPT5022 SecurityError。WebSocket on IE10 giving a SecurityError 原因：打开一个本地(内部网)域的 websocket，IE抛出一个安全性错误（SecurityError） 解决：禁用IE识别本地站点的自动算法：Tools > Internet Options > Security > Local Intranet > Sites. 取消选中的 include all local (intranet) sites not listed in other zones ，或者取消所有选中的复选框。 备注：修改后，重启IE浏览器。 3. SCRIPT1006: Expected ')'、SCRIPT1002: Syntax error 原因：IE浏览器不支持es6的一些新语法。 一般项目编译，会将项目根目录下 src 等文件夹下的所有.js|jsx 文件中的 ES6 语法转换成 ES5，且会将node_modules文件夹下所有文件忽略，而部分node_modules 下的包会包含了ES6语法。 SCRIPT1006: Expected ')': 不支持函数的默认参数。如： function correlation (xMatrix, xMatrix = xMatrix, options = {} ) { } SCRIPT1002: Syntax error: 不支持 class。如 class Base { constructor() {} } 解决： 用转换器，将ES6转成ES5。比如 babel。 采用不同工具创建的项目，修改 babel配置的方法不一样。 webpack 配置文件：在 module -> rules 的 babel-loader 的 include 属性中追加 resolve('node_modules')。 module.exports = { module: { rules: [ { test: /\\.js$/, loader: 'babel-loader', include: [ resolve('src'), resolve('test'), resolve('node_modules') ], } ] } } umi@3.1.x：配置 nodeModulesTransform 设置 node_modules 目录下依赖文件的编译方式。nodeModulesTransform umi@2.x.x：的修改就比较麻烦了。 extraBabelIncludes 属性：定义额外需要做 babel 转换的文件匹配列表，格式为数组，数组项是 webpack#Condition。（尝试修改，但是没有成功） chainWebpack 属性：修改 webpack 配置。（推荐） // config.js export default { chainWebpack: config => { config.module .rule('js-in-node_modules') .before('js') .test(/\\.(js|jsx|ts|tsx)$/) .include.add(/node_modules/) .end() .use('babel') .loader('babel-loader') .options({ presets: [ ['@babel/preset-env', { targets: 'defaults', modules: false }], ['@babel/preset-react'], ['@babel/preset-typescript'], ], }); } } https://github.com/umijs/umi/issues/2025 4. IE浏览器会缓存GET请求 在 get 请求的 url 中增加随机标识。如：时间戳。 请求头 headers 添加两个键值参数。服务端需要在 Access-Control-Allow-Header 里面添加 cache-control、Pragma 字段。 ['Cache-Control'] = 'no-cache'; ['Pragma'] = 'no-cache'; 修改浏览器配置。Internet选项 >> 浏览历史记录 >> 设置 >> Internet 临时文件的选项改为‘每次访问网页时’ 在服务端设置 header(“Cache-Control: no-cache, must-revalidate”) 改为 post 接口 5. This browser lacks typed array (Uint8Array) support which is required by buffer v5.x. Use buffer v4.x if you require old browser support。（未解决） 备注：将 buffer 版本回退到4.3.0，还是有报错。 npm list buffer ├── buffer@4.3.0 └─┬ umi-plugin-react@1.15.8 └─┬ webpack@4.41.1 └─┬ node-libs-browser@2.2.1 └── buffer@4.3.0 deduped 6. cannot call a class as a function。（未解决） 注：react-dom.production@17.min.js 报错。 7. DOM 对象不支持 remove 属性或方法 原因： IE 浏览器的 Element 对象是没有remove方法的 解决： 引入 element-remove polyfill。 为 Element 对象定义一个 remove 方法： if (!('remove' in Element.prototype)) { Element.prototype.remove = function() { if (this.parentNode) { this.parentNode.removeChild(this); } }; } 8. transform: translate|translateY 等对 table 中的 display: table-header-group|table-row-group 元素（thead、tbody）无效。 9. 不支持event.target.files（IE10） 解决：可修改为 event.srcElement.files || event.target.files 10. 不支持 new FormDate() （IE9） 解决：引入 FormData 的 polyfill。参考 https://gist.github.com/Rob--W/8b5adedd84c0d36aba64、https://github.com/henryluki/FormData 11. 无法获取file对象（IE9） 解决：参考 https://blog.csdn.net/weixin_34352005/article/details/91918449、http://www.zhishichong.com/article/83379 360浏览器 1. z-index的层叠规则与其他主流浏览器不一样 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-16 01:15:56 "},"bugs/03-HTML常见问题概览.html":{"url":"bugs/03-HTML常见问题概览.html","title":"HTML常见问题概览","keywords":"","body":"HTML常见问题概览 Uncaught SyntaxError: Unexpected token 通常是 HTML中的引用路径有误 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-06-02 21:59:15 "},"bugs/04-CSS常见问题概览.html":{"url":"bugs/04-CSS常见问题概览.html","title":"CSS常见问题概览","keywords":"","body":"CSS常见问题概览 CSS样式错乱 样式在 PC 端 Chrome 浏览器中显示正常，在部分手机上错乱。 原因： 样式缺少前缀。webpack 项目中通过 autoprefixer 自动给样式加前缀（即，加 `-webkit, -ms, -moz-, -o- 等前缀），而具体需要对哪些浏览器哪些版本加前缀，是通过配置决定的。 \"browserslist\": [ \"> 1%\", \"last 2 versions\" ] 其中 last 2 versions 是指定对最新的两个版本加前缀，这个指定是不固定。随着浏览器的更新，所指向的版本也变化，导致autoprefixed 不对之前的一些旧版本加前缀。 解决方法： 在 package.json 文指定需要加前缀的浏览器及对应版本，当然，也可以用其他文档形式配置。 \"browserslist\": [ \"> 1%\", \"last 2 versions\", \"Android >= 3.2\", \"Firefox >= 20\", \"iOS >= 7\", \"chrome > 20\" ] transform: scale引起的元素模糊问题 CSS 中使用 transform: scale(1.18) 放大元素，元素中的文字图片变模糊。 原因：大概原理就是 scale 的时候导致了 font-size 算出了小数，所以 Chrome 就模糊了处理，而且只会发生在复杂的 DOM 结构里，很简单的 DOM 结构，是不会发生模糊的。因为 Chrome 在处理这种复杂 Dom 结构的缩放的时候，把 Dom 结构渲染成了一张图，然后对图片进行缩放。 解决：对原有的 Dom 结构，先进行 zoom，慢慢调试到 scale 之后文字不模糊的程度就 ok了。目前采用调整 scale 倍数的方法，即scale(1.18) 改成 scale(1.2)。 其他尝试： 加 translateZ(0)、translate3d(0,0,0) 的解决方案，亲测无效。 A标签伪类问题 问题一： :active 在移动端无效。 解决： 在元素或 body/html 上绑定一个 touchstart 事件能激活 :active 状态。 //...空函数即可 document.body.addEventListener('touchstart',function () { }); 元素使用 :active，点击字体颜色会默认到 :visited 的默认颜色，需同时设置 :active、:visited 的颜色。 伪类的优先有： /*按L-V-H-A的顺序设置超链接样式即可，可速记为LoVe（喜欢）HAte（讨厌）*/ a { &:link{} &:visited{} &:hover{} &:active{} } 表单元素的placeholder文本不居中 PC端：line-height: [和表单元素的高度一样]； 移动端：line-height：normal 。 CSS动画页面闪动，动画卡顿 尽可能地使用合成属性 transform、opacity 来设计CSS3动画，不使用 position: left | top 来定位 。 -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); box-sizing属性 content-box：设置的高度不包括上下 border、padding；宽度包括左右 border、padding； border-box：设置的宽高值包括 border、padding。 背景边框的问题 背景图片大小 background: url(xxx) no-repeat top top/80% auto; /**部分手机不支持\"/\"后加参数的写法*，可改用下面写法/ background: url(xxx) no-repeat top top auto; background-size: 80%； 渐变颜色 /*部分手机不支持background-image属性写渐变颜色。如酷派、联想s810t；*/ background-image: -webkit-radial-gradient(center center, circle cover, #0087fb 0%, #0087fb 35%,transparent 35%); 透明色 IOS中 background 渐变色中 transparent 显示为黑色。 background: linear-gradient(to right, #f91250 0%, transparent 10%, transparent 90%, #f91250 100%); 错误解决方法：将 transparent 改成 rgba(255,255,255,0)。 background: linear-gradient(to right, rgba(249,18,80,1) 0%, rgba(255,255,255,0) 10%, rgba(255,255,255,0) 90%, rgba(249,18,80,1) 100%); 正确解决方法：将 transparent 改成 rgba(249,18,80,0)，即将透明色前的色值 #f91250 转换成 rgba 值，并设置透明度设为0。 background: linear-gradient(to right, rgba(249,18,80,1) 0%, rgba(249,18,80,0) 10%, rgba(249,18,80,0) 90%, rgba(249,18,80,1) 100%); 圆形有些扁 元素设置 border-radius: 100px（大于元素宽高），圆形有些扁。 父标签字体大小设置为零，由子标签设置 font-size 属性。 底部的导航栏挡住 body 设置 height: 100% 后被底部的导航栏挡住。 document.documentElement.style.height = `${window.innerHeight}px` 滚动条未隐藏 body 设置 width: 100%; overflow: hidden，仍有 X 方向滚动条。 原因： body 没有设置 postion:relative，且有子元素中有绝对定位元素宽度超过屏幕宽度。 -webkit的问题 禁止用户选中文字：-webkit-user-select:none； 去掉按钮touch时蓝色边框 :-webkit-tap-highlight-color:rgba(0,0,0,0)； 去除webkit的滚动条: ::-webkit-scrollbar{ display: none; }； 禁止保存或者拷贝图像(仅ios有效) : img { -webkit-touch-callout: none; }； 禁止选中内容 htm: { -webkit-user-select: none;}； 修改表单元素中placeholder 的样式： ::-webkit-input-placeholder{ }； 去除表单元素的默认样式: -webkit-appearance:none； 如select、input； input type=number之后，PC 端出现上下箭头： input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none !important; margin: 0; } 快速回弹滚动 (iOS上拥有像Native 的滚动效果) { overflow: auto; -webkit-overflow-scrolling:touch; } table样式的问题 td 用 col 设置了宽度后超出部分隐藏：table 加属性 table-layout:fixed（固定宽度布局） ; col 和 colgroup 发挥作用且保证兼容的应用就只有俩： width、background； table 定义了 border-collapse:collapse 属性，border-spacing 属性不生效； table中 实现圆角效果：在 table 中设置 border-radius 发现不起作用，原因是 border-collapse: collapse 和 border-radius 不兼容。以下方法解决（chrome试验可行，未测手机兼容性）： /* 解决方法一 */ table { border-radius: 12px; border-spacing: 0; border: 1px solid #ccc; } /* 解决方法二 */ table { border-radius: 12px; border-style: hidden; box-shadow: 0 0 0 1px #ccc; } 旧手机上的问题（机型可能已淘汰） border-radius失效 部分 Android 不识别百分比单位，可设置一个较大值的px、em、rem单位； 部分手机下，width 值过大，border-radius 无效； Android 4.2.x 不支持 border-radius 缩写； Samsung S4 (Android Browser4.4.2) 使用了 border-radius，并且使用了 -webkit-transform 属性，当使用了 translatez 或者 translate3d 值，圆角会出现问题，可用 -webkit-transform: translate(0, 0) 来避免这个问题。 Android 4.x bug 三星 Galaxy S4中自带浏览器不支持border-radius缩写 同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 android无法同时播放多音频audio © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-07-03 12:02:29 "},"bugs/05-JS常见问题概览.html":{"url":"bugs/05-JS常见问题概览.html","title":"JS常见问题概览","keywords":"","body":"JS常见问题 Uncaught TypeError: undefined is not a function Uncaught 表示错误没有被 catch 语句捕获，TypeError 是错误的名字，在这里表示是数据类型错误。undefined is not a function，这是 Error 的主信息，这里表示代码尝试使用 undefined ，把它当做一个函数。 这种错误，通常是执行了一个未定义的方法： 可能一：某个方法没有正确引入。如：this 的指向改变、异步引入问题； 可能二：浏览器兼容问题。如：IE 的 DOM 对某些 API 不支持； 可能三：ES6 没有转换。如：使用了 findIndex 等一些新 API，部分安卓机不支持。 Uncaught ReferenceError: Invalid left-hand side in assignment 未捕获的引入错误：赋值语句左侧变量无效。比如： // 正确逻辑是比较func1的返回值。因少写了一个“=”，变成了无效的赋值语句。 function func1 () { return 1 } if (func1() = 1) { console.log('true') } Uncaught SyntaxError: Invalid or unexpected token 未捕获的语法错误：无效或意外的符号。一般是出现中文符号或者语句不完整。比如： // 出现中文圆括号 function func1 () { console.log(1) } func1(） 类似的还有： // Uncaught SyntaxError: Unexpected end of input let arr = [a] arr[1 // Uncaught SyntaxError: Unexpected identifier let objA = { a: 1 objA.a // Uncaught SyntaxError: Unexpected end of JSON input JSON.parse('') Uncaught TypeError: Converting circular structure to JSON 未捕获的语法错误：将循环结构转换为JSON。比如： const objA = {} const objB = { objA: objA } objA.objB = objB JSON.stringify(objB) Uncaught RangeError: Maximum call stack size exceeded 未捕获边界错误：超过最大调用堆栈大小 。一般是函数递归调用或者循环中没有加判断条件。比如： function countDown (n) { if (n onbeforeunload事件无效 onbeforeunload 事件有兼容问题，及一些使用限制。详见 JS基础知识03-onbeforeunload事件。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-11-19 20:50:49 "},"bugs/06-移动端兼容性问题概览.html":{"url":"bugs/06-移动端兼容性问题概览.html","title":"移动端兼容性问题概览","keywords":"","body":"移动端兼容性问题概览 兼容性问题与手机型号、系统版本有关，只出现在部分手机上 设备更新换代快——低端机遗留下问题、高端机带来新挑战 。 浏览器厂商不统一——兼容问题多 。 网络更复杂——弱网络，页面打开慢 。 低端机性能差——页面操作卡顿 。 HTML5新技术多——学习成本不低 。 常见原因 使用了es6语法：不支持canvas\\promise等；有部分手机不支持es6，可用babel将es6转成es5。 Babel转换问题：Babel 默认只转换新的 JavaScript 语法，但是不转换新的API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比 如 Object.assign ）都不会转码。而@babel/polyfill就可以做到。 缓存问题：由于路由器或者 CDN 缓存，导致请求的文件不是最新的，或者缓存的文件内容缺失。 网络问题：部分地区网络出错，导致第三方插件无法加载、网络协议： http 和 https 使用不对。 JS API 兼容性： 不支持类数组的遍历 //部分手机中，这种遍历会报错。比如：华为畅享5S（TAG-TL00） document.querySelectorAll('div').forEach((ele, index) => {}); //修改为 Array.prototype.slice.call(document.querySelectorAll('div')).forEach((ele, index) => {}); 典型问题 IOS中input的readonly、disabled问题 disabled： 安卓设备上可以显示，IOS 设备上显示空白。解决：改为 readonly 属性。 readonly： IOS 设备上，点击仍会出现软键盘弹框。解决：样式中加 point-events: none。 IOS移动端click事件300ms的延迟相应 移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。这是由于区分单击事件和双击屏幕缩放的历史原因造成的。 fastclick可以解决在手机上点击事件的300ms延迟。 注意：使用了fastclick，可能会引起标签点击失效（非必现）。 zepto的touch模块，tap事件也是为了解决在click的延迟问题。 绑定ontouchstart。触摸屏顺序：touchstart > touchmove > touchend > click。 消除 transition 闪屏 -webkit-transform-style: preserve-3d; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-backface-visibility: hidden; /*(设置进行转换的元素的背面在面对用户时是否可见：隐藏)*/ 打电话发短信写邮件怎么实现 打电话： 打电话给:0755-10086 发短信（winphone 系统无效）：发短信给: 10086 写邮件：peun@foxmail.com 屏幕旋转的事件和样式 window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； window.onorientationchange = function(){ switch(window.orientation){ case -90: case 90: alert(\"横屏:\" + window.orientation); break; case 0: case 180: alert(\"竖屏:\" + window.orientation); break; } } /*竖屏时使用的样式*/ @media all and (orientation:portrait) { } /*横屏时使用的样式*/ @media all and (orientation:landscape) { } fixed元素的bug IOS 下 fixed 元素容易定位出错，软键盘弹出时，影响 fixed 元素定位。android 下 fixed 表现要比 IOS 更好，软键盘弹出时，不会影响 fixed 元素定位。IOS4 下不支持 position: fixed。 暂无完美方案。 Android和Ios设备，打开相机\\选择相册功能 var ua = navigator.userAgent.toLowerCase(); var isIos = (ua.indexOf('iphone') != -1) || (ua.indexOf('ipad') != -1); if (isIos) { $(\"input:file\").removeAttr(\"capture\"); }; 软键盘关闭，元素错位(部分安卓机) 弹层(加了position: fixed)中点击输入框弹出虚拟键盘，在区域1内点击（虚拟键盘关闭），页面元素错位。 原因: 与手机型号和系统版本有关，具体未知 解决方法: 无 相关链接 移动端web常见问题解决方案 H5移动端ios/Android兼容性总结 © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-07-03 12:03:26 "},"bugs/07-微信小程序开发.html":{"url":"bugs/07-微信小程序开发.html","title":"微信小程序开发","keywords":"","body":"微信小程序开发 微信小程序是一种全新的连接用户与服务的方式，它提供了一个简单、高效的应用开发框架和丰富的组件及API，帮助开发者在微信中开发具有原生 APP 体验的服务。 小程序的技术底层依托于 Web 技术，和 Web 端开发相似却又不同。在 Web 中，开发者可以使用浏览器提供的 dom/bom api 来操作渲染内容，同时编写 js 脚本来执行页面逻辑；在小程序中渲染和逻辑则完全分离，开发者可以编写 js 脚本，但是无法直接调用 dom/bom api，渲染和逻辑的交互通过数据和事件来驱动，开发者可以不用再去关心渲染的细节。 小程序与普通web开发的区别 小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 Dom/Bom API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。 Web 开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ 浏览器等，在移动端需要面对 Safari、Chrome 以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的： 运行环境 逻辑层 渲染层 iOS JavaScriptCore WKWebView 安卓 V8 chromium定制内核 小程序开发者工具 NWJS Chrome WebView 小程序的运行环境 微信小程序运行在多种平台上：iOS/iPadOS 微信客户端、Android 微信客户端、Windows PC 微信客户端、Mac 微信客户端、小程序硬件框架和用于调试的微信开发者工具等。 各平台脚本执行环境以及用于渲染非原生组件的环境是各不相同的： 在 iOS、iPadOS 和 Mac OS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS 14、iPad OS 14、Mac OS 11.4 等； 在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由基于 Mobile Chrome 内核的自研 XWeb 引擎来渲染的； 在 Windows 上，小程序逻辑层 javascript 和视图层 javascript 都是用 Chrome 内核； 在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium Webview 来渲染的。 尽管各运行环境是十分相似的，但是还是有些许区别： JavaScript 语法和 API 支持不一致：语法上开发者可以通过开启 ES6 转 ES5 的功能来规避（详情）；此外，小程序基础库内置了必要的 Polyfill，来弥补 API 的差异（详情)。 WXSS 渲染表现不一致：尽管可以通过开启样式补全来规避大部分的问题，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。 开发者工具仅供调试使用，最终的表现以客户端为准。 小程序运行机制 小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。 热启动：用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台。 如果每次打开页面都需要刷新数据，可以在生命周期 onShow 中加刷新逻辑。 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，需要重新加载页面资源。 如果用户很久（目前是 30 分钟）没有使用小程序，或者系统资源紧张，小程序会被「销毁」，即完全终止运行。 JavaScript 支持情况 基于安全考虑，小程序中不支持动态执行 JS 代码，即： 不支持使用 eval 执行 JS 代码 不支持使用 new Function 创建函数 new Function('return this') 除外 小程序常见问题 app.json 未找到? 报错： [ app.json 文件内容错误] app.json: app.json 未找到，未找到入口 app.json 文件,或者文件读取失败,请检查后重新编译。 原因： 由于 project.config.json 文件的 miniprogramRoot 属性找不到 app.json的路径。 场景一： 项目没有 app.json 文件。 原因是你没有打包项目，也就是，没有运行 npm run dev 或者 npm run build 生成小程序的运行文件。小程序打包的文件一般在 dist 目录（具体取决于你项目的编译结果） 。 场景二： 不存在 project.config.json 文件。 小程序运行会先读取根目录下的 project.config.json 配置文件。如果项目根目录下找不到这个文件，可能是你没有打包项目，或者打包生成的 dist 目录的 project.config.json 文件没有自动复制到根目录下（可以手动复制下）。 场景三：project.config.json 文件没有 miniprogramRoot 属性，或者 miniprogramRoot 指定的路径是错误的。 miniprogramRoot 指定小程序运行的根目录，即 app.json 所在的目录。一般是 ./dist/ 或 ./dist/mp/，具体取决于你项目的编译结果。 参考资料： 解决微信小程序报[ app.json 文件内容错误] app.json: app.json 未找到，未找到入口 app.json 文件,或者文件读取失败,请检查后重新编译。小程序app.json报错 开发者工具打开空白？ 项目启动后，微信开发者工具打开页面是空白的，其原因可能是项目指定的小程序源码的目录不对。 以 taro 框架为例： 默认情况下，微信开发者工具以 project.config.json 文件的 miniprogramRoot 配置（默认：\"dist/\"）为小程序源码目录。由于 taro 是支持多端开发的，微信小程序的源码是输出到 dist/weapp，所以微信开发者工具读取的目录是错误的。 解决方法有两种： 修改 project.config.json 或者 project.private.config.json 文件的 miniprogramRoot 配置为 dist/weapp。 微信开发者工具导入小程序项目时，指定为项目下的 dist/weapp 目录。 project.private.config.json 中的相同设置优先级高于 project.config.json。 开发者工具内的设置修改会优先覆盖 project.private.config.json 的内容。如在 project.private.config.json 有 appid 字段，那么在 详情-基本信息 中修改了 appid，则会优先使用开发者工具配置的 appid。 开发阶段相关的设置修改优先同步到 project.private.config.json 中，与最终编译产物有关的设置无法在 project.private.config.json 中生效。 sitemap.json 未找到？ 报错： [ dist/mp/app.json 文件内容错误] dist/mp/app.json: 未找到 [\"sitemapLocation\"] 对应的 sitemap.json 文件。 解决： 在根目录新建一个 sitemap.json 文件： { \"desc\": \"关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html\", \"rules\": [{ \"action\": \"allow\", \"page\": \"*\" }] } 或者在 build 后，dist 文件夹中的 sitemap.json 复制到 根目录下。 怎么清除小程序缓存？ 微信开发者工具： 微信开发者工具顶部工具栏，有【清缓存】功能。 移动端：删除小程序。（如果不启效，尝试把开发版、体验版、线上版都删掉） 微信开发者工具，自定义路径无法打开？ 重现场景： 在主页跳转到某页面，点击 【添加编译模式】，【自定义编译条件】面板会自动添加如下参数。其中重要的两个参数：启动页面，是 dist/mp/pages 文件夹下的页面路径；启动参数，是 type=jump&targeturl=xxx。 如图，自动添加的参数是 type=jump&targeturl=https%253A%252F%252Ftest.miniprogram.com%252Firr，但该页面打开是空白的： 原因： 是微信开发者工具，自动添加的参数 targeturl 有误。将该值解码后，得到的并不是正确的页面路径： decodeURIComponent('https%253A%252F%252Ftest.miniprogram.com%252Firr') // https%3A%2F%2Ftest.miniprogram.com%2Firr 解决方法： 手动 encodeURIComponent 页面路径，配置到面板中【启动参数】属性的 targeturl 参数。 encodeURIComponent('https://test.miniprogram.com/irr') // https%3A%2F%2Ftest.miniprogram.com%2Firr 正确配置： type=jump&targeturl=https%253A%252F%252Ftest.miniprogram.com%252Firr。 扩展： Q：已知 location.href，如何封装成对应的小程序的页面路由？ A：先找到对应的页面路径，假设是 pages/home/index，那么封装方式：/pages/home/index?type=${type}&targeturl=${encodeURIComponent(location.href)}&search=${encodeURIComponent(location.search)}&hash=${encodeURIComponent(location.hash)}。type 支持 open（新开页面）、jump（页面内跳转）和 share（分享进入），一般在配置体验版、添加工具模式等情况下使用 type=open 即可；targeturl 是经过编码的 location.href（也可以是 /test/abcde?id=123#hash 这样不带 origin 的 url，以缩减页面路由的长度，kbone 会自动取配置中的 origin 进行拼接）；search 和 hash 可传可不传，如若不传，则取 targeturl 中的 search 和 hash 进行解析。 参考资料： 小程序自定义路径无法打开。 #252 wechat-miniprogram / kbone—— Q&A 其他 小程序中不支持 Table 标签。 小程序不支持远程加载 Js、Css； 服务器接口：必须是 https 协议请求，同时请求的域名需要在小程序管理平台进行配置。本地开发时，可在微信开发者工具右上角 详情 -> 本地设置 中，关闭域名校验； 小程序里的所有页面必须同源； 小程序不支持动态追加未声明的属性：如 vue style 的 scoped 属性； 本地资源不能通过 wxss 获取； background-image： 可以使用网络图片或者 base64 格式； background-image: url(https://www.test.com/images/test.jpg); background-image: url(data:image/png;base64,...); 使用 image 标签。 个人或海外公众号不支持 webview 内嵌h5页面。webview中内嵌的链接来源必须在业务域名内。 wx.navigateTo 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。 开发框架 kbone kbone 是一个致力于微信小程序和 Web 端同构的解决方案。 微信小程序的底层模型和 Web 端不同，我们想直接把 Web 端的代码挪到小程序环境内执行是不可能的。kbone 的诞生就是为了解决这个问题，它实现了一个适配器，在适配层里模拟出了浏览器环境，让 Web 端的代码可以不做什么改动便可运行在小程序里。 它有以下特性： 大部分流行的前端框架都能够在 kbone 上运行，比如 Vue、React、Preact 等。 支持更为完整的前端框架特性，因为 kbone 不会对框架底层进行删改（比如 Vue 中的 v-html 指令、Vue-router 插件）。 提供了常用的 dom/bom API，让用户代码无需做太大改动便可从 Web 端迁移到小程序端。以于一些无法完美兼容到小程序端的 API 也提供了一些 dom/bom 扩展 API，比如：getComputedStyle、$$getBoundingClientRect 接口。 可使用 kbone-ui。kbone-ui 是一个支持在 Web 端使用小程序内置组件和 weui 组件的 UI 库。 kbone 在小程序端支持了内置组件和 weui 组件库的使用，但是这些是小程序端的特性，在 Web 端不可使用。kbone 提供了 kbone-ui 来磨平大部分的组件实现差异，方便跨端同构。 kbone-ui 目前有两个实现版本，版本间无法兼容： 1.x 版本：基于 Web Components 实现，无框架依赖，支持更完整的组件列表 0.x 版本：基于 vue 实现，可通过 npm install kbone-ui@core-v0 安装。 可使用 kbone-api。Kbone-API 是一个能同时支持小程序和 Web 端的多端 API 库。它有以下特征： 针对基于 Kbone 的多端开发，满足在 Web 上直接使用小程序相关 API 不依赖 Kbone 和 Kbone-UI，一个无依赖的小程序 API 的跨端库 完整对齐 wx[apis] 同时支持 promise 化和 callback 调用 Taro Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。 它有如下特性： 多端转换支持： Taro 3 可以支持转换到 H5、ReactNative 以及任意小程序平台。 框架支持： 在 Taro 3 中可以使用完整的 React / Vue / Vue3 / Nerv 开发体验。 Taro UI： 一款基于 Taro 框架开发的多端 UI 组件库。Taro UI 特性： 基于 Taro 开发 UI 组件； 一套组件可以在多端适配运行（ReactNative 端暂不支持）； 提供友好的 API，可灵活的使用组件。 uni-app uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台。 mpvue mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。 mpvue 作为小程序版本的 Vue.js，在框架 SDK 之外，完整的技术体系还包括如下设施： mpvue-loader： 提供 webpack 版本的加载器 mpvue-webpack-target： webpack 构建目标 postcss-mpvue-wxss： 样式代码转换预处理工具 px2rpx-loader： 样式转化插件 mpvue-lint： 开发辅助插件，包括语法检查，内存检查等功能 注意： mpvue 已长时间未更新了，最近一次更新是2年前（当前 2021年11月）。 kbone常见问题 web 端，vue-router 单页面打开空白？ 表现： vue-router 的 history 模式，在浏览览器中打开，id='app' 节点内没有内容，页面对应的 Js 没有加载。 原因： 未知 解决： 改用 hash 模式。 web 端怎么使用小程序 API？ 比如，wx.showToast 是小程序端的 API，web 端无法使用。 解决： 使用 kbone-api。Kbone-API 是一个能同时支持小程序和 Web 端的多端 API 库。 import kboneAPI from 'kbone-api' kboneAPI.showToast({ title: 'use kbone-api' }) // 或者 Vue.use(kboneAPI) this.$api.showToast({ title: 'use kbone-api' }) 小程序端如何获取元素宽高？ Dom.$$getBoundingClientRect().then((res) => { console.log(res.width) console.log(res.height) }) © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-05-11 19:10:07 "},"bugs/99-其他问题汇总.html":{"url":"bugs/99-其他问题汇总.html","title":"其他问题汇总","keywords":"","body":"其他问题汇总 修改hosts文件 文件位置： Windows：C:\\Windows\\System32\\drivers\\etc\\hosts Mac：/etc/hosts 清除DNS缓存： Winodws：打开CMD，输入ipconfig /flushdns（刷新）、ipconfig /displaydns（查看） Linux：在终端运行， sudo killall -HUP mDNSResponder； 浏览器：Chrome 地址栏输入， chrome://net-internals/#dns，点击 clear host cache。 hosts 文件用记事本打开，一般需要管理员权限才能修改； 可以将 hosts 文件复制出来，修改完成后，再替换到 etc 文件夹中； 也可以修改 hosts 文件的权限：右键hosts –> 属性 –> 安全 -> 编辑，添加【写入】权限。 避免使用 null 值 前端调用服务端接口时，尽量避免传递 null 值。因为，服务端使用架包解析接口传参时，可能会忽略值为 null 的字段。最终可能导致字段本该为 null，最终读取时为 undefined（即，直接不传该字段）。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-07-23 11:03:20 "},"css探索系列/00-CSS基础知识.html":{"url":"css探索系列/00-CSS基础知识.html","title":"CSS基础知识","keywords":"","body":"CSS基础知识 什么是幽灵空白节点？ 在 HTML5 规范中有这样一句话： Each line box starts with a zero-width inline box with the element's font and line height properties. We call that imaginary box a 'strut'. 每个行框盒子都以一个具有元素的字体和行高属性的零宽度行内框开始。我们称这个假想的盒子为\"支柱\"。 在HTML5 文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个 “空白节点” 永远透明，不占据任何宽度，也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样。也就是官方规范中的“strut”，在张鑫旭《CSS 世界》一书中根据其特点，称之为 “幽灵空白节点”。 幽灵空白节点引起的典型问题是：内联元素与父元素的底部会留有空白，比如 img 标签图片空隙。留空白的具体原因及解决方法，可查看 img元素底部为何有空白？。 什么是空白字符？ 浏览器会把内联元素间的空白字符（空格、换行、Tab 等）渲染成一个空格，该空格会占用一定宽度。而为了美观，我们通常在编写代码时，让一个标签占用一行。这样就导致标签之间会有空白字符。 空白字符与幽灵空白节点的区别： 相同点：都是不可见、有行高的行内框，都会引起内联元素与父元素的底部留空白问题； 不同点：空白字符是有宽度的，它还会导致两个相连内联元素在水平方向空白。 解决水平方向空白的办法： 父元素与子元素之间、多个子元素之间不要有空白字符（空格、换行、Tab 等）； 父元素的 font-size 设置为 0，在子元素内定义需要的 font-size（注意： Safari 浏览器可能依然会出现空白间隔）； 让 Chrome 支持小 12px 的文字 在 Chrome 下，CSS 设置字体大小为 12px 及以下时，显示都是一样大小，都是默认 12px。 -webkit-text-size-adjust： -webkit-text-size-adjust:none，字体大小就不受限制了，但是 Chrome 更新到 27 版本之后就不可以用了。 scale(0.5)： transform: scale(0.5) 可以缩小字体，默认是以元素的中心为源点，可以通过 transform-origin 修改。注意，缩小的是整个元素的大小，且元素必须是块元素。 使用图片。 常见的元素隐藏方式 display: none： 元素不占空间，也不会响应绑定的监听事件。 visibility: hidden： 元素仍占据空间，但是不会响应绑定的监听事件。 opacity: 0： 元素仍占据空间，并且能够响应元素绑定的监听事件。 z-index： 设置负值，使其他元素遮盖住该元素。 clip/clip-path： 元素仍占据空间，但是不会响应绑定的监听事件。 transform: scale(0,0)： 元素仍占据空间，但是不会响应绑定的监听事件。 height: 0： 元素仍占据空间，但是不会响应绑定的监听事件。 通过绝对定位将元素移除可视区域内。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-01-22 17:45:17 "},"css探索系列/02-由z-index引发的层叠上下文思考.html":{"url":"css探索系列/02-由z-index引发的层叠上下文思考.html","title":"由Z Index引发的层叠上下文思考","keywords":"","body":"由z-index引发的层叠上下文思考 CSS 通常被简称为样式或者样式表，而 CSS 其实是 Cascading Style Sheets 的缩写，翻译为层叠样式表。这里的层叠是 CSS 的一个基本特征，也是 CSS 的一个核心概念，它定义了合并来自多个源的属性值的算法。 此外，CSS 中还有另一个层叠的概念——层叠上下文，它是三维空间 Z 轴上，元素盒子之间的层叠。这里的层叠，意味着可覆盖，用户只能够看到 Z 轴上最上层的东西，开发者必须将最终要的东西放在最上层，让用户能够一眼就看到。 Cascading 层叠样式表中的层叠（Cascading），可以翻译为级联。 CSS 定义了三种可能的样式表来源：开发者、读者和浏览器，它们的作用范围是重叠的，而层叠则就是定义它们如何相互作用的算法，它决定如何找出要应用到每个文档元素的每个属性上的值。 层叠顺序如下： 首先，过滤来自不同源的全部规则，只保留要应用到当前页元素的那些规则。 其次，它依据重要程度对这些规则进行排序。重要程度指的是规则后面是否跟随者 !important 以及规则的来源，重要程度按升序排序如下： 用户代理（浏览器）； 读者：即浏览网页的用户，他们可以通过浏览器提供的接口为网站添加读者样式； 开发者； CSS 动画：@keyframes 定义状态的动画。@keyframes 定义的值会覆盖全部普通值，但会被 !important 的值覆盖。 注意： @keyframes 不参与层叠，即任何时候 CSS 都是取单一的 @keyframes 的值，而不会是某几个 @keyframe的混合。如果有多个满足条件的关键帧时，来源最重要的样式表定义的 @keyframes 会被选中。 开发者 + !important； 读者 + !important； 用户代理（浏览器） + !important； CSS 过渡（transitions）。 假如层叠顺序相等，则使用哪个值取决于优先级（详见CSS 优先级算法如何计算？）。 特别注意： 层叠算法是先于优先级是两个不同概念，层叠算法是先于优先级算法的。比如：即使读者定义的规则有更高的优先级，CSS 也会优先选择开发者定义的样式。 注意： 标记为 !important 样式，读者样式比开发者样式重要。这实际上这是 CSS 提供的一个很好的选择机制，也就是说，通常情况下，开发者样式会拥有最大的权重，但是用户拥有最终的选择权，可以通过 !important 覆盖任何样式。 Stacking 层叠上下文中的层叠（Stacking），可以翻译为堆叠，指的是盒子在 Z 轴上的位置与盒子之间的重叠关系。在 CSS 2.1中，每一个盒子处在三维空间中，除了水平轴和垂直轴外，还有一个 Z 轴，这三个轴共同决定了盒子在三维空间中的位置。 层叠上下文中，更靠近用户的元素优先被读者看到——更靠近用户，可理解为在 Z 轴的层级更高。 对应的英文名词解释 英文名词翻译为中文名词容易产生歧义，以下列出本文涉及的名词对应的英文名词： 非定位元素： Non-positioned Element，也就是 position: static 元素； 定位元素：Positioned Element，也就是 position: relative|absolute|fixed|sticky 元素； 盒子：box，也称盒模型。文档树由元素组成，渲染树由盒子组成，实际元素大小、布局渲染操作的对象是盒子而不是元素。在构造渲染树时会为每个元素生成对应的盒子。但盒子不一定全部由元素生成，如：匿名盒子（anonymous box）不是由元素对应生成，而是渲染器根据规则自动生成。 非/定位盒子： Non-positioned/Positioned Element，非定位元素对应的是非定位盒子，定位元素对应的是定位盒子。 层叠上下文： Stacking Context，也称堆叠上下文，Z 轴的基本组成单位。层叠上下文与盒子的映射关系为 1:N，即每个层叠上下文可以有 N 个盒子。每个层叠上下文有一个父层叠上下文（除根层叠上下文）和 0~N 个子层叠上下文。 根层叠上下文： Root Stacking Context，根盒子（html|body对应的盒子）对应的层叠上下文，是其他层叠上下文的祖先上下文，根层叠上下文的范围覆盖整条 Z 轴。 层叠等级： Stack Level，也有称层叠水平、层叠层级，当 N 个盒子位于同一个层叠上下文中，则通过层叠等级来决定它们位于 Z 轴上的位置。 层叠顺序： Stacking Order，表示元素发生层叠时特定的垂直显示顺序。 一切从 z-index 开始 CSS 的 z-index 的理解容易陷入一个误区：z-index 属性值大的元素会覆盖 z-index 属性值小的元素，更致命的是，在日常开发中，我们看到的表现也大抵如此，这也造成我们忽略一个重要——层叠上下文。 先看一个简单示例： 一个简单的 z-index DEMO 如果按 z-index 来比较，层级排序应该是：红色（10） > 青色（9） > 紫色（8） > 橙色（-999） ，而实际上，前三者的表现也正是如此，唯独橙色（-999）——这个本该在无尽深渊的元素，一举超出其他元素，高居在上。 这种现象就跟本文的主角——层叠上下文有关了： 首先，走出上述 z-index 的误区，正确理解是：同一个层叠上下文的 z-index 才具有可比性。 对于定位元素而言，若 z-index 属性值不是 auto，则会创建一个新的层叠上下文，并且其子孙盒子将属于这个新层叠上下文，因此，橙色（-999）实际是跟父盒子在同一层叠上下文，它比青色（9）、紫色（8） 更靠近用户。 z-index 只是层叠上下文中的一个属性而已，准确理解 z-index，实质上就是要理解层叠上下文。 什么层叠上下文？ 层叠上下文（Stacking context）是 HTML 中的一个三维的概念，是指一个独立的环境，与块级上下文类似（BFC），即层叠上下文内的盒子都被限制了，它们的在 Z 轴的位置不受外面其他层叠上下文的影响，也不影响外面的其他层叠上下文。 在 CSS2.1 规范中，每个盒模型的位置是三维的，分别是平面画布上的 X 轴、Y 轴，以及表示层叠的 Z 轴。X 轴指向屏幕的右边，Y 轴指向屏幕的底部，Z 轴的方向指向读者。 一般情况下，元素在页面上沿 X 轴、Y 轴平铺，我们察觉不到它们在 Z 轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。 什么是层叠规则？ 层叠规则决定了到底哪个盒子更靠近用户： 同一个层叠上下文，两个有同级层叠上下文的盒子，z-index 属性值大的盒子更靠近用户。 同一个层叠上下文，有层叠上下文的盒子平比普通元素的盒子更靠近用户。 同一个层叠上下文且 z-index 相同的盒子，对应元素在文档中后者比前者的更靠近用户。 不同的层叠上下文，并且层叠上下文没有祖孙/父子关系的两个盒子，会向上沿着父盒子进行搜索，直到两者父盒子属于同一个层叠上下文为止，然后比较父盒子的 z-index 属性值，z-index 属性值大的盒子更靠近用户。 不同的层叠上下文，并且层叠上下文为祖孙/父子关系，子层叠上下文的盒子必定更靠近用户。 什么是层叠等级? 层叠等级（Stack Level），也有译为层叠水平、层叠层级。它描述了元素在当前层叠上下文中 Z 轴上的顺序。 所有的元素都有层叠等级，包括层叠上下文元素、普通元素。 层叠等级的比较只有在当前层叠上下文元素中才有意义。 不要将层叠等级和 z-index 属性混为一谈： z-index 只影响定位元素以及 Flex 盒子的子元素；而层叠等级所有的元素都有的。 什么是层叠顺序？ 层叠顺序（Stacking Order）表示元素发生层叠时特定的垂直显示顺序。 注意： 层叠上下文和层叠等级是概念，而层叠顺序是规则。 在 HTML 文档中，默认情况之下有一个自然层叠顺序（Natural Stacing Order），即元素在 Z 轴上的顺序。元素盒子放入层叠上下文的顺序，从层叠的底部开始，共有七种层叠等级（由低到高）： 背景和边框：形成层叠上下文的元素的背景和边框； 负 z-index 值：层叠上下文内有着负 z-index 值的定位元素； 块级盒：层叠上下文内的非定位块级元素； 浮动盒：层叠上下文内的非定位浮动元素； 行内盒：层叠上下文内的非定位内联元素—— inline|inline-block 元素等级要高于 block|float 元素； 普通层叠上下文：z-index:0|auto 的定位元素的层叠上下文，或者不依赖于 z-index （如：opacity:0.9 ）的层叠上下文。 正 z-index 值：层叠上下文内有着正 z-index 值的定位元素。 注意： z-index: 0 （创建了层叠上下文）的元素、 z-index: auto （不创建层叠上下文）的元素、不依赖于 z-index 的层叠上下文的元素，这三者的层叠顺序是一样的，遵循后者比前者更靠近用户的层叠规则。 如何创建层叠上下文？ 一个简单的示例：尝试把红色元素放到其他两个元素后面，但是必须遵守下面的规则 点击试试？： 不能修改 HTML 中元素的顺序； 不能增加或修改任何元素的 position 和 z-index 属性； 创建层叠上下文 DEMO 你想到解决方法了吗？ 其实很简单，你只需要给第一个 div 标签的 opacity 属性加一个小于 1 的值。注意：这里说的是第一个 div 标签，不是 p 标签。 原理解释：一开始有两个层叠上下文，一个由根节点产生，一个由红色的 P 标签产生。当我们给第一个 div 设置 opacity: 0.99 时，产生了第三个层叠上下文，并且会把红色的 P 标签提到这个层叠上下文。也就是说，现在的层级比较是红色 div 标签和下面两个 p 标签，由于第一个 div 创建的是不依赖 z-index 的层叠上下文，而其他两个元素 p 标签是 z-index: auto 的层叠上下文，它们的等级是一样的。按层叠顺序，文档中后面出现的更靠近用户，即两个元素 p 标签在 Z 轴位置都比第一个 div 标签及其子标签更高。 特意注意： 第一个 div 的层级只是比后两个 p 标签低，但它仍然比后面两个 div 标签更高。 我们把 P 删除，给 div 加上边框，效果显示如下： 创建层叠上下文 DEMO2 当然，以上问题，opacity: 0.99 并不是唯一的方法，关键是掌握层叠上下文是如何创建的。 满足以下任意一个条件的元素： 文档根元素（html）； position: relative|absolute|fixed 且 z-index 值不为 auto 的元素； position: fixed|sticky 元素，注意：CSS2 中，position: fixed 必需设置 z-index 为非 0 值 ，而 CSS3 中只要设置 fixed 就会创建层叠上下文； opacity 属性值小于 1 的元素； 以下任意属性值不为 none 的元素：transform、filter、perspective、clip-path、mask/mask-image/mask-border； flex 容器的子元素，且 z-index 值不为 auto； grid 容器的子元素，且 z-index 值不为 auto； mix-blend-mode 属性值不为 normal 的元素； isolation属性值为 isolate 的元素； -webkit-overflow-scrolling 属性值为 touch 的元素； will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素； contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。 注意： 前面两条是 CSS2 的创建方法，后面的都是 CSS3 新增的。 层叠上下文还有以下特性： 层叠上下文可以包含在其他层叠上下文中，并且受该层叠上下文限制； 每个层叠上下文都完全独立于它的兄弟元素； 每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。 注意： 层叠上下文的层级是 HTML 元素层级的一个子级，因为只有某些元素才会创建层叠上下文。可以这样说，没有创建自己的层叠上下文的元素会被父层叠上下文同化。 z-index 在层叠中起什么作用呢？ 从 z-index 开始，也从 z-index 结束吧！ 简单来说，z-index 只有一个作用：修改定位盒子在其所属的层叠上下文中的层叠等级。 前面所说的，所有元素都有层叠等级，z-index 就是修改定位元素的层叠等级。 z-index 有以下的特性： z-index 属性值仅对定位盒子生效，而非定位盒子永远是 z-index: auto； z-index 属性值不为 auto，则会创建一个新的层叠上下文，并且其子孙盒子将属于这个新层叠上下文； z-index 属性值为 auto，盒子不会创建一个新的本地层叠上下文，其层叠等级和父级盒子相同； 这个是 CSS3 标准，也有如下说法（可能是css2）： 对于具有 z-index：auto 的盒子，将其视为已创建新的层叠上下文，但是该层叠上下文的后代应视为父级层叠上下文的一部分，而不是此新层叠上下文的一部分。 同一个层叠上下文的 z-index 才具有可比性： 常说的，z-index 越大层叠等级越高，是基于在同一层叠上下文内的。 z-index 可以设置为负值。值为负的盒子比较特殊，它们会先被绘制，意味着它们可以出现在其它盒子的后面，包括父盒子。但是必要条件是该盒子必须与父盒子处于同一层叠上下文，并且父盒子不是这个层的根盒子。 示例：z-index 仅对定位盒子生效 如：将第一 DEMO 中的 position: relative 都删除，你会发现所有的 z-index 值都失效了： 当然，改成 position: absolute|fixed|sticky，z-index 也是有效的，不过它们的表现行为是不一样的，且有各自的特性。 示例：z-index 值为 auto 和 0 的区别 z-index: 0 和 z-index: auto 单纯从层叠等级上看，是可以看成是一样的。注意这里的措辞——“单纯从层叠等级上看”，实际上，两者在层叠上下文领域有着根本性的差异。 如图所示：红色 p 标签位于紫色 p 标签的上方。这个似乎没什么问题？毕竟红色 p 标签的 z-index 值大于紫色 p 标签！ 查看 auto 和 0 的区别 DEMO 接下来，我们把 div 标签中 z-index: auto 改为 z-index: 0： 结果：紫色的 p 标签位于红色 p 标签的上方。 按照前面的【层叠规则】和【 z-index 的特性】解释下： z-index: auto 不会创建层叠上下文，所以两个 p 标签属于同一层叠上下文，谁的 z-index 值大，谁就更靠近用户。 z-index: 0 会为两个 div 标签创建新的层叠上下文，并且 p 标签会属于各自的父层叠上下文。如此，这两个 p 标签就没有可比性了，它们的层叠等级取决于父层叠上下文，即 div 的层叠上下文，而两个 div 的层叠上下文的等级是一样的，所以，最后遵循后者比前者更靠近用户的规则。 常见问题 为什么建议给 absolute 元素加 z-index？ 影斑驳，叶落纷纷，一路的繁华，消瘦在秋风里。 .box_05 { width: 300px; position: relative; } .box_05 > img { display: block; width: 100%; } .box_05 > p { position: absolute; left: 0; bottom: 0; padding: 10px; margin: 0; background: rgba(255, 255, 255, 0.8); opacity: 1; } 试一试？修改图片透明度 当我们给图片添加透明度动画时，将图片的 opacity 属性值设置为小于 1（如：0.99），则图片会遮掉文本。因为，img 标签创建了新层叠上下文（opacity: 0.99），且该层叠上下文与 p 标签创建的层叠上下文（z-index: auto）同级，遵循层叠顺序规则，后者比前者更靠近用户。 当然，z-index 不是必需的，如果你完全理解了层叠上下文，并且代码风格良好，你可以忽略它。 IE6/7的诡异行为 IE6~7 浏览器中，只要是定位元素就会创建层叠上下文， 就算z-index:auto也会。 参考链接 CSS魔法堂：你真的理解z-index吗？ 深入理解CSS中的层叠上下文和层叠顺序 CSS 开发者指南-层叠上下文 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-05-02 20:48:38 "},"css探索系列/03-由浮动塌陷引发的块级格式上下文思考.html":{"url":"css探索系列/03-由浮动塌陷引发的块级格式上下文思考.html","title":"由浮动塌陷引发的块级格式上下文思考","keywords":"","body":"由浮动塌陷引发的块级格式上下文思考 浮动最初的定义：实现文本环绕图片的效果。除此之外，没有其他方法可实现。 查看文本环绕DEMO 什么是浮动? CSS 中的浮动是用 float 属性来定义：float: left | right | none | inline-start | inline-end float 属性值不为 none，会对 display 属性的值产生影响： block、inline-block、inline、table-* -> block inline-table、table -> table flex、inline-flex -> 值不变，但是 float 对这样的元素不起作用 其他值不变 当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。浮动元素不属于文档中的普通流，属于浮动布局。顾名思义，浮动就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。 CSS 有三种基本的定位机制：普通流、浮动（float: left|right）和绝对定位（position: absoulte）。 注意： 浮动元素只在水平方向浮动，也就是说，只能左右移动而不能上下移动；并且它会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止，也就是说，它只能居左或居右，而无法居中。 读书，去别人的灵魂里偷窥。旅行，去陌生的环境里去感悟。电影，去荧屏里感受别人的生活历程。冥想，去自己内心的秘境里探寻。读书，去别人的灵魂里偷窥。旅行，去陌生的环境里去感悟。电影，去荧屏里感受别人的生活历程。冥想，去自己内心的秘境里探寻。 .box_02 img { width: 100%; } .box_02 > .item_02 { padding: 20px; border: 1px solid #0aa; } .box_02 > .item_02 .container_float, .box_02 > .item_02 .img_float { float: left; width: 100px; margin-left: 20px; margin-right: 20px; } .box_02 > .item_02 .bg { height: 50px; margin-top: 5px; background: #0aa; } 查看 float DEMO 浮动会造成哪些影响呢？ 浮动元素会对其相邻元素和父元素造成不同影响： 对相邻元素（紧邻浮动元素后面的元素）： 如果相邻元素是普通流的块级元素，则不会影响块级元素的布局（如上图的背景色模块——块级元素与浮动元素处于同一行，但其宽度占据了父元素的整个内容区域，浮动元素只是悬浮在块元素上方），但会影响块级元素包含的内联元素的排列（内联元素环绕浮动元素）； 如果相邻元素是普通流的内联元素，则会影响内联元素的布局和其包含的内联元素的排列（如上图的文本模块——内联元素的位置是紧跟浮动元素，而不是从父元素的最左侧开始，且文本会尽可能围绕浮动元素）。 注意： 浮动元素之前的元素将不会受到影响。 对父元素： 父元素在获取高度计算时，会忽略浮动元素，即不计算浮动元素高度。这就是浮动塌陷，也称高度塌陷现象。 什么是块级格式化上下文? 块格式化上下文（Block Formatting Context，BFC） 是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。一个元素创建了 BFC 后，它就拥有了一个独立的环境，该环境内的子元素不会影响外面元素的布局，同样，外面的元素也不会影响其子元素的布局。 块级格式化上下文的特性与层叠上下文相似，都是指独立的空间，不过，块级格式化上下文是 x、y 的独立空间，而层叠上下文是 z 轴上的独立空间。 BFC 有哪些特性？ 块格式化上下文对浮动定位（float）、清除浮动（clear）、外边距折叠（Margin collapsing）都很重要。浮动定位和清除浮动时只会应用于同一个 BCF 内的元素。外边距折叠也只会发生在属于同一 BFC 的块级元素之间。 BFC 的三个特性： BFC 会阻止外边距折叠（CSS探索系列之Margin） 当两个相邻的块框在同一个块级格式化上下文中时，它们之间垂直方向的外边距可能会发生叠加。换句话说，如果这两个相邻的块框不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。 BFC 不会重叠浮动元素 BFC 内的浮动不会影响其它 BFC 中元素的布局，而 clear 属性只能清除同一 BFC 中在它前面的元素的浮动。 BFC 通常可以包含浮动，即计算 BFC 的高度时，浮动元素也参与计算 独立的块级上下文可以包裹浮动流，全部浮动子元素也不会引起容器高度塌陷，也就是说父元素会把浮动元素的高度也计算在内，所以不用清除浮动来撑起高度。同时 BFC 仍然属于文档中的普通流。 也就是说，如果父元素创建了 BFC，就可以闭合浮动，避免浮动塌陷现象 如何为元素创建 BFC？ 一般来说，是通过 display 属性来创建 BFC ，具体如下： 根元素 浮动元素： float 属性值不为 none； 绝对定位元素： position 属性值不为 static|relative； 行内块元素： display 属性值为 inline-block； 元素的 overflow 属性值不为 visible； 表格单元格：display: table-cell； 表格标题：display: table-caption 匿名表格单元格元素：display: table | inline-table | table-row | table-row-group | table-header-group | table-footer-group 元素的 display 属性值为 flow-root。这是一个新的属性值，可以创建无副作用的 BFC，但 Safari 不支持。 弹性元素：display: flex | inline-flex 元素的直接子元素 网格元素：display: grid | inline-grid 元素的直接子元素 contain: layout | content | paint 多列容器：column-count 或 column-width 不为 auto、column-count: 1 column-span: all。即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 注意：display: table 本身并不会创建 BFC，但是它会产生匿名盒子，而匿名盒子中的 display: table-cell 可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是 display: table。所以通过 display: table 和 display: table-cell 创建的 BFC 效果是不一样的。 什么是 hasLayout? hasLayout 是 IE 浏览器私有的概念，可以简单看作是 IE 5.5/6/7 中的 BFC！ IE 浏览器使用 Layout 概念来控制元素的尺寸和位置。如果一个元素有 Layout，相当于元素创建了 BFC，其尺寸和位置以自身的内容进行计算（如：可通过width、height 来设置自身的宽高）；否则，相当于没有 BFC，它的尺寸和位置由最近的拥有 Layout 的祖先元素控制。 IE 浏览器，可能通过如下方法判断元素是否有 Layout： // 返回 true 表示有 Layout，否则就是没有 Element.currentStyle.hasLayout 需要注意的是： hasLayout 是一个只读属性，所以无法通过 Javascript 进行设置，只能通过一些 CSS 属性间接创建； 与 BFC 不同的是：有些 CSS 属性是以不可逆方式间接创建 Layout，并且默认创建 BFC 的只有 html 元素，而默认 Layout 的元素就不只有 html 元素了。 哪些元素有 Layout？ 如何为元素创建 Layout？ display: inline-block； width、height 属性值为除 auto 外的任意值； float: left|right； position: absolute； writing-mode: tb-rl； zoom 属性值为除 normal 外的任意值； IE7 还有一些额外的属性：min-height|min-width 属性值为任意值；max-height|max-width 属性值为除 none 外的任意值；overflow|overflow-x|overflow-y 属性值除 visible 外的任意值（仅用于块级元素）、position: fixed。 需要注意： 创建 BFC 和 创建 Layout 的方式不完全重叠，因此 Layout 所引发的问题，很大程度可以理解为在不应该的或没有预料到的地方创建了 BFC 导致的。 IE6 以前的版本（也包括 IE6 及以后所有版本的混杂模式，其实这种混杂模式在渲染方面就相当于 IE 5.5）， 通过设置任何元素的width、height 属性值（非 auto）都可以创建 Layout ； 但在 IE6 和 IE7 的标准模式中的行内元素上却不行，只能设置 display: inline-block 才可以。 display: inline-block|min-width: 0|min-height: 0 将不可逆地创建 Layout，而在其他属性创建的 Layout 可通过上面创建方法，逆向关闭。如：position: static，zoom: normal 、max-height|max-width 属性值为 none （IE 7）等。 怎样清除浮动呢？ 清除浮动，也可以称为闭合浮动。两者都是为了消除浮动元素产生的影响，即浮动塌陷。 它们的区别在于： 清除浮动： 对应 CSS 中的 clear：left|right|both|none，只能清除同一 BFC 中，在它前面的元素的浮动。 闭合浮动：更确切的含义是使浮动元素闭合，即创建 BFC，从而消除浮动塌陷。 确切的说，我们想要达到的效果是闭合浮动，而不是单纯的清除浮动。单纯的清除浮动，并不能解决容器高度塌陷的问题。 比如：我们将上一个示例的背景色模块，加上样式 clear: both 清除浮动，该模块的浮动还是会影响其后面的兄弟元素。如下图3： ... 查看DEMO 再如：我们将上一个示例的背景色模块，加上样式 display: flow-root 闭合浮动，创健了新 BFC，那么，它就不会影响其他 BFC 的元素了。如下图4： ... 查看DEMO 三种清除浮动的方法 方法一（摧荐）： 父元素加伪元素，并给伪元素 ::after 加 clear：both ，据说是最高大上的方法。 优点：浏览器支持好，不容易出现怪问题。 缺点： 需要全局定义一个清除浮动的 .clear_float，且要加在标签上。 .clear_float { /*对IE6/7的兼容处理，触发 hasLayout*/ zoom: 1; } .clear_float:after, .clear_float::after { clear: both; content: '.'; display: block; width: 0; height: 0; visibility: hidden; } ... ... 查看DEMO 方法二：浮动元素后，新增空标签 div，并设置样式 clear：both 。 优点：通俗易懂，容易掌握。 缺点：将添加很多无意义的空标签。 ... ... 查看DEMO 方法三：浮动元素后，新增空标签 br 标签，并设置属性 clear=\"both\"，与方法二类似： ... ... 查看DEMO 闭合浮动的方法 为浮动元素的父元素创建 BFC（为兼容 ie6，还需触发 hasLayout，如加：zoom: 1）： display: inline-block（推荐）； overflow: auto|hidden|visible：据说 auto 对 SEO 比较友好， hidden 对 SEO 不是太友好。缺点是内部元素宽高超过父元素时，会出现滚动条或者隐藏溢出部分； float: left|right： 缺点是使得与父元素相邻的元素的布局会受到影响； display: table： 缺点是盒模型属性已经改变，由此造成的一系列问题，得不偿失； display: flow-root：缺点是 Safari 不支持。 常见问题 clear 属性清除浮动的原理？ 使用 clear 属性清除浮动，其语法如下： clear: none|left|right|both 官方对 clear 属性的解释是：一个元素是否必须移动（清除浮动后）到在它之前的浮动元素下面。我们对元素设置 clear 属性只是避免了浮动元素对该元素的影响，实际上，浮动一直还在，并没有清除。 当应用于非浮动块时，它将非浮动块的边框边界移动到所有相关浮动元素外边界的下方；当应用于浮动元素时，它将元素的外边界移动到所有相关的浮动元素外边框边界的下方。这会影响后面浮动元素的布局，后面的浮动元素的位置无法高于它之前的元素。 BFC 和 IFC 有什么区别？ Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. Block-level boxes participate in a block formatting context. Inline-level boxes participate in an inline formatting context. 在普通流中的盒子会参与一种格式上下文，这个盒子可能是块盒也可能是行内盒，但不可能同时是块盒又是行内盒。块级盒参与块级格式上下文（BFC），行内级盒参与行级格式上下文（IFC）。 BFC 的特性： 在 BFC 中，盒子都是从它的包含块的顶部一个一个的垂直放置的。两个相邻盒子的垂直间距决定于 margin 属性。在同一 BFC 中，两个相邻块级盒子之间垂直方向上的外边距可能会塌陷的。 在 BFC 中，每个盒子的左外边界挨着包含块的左边界（与文档书写模式有关）。即使是存在浮动元素也是如此（即使一个盒子的行盒是因为浮动而收缩了的）除非这个盒子创建了新的 BFC（在某些情况下这个盒子自身会因为浮动而变窄）。 IFC 的特性： 在 IFC中，盒子水平放置，一个接着一个，从包含块的顶部开始。水平方向的 margins|borders|padding 在这些盒子中被平分。这些盒子也许通过不同的方式进行对齐：底部、顶部、基线对齐。矩形区域包含着来自一行的盒子叫做行盒子。 行盒子的宽度由浮动情况和它的包含块决定；行内盒子的高度由 line-height 的计算结果决定。 当一行不够放置的时候会自动切换到下一行，IFC 的高度，由里面最高盒子的高度决定。 在行内方向上，各行盒通常具有相同的尺寸，即在水平书写模式下，它们有同样的宽度；在垂直书写模式下，它们有同样的高度。但是，如果同一个块格式化上下文中存在一个 float，则这个浮动元素将导致包裹了它的各行框变短。 参考链接 MDN float MDN 块格式化上下文 CSS魔法堂：hasLayout原来是这样的！ © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-01-16 17:46:20 "},"css探索系列/04-CSS探索系列-flex布局.html":{"url":"css探索系列/04-CSS探索系列-flex布局.html","title":"CSS探索系列 Flex布局","keywords":"","body":"CSS探索系列之flex布局 当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）。每个盒子由四个部分组成：内容 Content、内边距 Padding、边框 Border、外边距 Margin。CSS 决定这些盒子的大小、位置以及属性（例如颜色、背景、边框尺寸…）。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 Flex是 Flexible Box的缩写，意为\"弹性盒子\"，用来为盒状模型提供最大的灵活性。 弹性盒子布局（Flexible Box Layout）定义了一种针对用户界面设计而优化的 CSS盒子模型。在弹性布局模型中，弹性容器的子元素可以在任何方向上排布，也可以弹性伸缩其尺寸，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免父元素溢出。子元素的水平对齐和垂直对齐都能很方便的进行操控。 基本概念 弹性盒子布局是一种一维的布局模型，一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局 网格布局，可以同时处理行和列上的布局。 .container { display: flex | inline-flex; /**生成块或内联的弹性容器**/ } 弹性容器： display属性的值为 flex | inline-flex 的元素。 弹性项目：弹性容器的每个子元素都称为弹性项目。 轴：每个弹性盒子布局包含两个轴。弹性项目沿其依次排列的那根轴称为主轴。垂直于主轴的那根轴称为侧轴(cross axis)。 方向：弹性容器的主轴起点(main start)/主轴终点(main end)和侧轴起点(cross start)/侧轴终点(cross end)描述了弹性项目排布的起点与终点。它们具体取决于弹性容器的主轴与侧轴中，由 writing-mode 确立的方向（从左到右、从右到左，等等）。 行：根据 flex-wrap 属性指定弹性项目单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向（从左到中、从右到左）。 尺寸：根据弹性容器的主轴与侧轴，弹性项目的宽和高中，对应主轴的称为主轴尺寸(main size) ，对应侧轴的称为 侧轴尺寸(cross size)。 由于弹性盒子使用了不同的布局算法，某些属性用在弹性容器上没有意义： 多栏布局模块的 column-* 属性对弹性项目无效。 float与 clear对弹性项目无效。使用 float将使元素的 display属性计为block。 vertical-align 对弹性项目的对齐无效。 容器的属性 以下6个属性设置在容器上： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性 定义了主轴的方向(正方向或反方向)，即弹性项目的排列方向。 初始值：row 取值： row：主轴为水平方向，从左到右。 row-reverse：主轴为水平方向，从右到左。 column：主轴为垂直方向，从上往下。 column-reverse：主轴为垂直方向，从下往上。 请注意： row 和 row-reverse 受 flex 容器的direction属性的影响。 css属性 direction 用来设置文本、表列水平排列的方向，初始值ltr。 ltr 表示从左到右 (类似汉语、英语等大部分语言)， rtl 表示从右到左 (类似希伯来语或阿拉伯语)。 direction属性是 ltr，row表示从左到右定向的水平轴，而 row-reverse 表示从右到左; 如果 dir属性是 rtl，row表示从右到左定向的轴，而row-reverse 表示从左到右。 column和column-reverse受弹性容器的 writing-mode 属性的影响。 writing-mode 属性指定块流动方向，即块级容器堆叠的方向，以及行内内容在块级容器中的流动方向。 horizontal-tb：行内元素从左到右或从右到左（受direction属性的影响） ，块元素由上往下。 vertical-rl：行内元素由上往下或由下往上，块元素从左到右或从右到左。（受direction属性的影响） vertical-lr：行内元素由上往下或由下往上，块元素从左到右或从右到左。（受direction属性的影响） flex-wrap属性 指定弹性项目单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向。 初始值：nowrap 取值： nowrap：弹性项目被摆放到到一行，这可能导致溢出弹性容器。 cross-start 会根据 flex-direction 的值 相当于 start 或 before。 wrap：弹性项目被打断到多个行中，行由上往下排列。 wrap-reverse：和 wrap的行为一样，但是行由下往上排列。 flex-flow属性 flex-flow 属性是 flex-direction 和flex-wrap 的简写。 初始值：row nowrap。 flex-flow: column-reverse wrap; justify-content属性 定义了弹性项目在主轴上的对齐方式及其周围的空间的分配。 初始值：flex-start 取值： flex-start：主轴起点对齐。 flex-end：主轴终点对齐。 center： 居中。 space-between：两端对齐，弹性项目之间的间隔都相等。 space-around：每个弹性项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 space-evenly：弹性项目之间、弹性项目与边框之间的间隔都相等。 以上六个是常见取值，还有值start、left、right、baseline、first baseline、last baseline、stretch、safe、unsafe。？？ align-items属性 属性定义弹性项目在侧轴上如何对齐。 初始值：normal。取决于我们处在什么布局模式中 取值： flex-start：侧轴起点对齐 flex-end：侧轴终点对齐 center：中间对齐 baseline: 弹性项目的第一行文字的基线对齐 stretch：弹性项目将占满整个容器的高度（弹性项目未设置高度或设为auto）。 align-content属性 当弹性盒子分多行时，定义了行的对齐方式和周围分配空间。该属性对单行（即：未设置flex-wrap或 flex-wrap: nowrap）弹性盒子模型无效。 取值： flex-start：侧轴起点对齐 flex-end：侧轴终点对齐 center：中间对齐 space-between：与侧轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个侧轴（弹性项目未设置高度或设为auto）。 place-content属性 是 align-content 和 justify-content 的简写。第一个值为 align-content属性, 第二个值为justify-content 。 place-content: center start; 非常重要：如果没有设置第二个值，那么第二个的值与第一个相等，此前提是第一个值对两个属性都是有效的。如果设置的这个值对两个属性都无效，那么整个设置的值就是无效的。 项目的属性 以下6个属性设置在项目上： order flex-grow flex-shrink flex-basis flex align-self order属性 定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性 指定了弹性项目扩展规则，即弹性容器中剩余空间的应该分配多少给弹性项目。 剩余的空间是弹性容器的主轴尺寸减去所有弹性项目的尺寸和。 默认为0，即如果存在剩余空间，也不放大；大于0，则弹性容器剩余空间的分配就会发生；负值无效。 具体规则如下： 所有剩余空间总量是1 只有一个弹性项目设置了 flex-grow属性值 如果flex-grow值小于1，则扩展的空间就是总剩余空间 * flex-grow值 如果flex-grow值大于1，则独享所有剩余空间 有多个弹性项目设置了flex-grow属性值 如果flex-grow值总和小于1，则每个子项扩展的空间就是总剩余空间 * flex-grow值。 如果flex-grow值总和大于1，则所有剩余空间被利用，分配比例就是flex-grow属性值的比例。 如：所有弹性项目都有相同的flex-grow系数，那么所有的项目将获得相同的剩余空间。 如：三个弹性项目，有一个的flex-grow属性为2，其他项目都为1，即：1：2：1，则值为2的占据剩余空间的2/4，其他两个分别占1/4。 flex-shrink属性 指定了弹性项目的收缩规则。弹性项目仅在默认宽度之和大于容器，且未设置flex-wrap或者flex-wrap: nowrap的时候才会发生收缩。 不足空间是所有弹性项目的宽度和 - 弹性容器的宽度。 默认值为1，即如果空间不足，弹性项目将缩小；值为0表示不收缩；负值无效。 具体规则： 只有一个弹性项目设置了flex-shrink flex-shrink值小于1，则收缩的尺寸不完全，会有一部分内容溢出弹性容器。 flex-shrink值大于等于1，则收缩完全，正好填满弹性容器。 多个弹性项目设置了flex-shrink flex-shrink值的总和小于1，则收缩的尺寸不完全，每个弹性项目的收缩尺寸为不足空间 * flex-shrink值。 flex-shrink值的总和大于1，则收缩完全，每个弹性项目收缩尺寸的比例和flex-shrink值的比例一样。 如：所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。 如：一个弹性项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性 指定了弹性项目在主轴方向上的初始大小。浏览器根据这个属性，计算主轴是否有多余空间。 注意：弹性项目的最终尺寸，是由一系列盒模型属性和布局算法决定的，具体可查看下文【弹性项目尺寸的计算】章节。 初始值：auto 取值： auto，即弹性项目的本来大小。 最初 auto的含义是 \"参照width和height属性\"。 在此之后，auto的含义变成了自动尺寸, 而 main-size 变成了 \"参照width和height属性\"。实际执行于 bug 1032922. 然后呢，这个更改又在 bug 1093316 中被撤销了, 所以 auto变回了原来的含义；而一个新的关键字 content变成了自动尺寸。 (bug 1105111 包括了增加这个关键字)。 可以跟width或height属性的值一样（比如350px、2rem、30%），则弹性项目将占据固定空间。负值是不被允许的。 Note: 当一个元素同时被设置了 flex-basis (除值为 auto 外) 和 width (或者在 flex-direction: column 情况下设置了height) ， flex-basis 具有更高的优先级。 content 基于弹性项目的内容自动调整大小。除火狐，其他大多数浏览器不支持。 其他值。除火狐，其他大多数浏览器不支持。 /* 固有的尺寸关键词 */ flex-basis: fill; flex-basis: max-content; flex-basis: min-content; flex-basis: fit-content; flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，后两个属性可选。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 默认值：initial，0 1 auto。 flex 属性可以指定1个，2个或3个值： 单值语法：值必须为以下其中之一 一个无单位数值：它会被当作的值。 一个有效的宽度(width)值：它会被当作 的值。 关键字none，auto或initial。 auto ：1 1 auto none：0 0 auto initial：0 1 auto。即：flex-grow、flex-shrink、flex-basis的默认值。 双值语法：第一个值必须为一个无单位数值，当作 的值。第二个值必须为以下之一 一个无单位数：它会被当作 的值。 一个有效的宽度值：它会被当作 的值。 三值语法 第一个值必须为一个无单位数，并且它会被当作 的值。 第二个值必须为一个无单位数，并且它会被当作 的值。 第三个值必须为一个有效的宽度值， 并且它会被当作 的值。 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 初始值：auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 取值：可能取6个值，除了auto，其他都与align-items属性完全一致。 弹性项目尺寸的计算 在弹性盒子布局中，一个弹性项目的最终尺寸是基础尺寸、弹性增长或收缩、最大最小尺寸限制共同作用的结果： 基础尺寸：由CSS flex-basis、width等属性，内容尺寸以及box-sizing盒模型共同决定； 弹性增长指的是flex-grow属性，弹性收缩指的是flex-shrink属性； 最大最小尺寸限制指的是min-width/max-width等CSS属性，以及min-content最小内容尺寸。 #优先级 最大最小尺寸限制 > 弹性增长或收缩 > 基础尺寸 弹性项目尺寸的计算规则： 如果没有设置 flex-basis 属性，那么 flex-basis 的大小就是弹性项目的 width 属性的大小； 如果没有设置 flex-basis 、 width 属性，那么 flex-basis 的大小就是弹性项目内容的大小； 默认情况下，flex-basis的大小不会收缩至小于内容尺寸。若想改变这一状况，可以设置 min-width、width 属性。 主轴空间有剩余空间，遵循flex-grow规则；空间不足，遵循flex-shrink规则 以下在实际开发的项目中遇到的问题：使用了flex布局后，弹性项目中文本溢出自动省略号（...）的属性（即， text-overflow:ellipsis ）失效。 低眉含笑间 寒灯纸上梨花雨凉 谁的深情绚烂了三生石上的一见倾心 灯烛依旧 无人执手。低眉含笑间 寒灯纸上梨花雨凉 谁的深情绚烂了三生石上的一见倾心 灯烛依旧 无人执手 .box_01 { display: flex; padding: 10px; border: 1px solid #0aa; } .box_01 .item_01 { margin-right: 15px; padding: 10px; color: #fff; text-align: center; background-color: #0aa; white-space: nowrap; } .box_01 .item_01 .text { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .box_01 .item_01_text01 { min-width: 0; } /* .box_01 .item_01_text02 { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } */ 查看DEMO 从本质上来说，ellipsis失效的是因为.text元素中的文本没有溢出。 .text_parent元素是一个弹性项目，设置了flex: 1（即：flex-grow:1; flex-shrink:1; flex-basis: auto;，flex-basis: auto;），且没有设置width属性，它的宽度由内容宽度决定，即.text元素的宽度。 .text元素默认情况下width: 100%，宽度与父元素.text_parent一样。父元素宽度不固定的情况下，.text元素的宽度取内容宽度，即文本的宽度。 最终结果：.text_parent的宽度 = .text的宽度 = 文本宽度，所有文本没有溢出 要使ellipsis启效，首先我们可以想到的方法是给.text元素设置一个小于文本宽度的width值，但这种方法显然不适用于响应式开发。 另一种思路是：给.text_parent指定一个小于文本宽度的width值。 方法一：.text_parent设置overflow属性 .text_parent { overflow: hidden; } 弹性项目在弹性容器中，有一个可用宽度。设置overflow后，表示弹性项目宽度不超出可用宽度。 方法二：.text_parent设置width属性 .text_parent { width: 0; } 弹性项目的width属性的作用是告诉浏览器：我有自己的宽度，不需要取内容的宽度。注意：弹性项目的最终尺寸不一定是css中的width值，它会根据一系列的盒模型属性来计算。 方法三：.text_parent设置min-width属性 /** 根据CSS规范草案，一般情况下min-width属性默认值是0，但弹性项目的min-width属性默认值是auto，这样能为弹性盒子布局指明更合理的默认表现。 **/ .text_parent { min-width: 0; } 弹性项目设置了min-width属性，浏览器将采用如下算法（shrink-to-fit算法 ??）： 弹性项目宽度 = min ( max (最小宽度, 可用宽度) , 首选宽度) 最小宽度：min-width的值 可用宽度：弹性项目在弹性容器中的允许宽度 首选宽度：内容不发生换行的时的宽度。（示例中的文本宽度） 以上是个人对弹性项目width计算的理解，如有不对，敬请指正。 参考文章： 张鑫旭 - Oh My God，CSS flex-basis原来有这么多细节 flexbox 布局中 flex 项的宽度计算原理 浏览器前缀 flex布局需要一些浏览器前缀来最大力度地兼容大多数的浏览器。Flex布局的前缀不只是在属性前面添加浏览器前缀，不同浏览器下的属性名和属性值都不同，这是因为Flexbox布局的标准一直在变，一共有old, tweener, new三个版本。 可能处理前缀的最好方法是使用新的语法书写CSS并通过Autoprefixer运行CSS，能够很好地处理这个问题。 另外，这里有一个Sass中 @mixin 来处理一些前缀，也可以给你一些处理前缀的启发： @mixin flexbox() { display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; } @mixin flex($values) { -webkit-box-flex: $values; -moz-box-flex: $values; -webkit-flex: $values; -ms-flex: $values; flex: $values; } @mixin order($val) { -webkit-box-ordinal-group: $val; -moz-box-ordinal-group: $val; -ms-flex-order: $val; -webkit-order: $val; order: $val; } .wrapper { @include flexbox(); } .item { @include flex(1 200px); @include order(2); } 相关问题 iPhone 设备兼容 iPhone 11pro、iPhone 不支持 justify-content: right，请用 justify-content: flex-end 代替。 参考链接 MDN CSS 布局 mdn CSS 弹性盒子布局 Flex 布局教程：语法篇 张鑫旭 写给自己看的display: flex布局教程 © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-04-11 21:25:25 "},"css探索系列/05-CSS探索系列-gradient.html":{"url":"css探索系列/05-CSS探索系列-gradient.html","title":"CSS探索系列 Gradient","keywords":"","body":"CSS3探索系列之gradient 是一种特别的数据类型，用于表现两种或多种颜色的过渡转变。只能被用于可以使用的地方。因此，它并不适用于background-color以及类似的使用数据类型的属性中。 通常，在CSS中渐变就是background的background-image，也就是说，适用于背景图像的CSS属性都适合于渐变。 渐变容器（渐变框） 图像和传统的背景图像不一样，它是无限的渐变图像，可见区域是由渐变容器大小来决定的。 一个DOM元素的background-image使用linear-gradient，其显示区域就是元素的border-box区域（即：包括内容、内边距和边框，但不包括外边距）。其实也是background-color或者说通过url引入背景图像的显示区域。 然而，如果你通过CSS的background-size设置一个尺寸，比如说200px * 200px，这个时候渐变容器（渐变尺寸）就是200px * 200px。在没有使用background-position设置为其他值时，它默认是显示在DOM元素的左上角（也就是background-position: left top）。 线形渐变 颜色值沿着一条隐式的直线逐渐过渡。由linear-gradient()创建一个表示两种或多种颜色线性渐变的图片。 语法 linear-gradient([ | to ,]? [] ... ) 通过指向边或者角，指定渐变的方向，可不写，默认值为 to bottom。 取值：to left/ to right/ to top/ to bottom/ to top left/ to bottom right。关键词的先后顺序无影响，即to top left和to left top是一样的。 用角度值指定渐变的方向（或角度），可不写，默认值为 180deg（等价to bottom）。 0deg表示指向北方的方向，角度顺时针增加。 取值：90deg、135deg、0.25turn、100grid、1rad。 在带前缀的变体和不带前缀的提案之间仍然存在一项语义的分歧：标准将0deg指向北方，带前缀的保持原始的角度定义，即0deg指向东方。 CSS角度单位：deg、grad、rad、turn 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad deg：度（Degress）。一个圆共360度 grad：梯度（Gradians）。一个圆共400梯度 rad：弧度（Radians）。一个圆共2π弧度 turn：转、圈（Turns）。一个圆共1圈 颜色终止点，由组成，位置可不写。如：#e66465、#e66465 50%、#e66465 100px等。可写两个或多个颜色终止点。 颜色终止列表中颜色的终止点应该是依次递增的。如果一个颜色中间点的位置比前一个小，那么将会被设定成与前一个相同的值。 如果第一个颜色中间点没有位置属性,那么它默认为0%。如果最后一个颜色中间点没有位置属性, 则默认为100%。如果一个既不是起始也不是终止的颜色中间点，没有被明确声明位置，那么这个颜色就会从前后两个颜色的中间位置开始。 定义了在相邻之间过渡的中点，默认值50%。注：相邻两个之间只能有一个过渡点。 background-image: linear-gradient(#e66465, #9198e5); /*下图左，与【#e66465, 50%, #9198e5】等价*/ background-image: linear-gradient(#e66465, 10%, #9198e5); /*下图中*/ background-image: linear-gradient(#fb3 40%, #e66465 30%, #9198e5); /*下图右*/ 示例 查看DEMO .box_01 .item_01 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; border: 1px solid #0aa; background-image: linear-gradient(#e66465, #9198e5); } .box_01 .item_01:nth-child(2) { background-image: linear-gradient(0.25turn, #3f87a6, #ebf8e1, #f69d3c); } .box_01 .item_01:nth-child(3) { background-image: linear-gradient(217deg, rgba(255, 0, 0, .8), rgba(255, 0, 0, 0) 70.71%), linear-gradient(127deg, rgba(0, 255, 0, .8), rgba(0, 255, 0, 0) 70.71%), linear-gradient(336deg, rgba(0, 0, 255, .8), rgba(0, 0, 255, 0) 70.71%); } .box_01 .item_01:nth-child(4) { background-image: linear-gradient(#3f87a6 33.33%, #fb3 0, #fb3 66.66%, #e45b5a 0); background-size: 100% 42px; } 径向渐变 颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值。由radial-gradient()函数产生。 语法 radial-gradient([ [ | ] at ]? [] ... ) 表示用于设置相对于框的位置的2D空间中的坐标，即x轴、y轴坐标，默认值center。 取值：关键字（left, right, top, bottom or center），或者百分比，或是一个绝对的长度值 如：left、left top、left center、center top、50%、100px、5rem等。x轴、y轴都是关键字时，顺序无影响。 渐变的形状，默认值ellipse（椭圆）。 取值：ellipse（椭圆）、circle（正圆） 渐变圆的半径长度。 当渐变类型为 circle 时，只能指定一个size值，值必需为具体的长度值，即直径；当渐变类型为 ellopse时，可以指定两个size值，即水平半径，垂直半径，值可以为具体的长度值或者百分比。 关键字用于描述边缘轮廓的具体位置。以下为关键字常量： | 常量 | 描述 | | :---------------- | :----------------------------------------------------------- | | closest-side | 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 | | closest-corner | 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 | | farthest-side | 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 | | farthest-corner | 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 | 颜色终止点，由组成，位置可不写。如：#e66465、#e66465 50%、#e66465 100px等。可写两个或多个颜色终止点。 颜色终止列表中颜色的终止点应该是依次递增的。如果一个颜色中间点的位置比前一个小，那么将会被设定成与前一个相同的值。 如果第一个颜色中间点没有位置属性,那么它默认为0%。如果最后一个颜色中间点没有位置属性, 则默认为100%。如果一个既不是起始也不是终止的颜色中间点，没有被明确声明位置，那么这个颜色就会从前后两个颜色的中间位置开始。 定义了在相邻之间过渡的中点，默认值50%。 示例 查看DEMO .box_02 .item_02 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; border: 1px solid #0aa; background-image: radial-gradient(#ff0, #9198e5); } .box_02 .item_02:nth-child(2) { background-image: radial-gradient(at top, #ff0, #9198e5); } .box_02 .item_02:nth-child(3) { background-image: radial-gradient(circle at top, #ff0, #9198e5); } .box_02 .item_02:nth-child(4) { background-image: radial-gradient(circle closest-corner at top, #ff0, #9198e5); } .box_02 .item_02:nth-child(5) { background-image: radial-gradient(ellipse 50px 50px at top, #ff0, #9198e5); } .box_02 .item_02:nth-child(6) { background-image: radial-gradient(#3f87a6 33.33%, #fb3 0, #fb3 66.66%, #e45b5a 0); background-size: 42px 42px; } 圆锥渐变 圆锥渐变创建一个图像，由一个梯度组成，颜色起始点是图形中心，然后以顺时针方向绕中心实现渐变效果（而不是从中心辐射）。由conic-gradient()函数产生。 语法 conic-gradient([ from ]? [ at ]?, [] ... ) ) 颜色围绕中心点旋转的角度值，可不写，默认值为0deg（指向北方）。 表示用于设置相对于框的位置的2D空间中的坐标，即x轴、y轴坐标，默认值center。 取值：关键字（left, right, top, bottom or center），或者百分比，或是一个绝对的长度值 如：left、left top、left center、center top、50%、100px、5rem等。x轴、y轴都是关键字时，顺序无影响。 颜色终止点，由组成，位置可不写。如：#e66465、#e66465 90deg、#e66465 0.25turn、#e66465 0.25turn 0.75turn等。可写两个或多个颜色终止点。 定义了在相邻之间过渡的中点，默认值50%。 示例 查看DEMO .box_03 .item_03 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; border: 1px solid #0aa; background-image: conic-gradient(red, orange, yellow, green, teal, blue, purple); } .box_03 .item_03:nth-child(2) { background-image: conic-gradient(from 40deg, red 0deg, orange 90deg, yellow 180deg, green 270deg, blue 360deg) } .box_03 .item_03:nth-child(3) { background-image: conic-gradient(from 40deg at 25% 25%, red 0deg, orange 90deg, yellow 180deg, green 270deg, blue 360deg) } .box_03 .item_03:nth-child(4) { background-image: conic-gradient(red 36deg, orange 36deg 170deg, yellow 170deg); } .box_03 .item_03:nth-child(5) { background-image: conic-gradient(red 12.5%, orange 0 37.5%, red 0 62.5%, orange 0 87.5%, red 0); background-size: 50px 50px; } .box_03 .item_03:nth-child(6) { background-image: conic-gradient(#3f87a6 33.33%, #fb3 0, #fb3 66.66%, #e45b5a 0); background-size: 42px 42px; } .box_03 .item_03:nth-child(7) { position: relative; background: conic-gradient(rgba(255, 152, 0, 1) 0, rgba(255, 152, 0, 0) 100%); border: 0; text-align: center; vertical-align: top; } .box_03 .item_03:nth-child(7):after { position: absolute; top: 10%; left: 10%; display: block; width: 80%; height: 80%; content: \" \"; background: #fff; } 重复渐变 重复多次渐变图案直到足够填满指定元素。 重复线性渐变 repeating-linear-gradient()创建一个由重复线性渐变组成的， 这是一个类似linear-gradient 的函数，并且采用相同的参数，但是它会在所有方向上重复渐变以覆盖其整个容器。 重复径向渐变 repeating-radial-gradient() 创建一个从原点辐射的重复渐变组成的 。它类似于radial-gradient并且采用相同的参数，但是它会在所有方向上重复颜色，以覆盖其整个容器。 重复圆锥渐变 repaeting-conic-gradient 创建一个颜色过渡旋转围绕中心点的重复渐变组成的 。重复圆锥渐变语法与conic-gradient()相似。 示例 查看DEMO .box_04 .item_04 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; border: 1px solid #0aa; background-image: repeating-linear-gradient(-45deg, transparent, transparent 25px, orange 25px, orange 50px); } .box_04 .item_04:nth-child(2) { background-image: repeating-linear-gradient(transparent, transparent 23%, orange 23%, orange 27%), repeating-linear-gradient(90deg, transparent, transparent 23%, orange 23%, orange 27%); } .box_04 .item_04:nth-child(3) { background-image: repeating-radial-gradient(red, yellow 10%, green 15%); } .box_04 .item_04:nth-child(4) { background-image: repeating-radial-gradient(circle, red, red 10px, yellow 10px, yellow 20px); background-size: 25px; } .box_04 .item_04:nth-child(5) { background-image: repeating-conic-gradient(red 0 9deg, yellow 9deg 18deg); } .box_04 .item_04:nth-child(6) { background-image: repeating-conic-gradient(red 0 9deg, yellow 9deg 18deg); background-size: 50px 50px; } 其他渐变 查看DEMO 愿你走出 半生归来 仍是少年 .box_05 .item_05 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; vertical-align: middle; border: 1px solid #0aa; } .box_05 .item_05:nth-child(1) { border: 10px solid transparent; border-image: linear-gradient(to top, red, orange); border-image-slice: 10; } .box_05 .item_05:nth-child(2)>div { height: 60px; margin-top: 60px; font-size: 42px; background-image: linear-gradient(to top, red, orange); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; } .box_05 .item_05:nth-child(3)>div { height: 60px; margin-top: 60px; font-size: 42px; position: relative; color: red; text-align: center; } .box_05 .item_05:nth-child(3)>div:before { position: absolute; color: orange; -webkit-mask: linear-gradient(to top, red, transparent); content: attr(text); z-index: 1; } .box_05 .item_05:nth-child(4)>div { height: 60px; margin-top: 60px; text-align: center; } .box_05 .item_05:nth-child(4)>div .gradient-text-three { fill: url(#SVGID_1_); font-size: 48px; } 常见问题 iPhone 设备兼容 iPhone 11pro 不支持如下写法： background: linear-gradient(to bottom, rgba(255, 0, 0, 0.1), white 10%, white); 背景渐变色应避免用 rgba 设置透明度。 参考链接 MDN 使用 CSS 渐变 MDN linear-gradient 神奇的 conic-gradient 圆锥渐变 复杂的css背景图 © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-04-11 21:25:10 "},"css探索系列/06-为什么使用PostCSS处理CSS？.html":{"url":"css探索系列/06-为什么使用PostCSS处理CSS？.html","title":"为什么使用PostCSS处理CSS？","keywords":"","body":"为什么使用PostCSS 处理CSS ？ postcss是什么？ PostCSS是一个用 JavaScript 工具和插件转换 CSS 代码的工具。 PostCSS并不是一门语言，而是一个类似于webpack的工具，它支持很多插件，来达到便捷的编译效果，组成一个CSS编译/lint/autoprefixer的生态圈。它的作者是Euil Martians，一家致力于技术研究与网站外包开发的公司。其后端技术栈偏重于Ruby，而前端从 React 到 Node 都有涉猎。 PostCSS 本身是一个功能比较单一的工具。它提供了一种方式用 JavaScript 代码来处理 CSS。它负责把 CSS 代码解析成抽象语法树结构（Abstract Syntax Tree，AST），再交由插件来进行处理。 插件基于 CSS 代码的 AST 所能进行的操作是多种多样的，比如可以支持变量和混入（mixin），增加浏览器相关的声明前缀，或是把使用将来的 CSS 规范的样式规则转译（transpile）成当前的 CSS 规范支持的格式。从这个角度来说，PostCSS 的强大之处在于其不断发展的插件体系。 目前 PostCSS 已经有 200 多个功能各异的插件。开发人员也可以根据项目的需要，开发出自己的 PostCSS 插件。 实际上，PostCSS 的主要功能只有两个： 第一个就是前面提到的把 CSS 解析成 JavaScript 可以操作的 AST， 第二个就是调用插件来处理 AST 并得到结果。 因此，不能简单的把 PostCSS 归类成 CSS 预处理或后处理工具。PostCSS 所能执行的任务非常多，同时涵盖了传统意义上的预处理和后处理。 为什么选择postcss？ 随着前端工程化的不断完善，CSS 预处理器已经成为项目中不可缺少的部分，很多人在项目技术选型阶段就会先选择一个 CSS 预处理器，绝大部分前端工程的脚手架也内置了一系列的 CSS 预处理的模版。 CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成 CSS 的程序。 市面上有很多 CSS 预处理器可供选择，且绝大多数 CSS 预处理器会增加一些原生 CSS 不具备或不完善的高级特性，这些特性让 CSS 的结构更加具有可读性且易于维护。当前社区代表的 CSS 预处理器 主要有以下几种： Sass：2007 年诞生，最早也是最成熟的 CSS 预处理器，拥有 Ruby 社区的支持和 Compass 这一最强大的 CSS 框架，目前受 LESS 影响，已经进化到了全面兼容 CSS 的 SCSS。 Less：2009年出现，受 SASS 的影响较大，但又使用 CSS 的语法，让大部分开发者和设计师更容易上手，在 Ruby 社区之外支持者远超过 SASS，其缺点是比起 SASS 来，可编程功能不够，不过优点是简单和兼容 CSS，反过来也影响了 SASS 演变到了 SCSS 的时代，著名的 Twitter Bootstrap 就是采用 LESS 做底层语言的。 Stylus：Stylus 是一个CSS的预处理框架，2010 年产生，来自 Node.js 社区，主要用来给 Node 项目进行 CSS 预处理支持，所以 Stylus 是一种新型语言，可以创建健壮的、动态的、富有表现力的 CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似， 相比其他的 CSS 预处理器，postcss 优势主要体现在以下几个方面： 根据你需要的特性进行模块化，而不是像 less 或者 scss 一样的全家桶。 多样化的功能插件，创建了一个生态的插件系统 拥有极高的处理性能（3倍以上的处理速度） 可以自己编写postcss插件 既可以写正常的CSS，也可以结合 LESS 或者 SASS 一起编写 可以与许多流行工具无缝部署，例如webpack、gulp、codepen 等 对 Source Map 支持更好 一句话来概括PostCSS：CSS编译器能够做到的事情，它也可以做到，而且能够做得更好 postcss的使用 PostCSS的一大特点是，具体的编译插件甚至是CSS书写风格，可以根据自己的需要进行安装，选择自己需要的特性：嵌套，函数，变量。自动补全，CSS新特性等等，而不是像less或者scss一样的大型全家桶。因此，不需要再专门去学习less或者scss的语法，只要选择自己喜欢的特性，可以只写 CSS 文件，但依旧可以写嵌套或者函数，然后选择合适的插件编译它就行了。 到目前，PostCSS有200个多个插件。你可以在插件列表或搜索目录找到它们。你也可以自己开发PostCSS插件。 安装：npm i -D postcss-loader postcss的配置： webpack.config.js，优先级最高 // webpack.config.js { test: /\\.css$/, use: [ 'style-loader', 'css-loader', { loader: 'postcss-loader', options: { ident: 'postcss', plugins: (loader) => [ require('postcss-import')({ root: loader.resourcePath }), require('postcss-preset-env')(), require('cssnano')() ] } } ] } postcss.config.js或者.postcssrc.js // postcss.config.js module.exports = ({ file, options, env }) => ({ parser: file.extname === '.sss' ? 'sugarss' : false, plugins: { 'autoprefixer': {}, 'postcss-import': { root: file.dirname }, 'postcss-preset-env': options['postcss-preset-env'] ? options['postcss-preset-env'] : false, 'cssnano': env === 'production' ? options.cssnano : false } }) .postcssrc { \"plugins\": { \"postcss-plugin\": {} } } package.json 中的 postcss，优先级最低 { \"postcss\": { \"plugins\": { \"postcss-plugin\": {} } } } 基于webpack，创建测试项目 鉴于现在webpack也越来越火，所以之后的配置主要是借助于postcss-loader，将PostCSS的生态圈依托在webpack之下。 安装： npm i webpack webpack-cli -g npm i webpack npm i css-loader postcss-loader mini-css-extract-plugin -D 项目结构如下： - build - webpack.postcss.config.js - src - index.css - index.js - package.json - postcss.config.js // webpack.postcss.config.js const webpack = require('webpack') const Path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const webpackConfig = { mode: 'production', entry: './src/index.js', output: { path: Path.resolve(__dirname, '../dist'), filename: 'index.js' }, module: { rules: [ { // 使用 PostCSS 处理 CSS 文件 test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', ] } ] }, plugins: [ new MiniCssExtractPlugin({ filename: 'index.css', chunkFilename: 'chunkIndex.css', }) ] } webpack(webpackConfig, err => {}) MiniCssExtractPlugin 不能与 style-loader 一起使用 webpack(webpackConfig, err => {})，要传回调函，可以为空 // index.js import './index.css' /*index.css*/ .hello { box-sizing: border-box; } // package.json { ... \"scripts\": { \"postcss\": \"node build/webpack.postcss.config.js\" }, ... } // postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { } }) 常用插件 Autoprefixer 安装：npm i autoprefixer -D 利用从 Can I Use 网站获取的数据为 CSS 规则添加特定厂商的前缀。Autoprefixer 自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮你自动为 CSS 规则添加前缀。 我们可以用以下方法，对插件配置参数，(Browserslist，指定目标浏览器范围 )： postcss.config.js： //postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { \"autoprefixer\": { \"overrideBrowserslist\": [ \"> 0.1%\", \"last 2 versions\", \"Android >= 3.2\", \"Firefox >= 20\", \"iOS >= 7\", \"chrome > 20\" ] } } }) package.json 增加如下配置： { \"browserslist\": [ \"> 1%\", \"last 2 versions\", \"Android >= 3.2\", \"Firefox >= 20\", \"iOS >= 7\", \"chrome > 20\" ] } 根目录下加.browerslistrc配置文件： # 注释是这样写的，以#号开头 \"> 1%\", \"last 2 versions\", \"Android >= 3.2\", \"Firefox >= 20\", \"iOS >= 7\", \"chrome > 20\" 具体配置参数，可以参考前端工程基础知识点--Browserslist (基于官方文档翻译） /* 输入 src/index.css */ .autoprefixer { box-sizing: border-box; } /* 输出 dist/index.css */ .autoprefixer { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } postcss-nesting 、postcss-nested 支持css的嵌套写法。 安装：npm i postcss-nesting -D 安装：npm i postcss-nested -D 他们两个的区别是： postcss-nesting: W3C nested selectors，遵循W3C的写法，每个嵌套的样式前面都需要一个&（注意符号后面有个空格） postcss-nested: Sass-like nested selectors，不需要加&符号 建议是使用 postcss-nesting ，遵循W3C规则。 //postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { \"postcss-nesting\": {} } }) /*postcss-nesting，嵌套样式前需要加&符号*/ /*postcss-nested，正常样式前不需加&符号，伪类前还是要加*/ /*输入*/ .postcss_nesting { & sub_class { width: 100%; } & a { color: red; } } /*输出*/ .postcss_nesting sub_class { width: 100%; } .postcss_nesting a { color: red; } postcss-import 允许css通过@ import内联其他css模块。 安装：npm i postcss-import -D // postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { \"postcss-nesting\": {} } }) 新增一个import.css文件，在index.css中导入： /*import.css*/ .import { color: red; } .import_sub { width: 100%; } /*index.css*/ @import './import.css'; 最终输出到dist/index.css： /*import.css*/ .import { color: red; } .import_sub { width: 100%; } postcss-preset-env 安装：npm i postcss-preset-env -D 帮你将现代 CSS 语法转换成大多数浏览器都能理解的东西，根据你的目标浏览器或运行时环境来确定你需要的 polyfills，基于 cssdb 实现。 postcss-preset-env 已经内置了 autoprefixer、postcss-nesting/postcss-nested、postcss-import 等相关功能。 //postcss.config.js module.exports = { plugins: { \"postcss-preset-env\": { features: { \"custom-properties\": { preserve: false, variables: {} }, \"nesting-rules\": true } } } } 具体参数可查看postcss-preset-env 或者 feature cssnano 安装：npm i cssnano -D cssnano会采用格式良好的CSS并通过许多有针对性的优化来运行它，以确保最终结果对于生产环境而言尽可能小。 //postcss.config.js module.exports = { plugins: { \"cssnano\": { preset: [\"default\", { // 禁止插件对自定义动画名称的重命名 reduceIdents: false, // 禁用postcss重写z-index值 zindex: true }] } } } /*输入*/ .autoprefixer { box-sizing: border-box; } .postcss_nesting { & sub_class { width: 100%; } & a { color: red; } } .cssnano { font-size: 16px; z-index: 1000; } /*输出*/ .autoprefixer{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.postcss_nesting sub_class{width:100%}.postcss_nesting a{color:red}.cssnano{font-size:16px;z-index:1000} postcss-apply 允许您将一组属性存储在指定的定制属性中，然后在其他样式规则中引用它们。 您正在使用@apply 规则和自定义属性集。该功能将不会包含在 postcss-cssnext 的下一个主要版本中。这很可能不会得到来自浏览器供应商的更多支持，因为该规范尚未被认可，并且正在讨论替代解决方案。 安装：npm i postcss-apply -D //postcss.config.js module.exports = { plugins: { \"postcss-import\": {}, \"postcss-apply\": {} } } 新增一个apply.css，引入到index.css： /*apply.css*/ :root { --no-wrap: { width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } } /*index.css*/ @import './apply.css'; .apply { color: green; @apply --no-wrap; } 最终输出到dist/index.css： /*dist/index.css*/ .apply { color: green; width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } postcss-apply 要跟 postcss-import 一起使用 postcss-mixins 样式混入文件中。 安装：npm i postcss-mixins -D //postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { \"postcss-mixins\": {}, } }) /*输入*/ @define-mixin icon $name, $color: blue { .icon.is-$(name) { color: $color; } .icon.is-$(name):hover { color: white; background: $color; } } @mixin icon twitter { background: url(twt.png); } /*输出*/ .icon.is-twitter { color: blue; } .icon.is-twitter:hover { color: white; background: blue; } postcss-px2rem-exclude 安装：npm i postcss-px2rem -D 安装：npm i postcss-px2rem-exclude -D //postcss.config.js module.exports = { \"plugins\": { \"postcss-px2rem-exclude\": { remUnit: 75, exclude: /node_modules|folder_name/i } } } /*输入*/ .px2rem { width: 100px; font-size: 30px; } /*输出*/ .px2rem { width: 1.333333rem; font-size: 0.4rem; } 参考文档 postCss 初识 （文章较长，需要耐心） 2019年，你是否可以抛弃 CSS 预处理器？ © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:36:58 "},"css探索系列/_关于css.html":{"url":"css探索系列/_关于css.html","title":" 关于Css","keywords":"","body":"关于CSS 层叠样式表 (Cascading Style Sheets，缩写为 CSS），是一种 样式表语言，用来描述 HTML 或 XML（包括如 SVG、MathML、XHTML 之类的 XML 分支语言）文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。 CSS 是开放网络的核心语言之一，由 W3C 规范 实现跨浏览器的标准化。CSS节省了大量的工作。 样式可以通过定义保存在外部.css文件中，同时控制多个网页的布局，这意味着开发者不必经历在所有网页上编辑布局的麻烦。CSS 被分为不同等级：CSS1 现已废弃， CSS2.1 是推荐标准， CSS3 分成多个小模块且正在标准化中。 CSS 的诞生 20 世纪 90 年代蒂姆·伯纳斯·李（Tim Berners-Lee）发明万维网，创造 HTML 超文本标记语言。此后网页样式便以各种形式存在，不同的浏览器有自己的样式语言来控制页面的效果，因为最原始的 Web 版本中根本没有提供一种网页装饰的方法。 在HTML迅猛发展的 90 年代，不同的浏览器根据自身的 HTML 语法结构来支持实现不同的样式语言。在最初的 HTML 版本中，由于只含有很少的显示属性，所以用户可以自己决定显示页面的方式。 但随着 HTML 的发展，HTML 增加了很多功能，代码也越来越臃肿，HTML 就变得越来越乱。网页也失去了语义化，维护代码很艰难，因为代码很混乱： some text! 于是装饰网页样式的 CSS（层叠样式表，Cascading Style Sheets）诞生了。 CSS 的历史 CSS1 于1994年，Håkon Wium Lie (哈肯·维姆·莱) 和 Bert Bos (伯特·波斯) 合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。 1996年12月 发表的 CSS1 的要求有第一版主要规定了选择器、样式属性、伪类 、对象几个大的部分。 CSS2 CSS2 在 1998 年 5月 由 W3C 发布，CSS2 规范是基于 CSS1 设计的，扩充和改进了很多更加强大的属性。包括选择器、位置模型、布局、表格样式、媒体类型、伪类、光标样式。 CSS 2.1 修复了 CSS 2中的错误，删除了支持不良或不能完全互操作的特性，并为规范增加了已经实现的浏览器扩展。 为了遵守 W3C 标准化技术规范的过程，CSS 2.1 在 Working Draft (WD) 状态和 Candidate Recommendation (CP) 状态之间来回了很多年。 CSS3 CSS3 是层叠样式表（Cascading Style Sheets）语言的最新版本，旨在扩展CSS2.1。 为了加快那些已经确认没有问题的特性的标准化速度，W3C 的 CSS Working Group 作出了一项被称为 Beijing doctrine 的决定，将 CSS 划分为许多小组件，称之为模块。这些模块彼此独立，按照各自的进度来进行标准化。其中一些已经是 W3C Recommendation 状态，也有一些仍是 Early Working Drafts（早期工作草案）。当新的需求被肯定后， 新的模块也会同样地添加进来。 从形式上来说，CSS3 标准自身已经不存在了。每个模块都被独立的标准化，现在标准 CSS 包括了修订后的 CSS2.1 以及完整模块对它的扩充，模块的 level（级别）数并不一致。可以在每个时间点上为 CSS 标准定义一个 snapshots（快照），列出 CSS 2.1 和成熟的模块。 有一张图可以更加直观的表示当前 CSS3 Modules 的分类和状态： 指南与教程 MDN CSS（层叠样式表） MDN CSS 参考 CSS参考手册（css.doyoe.com） CSS 教程（www.runoob.com） © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-03-21 20:51:46 "},"frontend/01-基础-02-浏览器工作原理.html":{"url":"frontend/01-基础-02-浏览器工作原理.html","title":"基础 02 浏览器工作原理","keywords":"","body":"浏览器内核、JS引擎及其工作原理 浏览器（Web Browser，网页浏览器）是一种用来检索、展示以及传递 Web 信息资源的应用程序。Web 信息资源由统一资源标识符（Uniform Resource Identifier，URI）所标记，它是一张网页、一张图片、一段视频或者任何在Web上所呈现的内容。使用者可以借助超级链接( Hyperlinks)，通过浏览器浏览互相关联的信息。 浏览器发展历程 世界上第一个浏览器 Tim Berners-Lee（蒂姆·伯纳斯·李） 于1990年发明了第一个网页浏览器 WorldWideWeb，后来为了避免和 World Wide Web 命名冲突而改叫 Nexus。这时浏览器的功能很简单，只支持文本、简单的样式表和有限格式的图片和声音。 Erwise 是第一个普遍可用的使用 GUI 的网页浏览器，由罗伯特·卡里奥发起开发。 第一次浏览器大战 1993年，马克·安德森 发布 Mosaic——“世界上最流行的浏览器”，进一步推动了浏览器的创新，这使得万维网更易于使用。安德森的浏览器引发了1990年代的互联网热潮。安德森是 NCSA 中 Mosaic 团队的领导者，他不久后辞职并成立了自己的公司—— Netscape，发布了受 Mosaic 影响的 Netscape Navigator。Netscape Navigator 很快便成为世界上最流行的浏览器，市占率一度达到90%。 作为应对，错失了互联网浪潮的微软匆促购入了 Spyglass 公司的技术，发布 Internet Explorer。这引发了第一轮浏览器大战。因捆绑于 Windows，Internet Explorer 于网页浏览器市场获取了主导地位，其市占率于2002年达到最高时超过95%。 第二次浏览器大战 由于微软推出的 IE 的影响， 网景公司的 Netscape 每况日下。但网景公司并没有坐以待毙，在 1998 年 成立了 Mozilla 基金会，并准备开发新的浏览器 。 2003 年，苹果公司搭配自家的 Mac OS X Panther 推出了 Safari浏览器，受限于 Mac 的用户量，Safari 并未产生多大的影响；2005 年，苹果开源了 Safari 的内核（渲染引擎）—— 大名鼎鼎的 Webkit，意义之重大，不言而喻。 2004 年，网景公司发布了全新的浏览器 Firefox，并搭配了 Gecko 内核。它功能丰富，支持用户拓展，一推出就深受大家喜爱，市场份额也稳步上升。 2008 年，Google 公司以苹果的开源项目 Webkit 作为内核，创建了一个全新的项目 Chromium 浏览器。它被谷歌拿来做 Web 技术试验场，尝试一些大胆创新的技术。同年，推出了面向用户的浏览器 —— Chrome，它会选择 Chromium 的稳定版本为基础，集成一些私有的编码解码器。或许你会疑惑，既然推出了 Chromium，为什么还要推出 Chrome？其实很简单，Chromium 是面向开发者玩的，Chrome 是选取 Chromium 的稳定版面向普通大众的，二者并不冲突。 自此，微软 IE 依靠 Windows 系统依然占据重要地位，Mozilla 火狐 和 Google Chrome 二者也拥有大量粉丝，逐步谗食 IE 的市场份额，形成三足鼎立之势。 2010 ~ 现在 2010 年，苹果宣布了 Webkit2 ，改为多进程的结构模型。 2013 年，Google 和 苹果 出现了对内核发展的分歧。于是 4 月份，Google 宣布了全新的内核项目 —— Blink。该内核早期是完全复制了 Webkit ，之后删除了与 Chromium 无关的代码，并开始大刀阔斧地对内核进行改革。 2015 年，随着 Windows 10 的发布，微软公司宣布了全新的浏览器 —— Microsoft Edge，用来取代 IE 浏览器，一代王者逐步退出舞台。 2017 年，Mozilla 宣布了为 Firefox 全新的打造的 Quantum 版本，号称新时代的最快浏览器。 目前为止，Google Chrome 以绝对的优势远远领先于其他浏览器，并且对 Web 技术 依然充满热情，以优秀的特性和性能吸引了绝大部分开发者。 浏览器的主要组件 简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。 shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。 内核才是浏览器的核心：内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。 用户界面：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎：在用户界面和呈现引擎之间传送指令。 呈现引擎：也称浏览器内核，负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络：用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 Javascript解析器：用于解析和执行 JavaScript 代码。 数据存储：这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 浏览器最重要的部分是浏览器的内核。浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。 浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。 渲染引擎 渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有 10 多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 Trident 该内核程序在 1997 年的 IE4 中首次被采用，是微软在 Mosaic 代码的基础之上修改而来的，并沿用到 IE11，也被普遍称作 IE内核。 由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核（也被称为 IE 内核）长期一家独大，微软也很长时间都并没有更新 Trident 内核。这导致了两个后果： 一是 Trident 内核曾经几乎与 W3C 标准脱节（2005年）。 二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决。 再加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox 和 Opera 就是这个时候兴起的。 注：IE 从版本 11 开始，初步支持 WebGL 技术。IE8 的 JavaScript 引擎是 Jscript，IE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 Gecko Netscape6 开始采用的内核，后来的 Mozilla FireFox 浏览器也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。 Gecko 内核的浏览器以 Firefox 用户最多，所以有时也会被称为 Firefox 内核。此外 Gecko 也是一个跨平台内核，可以在Windows、 BSD、Linux 和 Mac OS X 中使用。 Webkit Safari 是苹果公司开发的浏览器，使用了KDE（Linux桌面系统）的 KHTML 作为浏览器的内核，Safari 所用浏览器内核的名称是大名鼎鼎的 WebKit。 Safari 在 2003 年 1 月 7 日首度发行测试版，并成为 Mac OS X v10.3 与之后版本的默认浏览器，也成为苹果其它系列产品的指定浏览器（也已支持 Windows 平台）。 如上述可知，WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。当年苹果在比较了 Gecko 和 KHTML 后，选择了后者来做引擎开发，是因为 KHTML 拥有清晰的源码结构和极快的渲染速度。 Webkit 内核可以说是以硬件盈利为主的苹果公司给软件行业的最大贡献之一。 注：苹果在 Safari 里面使用了自己的 Nitro JavaScript 引擎（只用 WebKit 来渲染 HTML），所以一般说到 Webkit，通常指的就是渲染引擎（而不包括 Javascript 引擎）。 Chromium/Blink 2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。 chromium 是基于 webkit 引擎的，却把 WebKit 的代码梳理得可读性提高很多。因此 Chromium 引擎和其它基于 WebKit 的引擎所渲染页面的效果也是有出入的。所以有些地方会把 chromium 引擎和 webkit 区分开来单独介绍，而有的文章把 chromium 归入 webkit 引擎中，都是有一定道理的。 Blink 是一个由 Google 主导开发的开源浏览器引擎，Google 计划将这个渲染引擎作为 Chromium 计划的一部分，并且在2013年4月的时候公布了这一消息。 webkit 用的好好的，为何要投入到一个新的内核中去呢？ Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit 作为渲染引擎，但出于某种原因，并没有将其多进程架构移植入Webkit。 后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。 基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。 总的来说，Chromium 基于 Webkit 引擎，衍生出 Blink。据说 Blink 删除了 880w 行 webkit 代码。 Presto Presto 是 Opera 自主研发的渲染引擎，然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎。 在 Chrome 于 2013 年推出 Blink 引擎之后，Opera 也紧跟其脚步表示将转而使用 Blink 作为浏览器核心引擎。 Opera 的一个里程碑作品是 Opera7.0，因为它使用了 Opera Software 自主开发的 Presto 渲染引擎，取代了旧版 Opera 4 至 6 版本使用的 Elektra 排版引擎。该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。 换内核的代价对于 Opera 来说过于惨痛。使用谷歌的 WebKit 内核之后，原本快速，轻量化，稳定的 Opera 浏览器变得异常的卡顿，而且表现不稳定，Opera 原本旧内核浏览器书签同步到新内核上的工作 Opera 花了整整两年时间，期间很多 Opera 的用户纷纷转投谷歌浏览器和其他浏览器，造成了众多的用户流失。 JS 引擎 JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 主流浏览器的 JavaScript 引擎： V8：用 C++ 编写，开放源代码，由 Google 丹麦开发，是 Google Chrome 的一部分，也用于 Node.js。 JavaScriptCore：开放源代码，用于 webkit 型浏览器，如：Safari。2008年实现了编译器和字节码解释器，升级为了 SquirrelFish。苹果内部代号为 Nitro 的 JavaScript 引擎也是基于 JavaScriptCore 引擎的。 Rhino：由Mozilla基金会管理，开放源代码，完全以Java编写，用于 HTMLUnit。 SpiderMonkey：第一款 JavaScript 引擎，早期用于 Netscape Navigator，现时用于Mozilla Firefox。 Chakra（JScript引擎）：用于Internet Explorer 11。 Chakra （JavaScript引擎）用于Microsoft Edge。 KJS：KDE 的 ECMAScript／JavaScript 引擎，最初由哈里·波顿开发，用于 KDE 项目的 Konqueror 网页浏览器中。 主流浏览器 国内常见的浏览器有：IE、Firefox、QQ浏览器、Safari、Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360浏览器、UC浏览器、遨游浏览器、世界之窗浏览器等。但目前最为主流浏览器有五大款： IE Firefox Google Chrome Safari Opera 各常用浏览器所使用的内核： IE：Trident 内核 Chrome：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核 Firefox：Gecko 内核 Safari：Webkit 内核 Opera：最初是自己的 Presto 内核，后来是 Chromium 内核，现在是 Blink 内核 360、猎豹浏览器：Trident + Chrome 双内核 搜狗、遨游、QQ浏览器：Trident（兼容模式）+ Webkit（高速模式） 百度、世界之窗浏览器：Trident 内核 2345：以前是IE内核，现在也是 IE + Chrome 双内核 浏览器 内核（渲染引擎） JavaScript 引擎 Chrome Blink（28~） Webkit（Chrome 27） V8 FireFox Gecko SpiderMonkey Safari Webkit JavaScriptCore Edge EdgeHTML Chakra(for JavaScript) IE Trident Chakra(for JScript) PhantomJS Webkit JavaScriptCore Node.js - V8 浏览器的工作原理 从浏览器中输入URL并回车，到显示器上看到网页，这中间都发生了什么？ 一、导航 导航是加载 web 页面的第一步。它发生在以下情形：用户通过在地址栏输入一个URL、点击一个链接、提交表单或者是其他的行为。 1.DNS 查找 导航的第一步是解析域名，找到页面资源的位置。 浏览器通过服务器名称请求 DNS 进行查找，最终返回一个IP地址，第一次初始化请求之后，这个IP地址可能会被缓存一段时间，这样可以通过从缓存里面检索IP地址而不是再通过域名服务器进行查找来加速后续的请求。其具体过程如下： 查找浏览器缓存：浏览器会缓存2-30分钟访问过网站的 DNS 信息 检查系统缓存：检查hosts文件，它保存了一些访问过网站的域名和IP的数据 检查路由器缓存：路由器有自己的DNS缓存 检查ISP DNS缓存：ISP服务商DNS缓存（本地服务器缓存） 递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索对应目标域名的IP DNS 查找对于性能来说是一个问题，特别是对于移动网络。当一个用户用的是移动网络，每一个 DNS 查找必须从手机发送到信号塔，然后到达一个认证 DNS 服务器。手机、信号塔、域名服务器之间的距离可能是一个大的时间等待。 2.TCP 握手协议 一旦获取到服务器IP地址，浏览器就会通过TCP 三次握手 与服务器建立连接。这个机制的是用来让两端尝试进行通信—浏览器和服务器在发送数据之前，通过上层协议Https可以协商网络TCP套接字连接的一些参数。 第一次握手：客户端向服务器端发送请求等待服务器确认 第二次握手：服务器收到请求并确认，回复一个指令 第三次握手：客户端收到服务器的回复指令并返回确认 3.TLS 协商 TLS 是 Transport Layer Security 的缩写，中文翻译 传输层安全性协议。 为了在 HTTPS 上建立安全连接，另一种握手是必须的。更确切的说是 TLS 协商 ，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。 虽然建立安全连接对增加了加载页面的等待时间，对于建立一个安全的连接来说，以增加等待时间为代价是值得的，因为在浏览器和web服务器之间传输的数据不可以被第三方解密。 二、响应 一旦我们建立了到 web 服务器的连接，浏览器就代表用户发送一个初始的 HTTP GET 请求，对于网站来说，这个请求通常是一个 HTML 文件。 一旦服务器收到请求，它将使用相关的响应头和HTML的内容进行回复。 三、解析 解析是浏览器将通过网络接收的数据转换为 DOM树 和 CSSOM树 的步骤，通过渲染器把 DOM树 和 CSSOM树 在屏幕上绘制成页面。 1.构建DOM树 第一步是处理 HTML 标记并构造 DOM 树。HTML解析涉及到标记化和树的构造。HTML标记包括开始和结束标记，以及属性名和值。 如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建文档树。 当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个CSS文件时，解析也可以继续进行，但是对于 script 标签（特别是没有 async 或者 defer 属性）会阻塞渲染并停止HTML的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。 2.构建CSSOM树 第二步是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM是两棵树。它们是独立的数据结构。浏览器将CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。 JavaScript 编译 当 CSS 被解析并创建 CSSOM 时，其他资源，包括JavaScript文件正在下载（多亏了preload scanner）。JavaScript被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用 Abstract Syntax Tree 并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的 JavaScript 编译。 构建辅助功能树 浏览器还构建辅助设备用于分析和解释内容的辅助功能树。可访问性对象模型（AOM）类似于DOM的语义版本。当DOM更新时，浏览器会更新辅助功能树。辅助技术本身无法修改可访问性树。 四、渲染 渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。在解析步骤中创建的 CSSOM 树和 DOM 树组合成一个 Render 树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。 1.样式计算 第三步是将 DOM 树和 CSSOM 树组合成一个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点。 2.布局计算 第四步是在渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。 第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。 3.绘制 最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为首次有效绘制（first meaningful paint）。在绘制阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。绘画包括将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素。 合成 绘制可以将布局树中的元素分解为多个层（类似层级上下文）。当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。 层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。 解析 html 生成 DOM 树，解析 css，生成 CSSOM 树，将 DOM 树和 CSSOM 树结合，生成渲染树； 根据渲染树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系 - 回流； 根据渲染树以及回流得到的节点信息，计算出每个节点在屏幕中的位置 - 重绘； 最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面。 五、交互 主线程绘制页面完成后，页面不一定是可用的。比如：有 JS 文件可能是2 MB，而且用户的网络连接很慢。在这种情况下，用户可以非常快地看到页面，但是在下载、解析和执行脚本之前，就无法滚动。 重流和重绘 渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。 页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（a:hover）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。 重流 当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为重流（回流）。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的 DOM 元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 一些会导致回流的CSS属性： width, height, padding, border, margin, position, top, left, bottom, right, float, clear, text-align, vertical-align, line-height, font-weight, font-size, font-family, overflow, white-space 重绘 (Repaint) 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 容易造成重绘操作的css： color, border-style, border-radius, text-decoration, box-shadow, outline, background 如何进行优化，减少重绘和重流 浏览器自己的优化 每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制。浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 这些属性或方法都需要得到最新的布局信息，所以浏览器必须去回流执行。因此，在项目中，尽量避免使用上述属性或方法，如果非要使用的时候，也尽量将值缓存起来，而不是一直获取。 减少重流与重绘 CSS： 避免使用 table|flex 布局。可能很小的一个小改动会造成整个 table|flex 的重新布局。 使用 visibility 替换 display: none 。因为前者只会引起重绘，后者会引发回流（改变了布局） 尽可能在 DOM 树的最末端改变 class。回流是不可避免的，但可以减少其影响，可以限制回流的范围，使其影响尽可能少的节点。 避免设置多层内联样式； 将动画效果应用到 position 属性为 absolute|fixed 的元素上。 避免使用CSS表达式。 使用 transform 替代 top。 将频繁重绘或者回流的节点设置为图层。图层能够阻止该节点的渲染行为影响别的节点。如： will-change、video、iframe 等标签，浏览器会自动将该节点变为图层。 css3硬件加速（GPU加速）。 使用css3硬件加速，可以让 transform、opacity、filters、will-change 这些动画不会引起回流重绘 。但对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 JavaScript： 避免频繁操作样式。最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。 避免频繁操作DOM。创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。也可以先为元素设置 display: none ，操作结束后再把它显示出来。因为在 display: none 的元素上进行的 DOM 操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性。如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。 浏览器加载JavaScript脚本 JavaScript 是一种具有函数优先的轻量级、解释型或即时编译型的编程语言。虽然它是作为开发 Web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，例如 Node.js、 Apache CouchDB 和 Adobe Acrobat。JavaScript 是一种基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 JavaScript 的标准是 ECMAScript 。截至 2012 年，所有的现代浏览器都完整的支持 ECMAScript 5.1，旧版本的浏览器至少支持 ECMAScript 3 标准。2015 年 6 月 17 日，ECMA 国际组织发布了 ECMAScript 的第六版，该版本正式名称为 ECMAScript 2015，但通常被称为 ECMAScript 6 或者 ES6。自此，ECMAScript 每年发布一次新标准。 嵌入 JavaScript 代码 在 HTML 文档里嵌入 JavaScript 代码有四种方法： 在 HTML 标签的事件属性中直接添加脚本代码。 使用 script 标签在网页中直接插入脚本代码。 console.log(\"JavaScript！\") script 标签有一个 type 属性，用来指定脚本类型。属性的值为 MIME 类型，支持的 MIME 类型包括：text/javascript（默认值）、text/ecmascript、application/javascript、application/ecmascript。如果 MIME 类型不是 JavaScript 类型，则该元素所包含的内容会被当作数据块而不会被浏览器执行。 如果 type 属性为module，代码会被当作 JavaScript 模块。 使用 script 标签链接外部脚本文件。 在 URL 使用特殊的 Javascript: 协议。 现在是什么时间了？ JavaScript 加载流程 浏览器加载 JavaScript 脚本，其正常流程如下： 浏览器的渲染引擎持有渲染的控制权，它正常解析 HTML 页面。 解析遇到 script 标签，渲染引擎移交控制权给 Javascript 引擎。 如果 script 标签引用了外部脚本那就先下载再执行，否则直接执行代码。 JavaScript 引擎执行完毕移交控制权给渲染引擎，渲染引擎继续解析。 浏览器可以同时并行加载多个 .js 文件，但下载后并不一定立即执行，而是按引入的顺序执行，也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。 此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。 defer属性 浏览器解析到包含 defer 属性的 script 元素时，其运行流程如下： 浏览器的呈现引擎持有渲染的控制权，它正常解析 HTML 页面。 解析遇到包含 defer 属性的 script 标签，继续解析 HTML，同时并行下载外链脚本。 解析完成，文档处于交互状态时开始解析处于 deferred 模式的脚本。 脚本解析完毕后，将文档状态设置为完成，DOMContentLoaded 事件随之触发。 使用 defer 属性时需要注意的点： defer 属性下载的脚本文件在 DOMContentLoaded 事件触发前执行，即，刚刚读取完 html 标签。 defer 属性可以保证执行顺序就是它们在页面上出现的顺序。 对于内置而不是加载外部脚本的 script 标签，以及动态生成的 script 标签，defer 属性不起作用。 使用 defer 加载的外部脚本不应该使用 document.write 方法。 async属性 浏览器解析到包含 async 属性的 script 元素时，其运行流程如下： 浏览器的呈现引擎持有渲染的控制权，它正常解析 HTML 页面。 解析遇到包含 async 属性的 script 标签，继续解析 HTML，让另一进程同时并行下载外链脚本。 脚本下载完成，浏览器暂停解析 HTML，开始执行下载的脚本。 脚本执行完毕，浏览器恢复解析 HTML。 使用 async 属性时需要注意的点： async 属性可以保证脚本下载的同时，浏览器继续渲染。 async 属性无法保证脚本的执行顺序，哪个先下载结束就先执行哪一个。 包含 async 属性的脚本不应该使用 document.write 方法。 如果同时使用 async 和 defer 属性，后者不起作用，浏览器行为由 async 属性决定。 脚本的动态加载 JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。 script 元素还可以动态生成，生成后再插入页面，从而实现脚本的动态加载。动态生成的 script 标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。如果想避免这个问题，可以设置 async 属性为 false。还可以监听脚本的 onload 事件来为脚本指定回调。 CSS 阻塞 JS 加载 因为 JS 脚本可能会引用 DOM 的样式做计算，所以为了保证脚本计算的正确性，Firefox 浏览器会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit 则是一旦发现脚本引用了样式，就会暂停执行脚本，等到样式表下载并解析完，再恢复执行。 预加载扫描器 当主线程在解析 HTML 和 CSS 时，预加载扫描器将找到脚本和图像，并开始下载它们。为了确保脚本不会阻塞进程，当 JavaScript 解析和执行顺序不重要时，可以添加 async 属性或 defer 属性。 请注意，预加载扫描器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。 浏览器引擎前缀 浏览器厂商们有时会给实验性的或者非标准的 CSS 属性和 JavaScript API 添加前缀，这样开发者就可以用这些新的特性进行试验，同时（理论上）防止他们的试验代码被依赖，从而在标准化过程中破坏 web 开发者的代码。开发者应该等到浏览器行为标准化之后再使用未加前缀的属性。 CSS 前缀 主流浏览器引擎前缀: -webkit-：Chrome、Safari、新版Opera浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器 -moz-：firefox 浏览器 -o-：旧版 Opera 浏览器 -ms-：IE、Edge 浏览器 -webkit-transition: all 4s ease; -moz-transition: all 4s ease; -ms-transition: all 4s ease; -o-transition: all 4s ease; transition: all 4s ease; API 前缀 过去，浏览器引擎也使用前缀修饰实验性质的 API。如果整个接口都是实验性的，前缀修饰的就是接口名（但不包括其中的属性或者方法）。如果将一个实验性的接口或者方法添加到一个标准化的接口中，这个新增的接口或者方法被前缀修饰。 接口前缀，需要使用大写的前缀修饰接口名： Webkit：Chrome、Safari、新版Opera浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器 Moz：firefox 浏览器 O：旧版 Opera 浏览器 Ms：IE、Edge 浏览器 属性和方法前缀，需要使用小写的前缀修饰属性或者方法： webkit：Chrome、Safari、新版Opera浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器 moz：firefox 浏览器 o：旧版 Opera 浏览器 ms：IE、Edge 浏览器 var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame; 相关问题 渲染页面时常见哪些不良现象？ FOUC：无样式内容闪烁（Flash Of Unstyled Content），主要指的是样式闪烁的问题，由于浏览器渲染机制（比如：firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。 白屏：有些浏览器渲染机制（比如：chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。 什么是 javascript: 协议？ javascript: 协议是在 URL 前面跟一个 javascript: 协议限定符，是另一种嵌入 JavaScript 代码到客户端的方式。这种特殊的协议类型指定 URL 内容为任意字符串，这个字符串是会被 JavaScript 解释器运行的 JavaScript 代码。javascript:URL 能识别的「资源」是转换成字符串的执行代码的返回值，如果代码返回 undefined，那么这个资源是没有内容的。 javascript:URL 可以用在任意使用常规 URL 的地方，比如 a 标签的 href 属性，form 标签的 action 属性，甚至 window.open() 方法的参数。 现在是什么时间了？ 部分浏览器（Firefox、Chrome）会执行 URL 里面的代码，并使用返回的字符串作为待显示新文档的内容。但是有些浏览器（如 Safari）则不支持这种语法，但是类似这样的 URL 还是支持的： 现在是什么时间了？ 上面两种方式：第一种会使用返回值覆盖当前文档，第二种则不会。如果要确保不覆盖当前文档，可以用 void 操作符强制函数调用或给表达式赋予 undefined 值。 打开一个窗口 javascript:URL 还可以用于测试一小段 JavaScript 代码，在浏览器地址栏直接输入 javascript:URL 即可。 此外，还可以用于浏览器书签，在 Web 浏览器中，「书签」就是一个保存起来的 URL。如果书签是 javascript:URL 那么保存的就是一小段脚本，叫做 bookmarklet，bookmarklet 是一个小型程序，很容易就可以从浏览器的菜单或工具栏里启动，bookmarklet 里的代码执行起来就像页面上的脚本一样，可以查询和设置文档的内容、呈现和行为，只要书签不返回值，就可以操作当前显示的任何文档，而不把文档替换成新内容。 参考链接 小文：浅谈浏览器发展简史 五大主流浏览器及四大内核 MDN 浏览器引擎前缀 MDN 渲染页面：浏览器的工作原理 浏览器的工作原理：新式网络浏览器幕后揭秘 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-05-31 20:58:34 "},"frontend/02-进阶-11-前端自动化测试.html":{"url":"frontend/02-进阶-11-前端自动化测试.html","title":"进阶 11 前端自动化测试","keywords":"","body":"进阶篇：前端自动化测试 测试是在开发完成的应用程序之上采用人工或非人工的方式验证应用是否有错误和缺陷、是否符合工程预期、是否会造成用户/开发商损失等潜在问题的一种方式。 自动化测试是采用一种非人工的测试方式，即使用软件工具或运行一段特定的测试代码，去验证目标代码是否满足期望。前端自动化测试一般是在预设条件下运行前端页面或逻辑模块，预设条件应包括正常条件和异常条件，以达到自动运行测试过程、减少或避免人工干预测试的目的，然后评估运行结果。 测试的目的是为了提升代码的质量、可靠性、可维护性，自动化测试则是将人工测试行为转化为由机器自动执行测试的行为，从而替代大量的手工测试操作，使测试能更加快速高效且准确定位问题、并且能反复进行。 为什么需要自动化测试？ 大多数情况下，前端代码都是开发者人工自测，又或是提测后由专门的测试人员人工测试。 人工测试能快速准确的获得视觉反馈，并且人的判断力和直觉总是有益于发现应用的一些缺陷或体验问题，但人工容易出现人为的失误或遗漏，另外还有最重要的一点，不利于后期的回归测试。自动化测试可找到比人工测试更多的错误，可以快速高效地进行测试，并且可以重用和执行相同类型的测试操作，它的缺点是会增加测试成本，如测试软件的费用，或者开发维护测试代码的成本。 自动化测试的优势： 可以验证代码正确性，保证项目质量； 测试用例可以复用，一次编写，多次运行； 通过看测试用例可以快速了解需求； 驱动开发，指导设计，保证写的代码可测试。 自动化的收益 = 迭代次数 * 全手动执行成本 - 首次自动化成本 - 维护次数 * 维护成本 什么项目适合自动化测试？ 自动化测试有很多优点，但并不是所有项目都适合自动化测试，主要原因是自动化测试的成本问题。在实施自动化测试以前需要对软件开发过程进行分析，基于投入产出来判断是否适合实施自动化测试。 一般需要同时满足以下条件： 任务测试明确，需求变更不频繁； 项目周期足够长； 自动化测试脚本可重复使用； 比较频繁的回归测试； 开发比较规范，具有可测试性。 若是需求变更过于频繁，维护测试脚本的成本过高；若是项目周期比较短，没有足够的时间去支持自动化测试的过程；若是测试脚本重复使用率低或者后期不需要频繁的回归测试，耗费的精力大于创造的价值，不值得；若是代码不规范，可测试性差，那自动化测试实施起来会比较困难。 测试的方法 测试方法一般分为黑盒测试、白盒测试和灰盒测试。 黑盒测试 黑盒测试，也称黑箱测试，是软件测试方法，测试应用程序的功能，而不是其内部结构或运作。测试者不需具备应用程序的代码、内部结构和编程语言的专门知识。测试者只需知道什么是系统应该做的事，即当键入一个特定的输入，可得到一定的输出。测试案例是依应用系统应该做的功能，按照规范、规格或要求等设计。测试者选择有效输入和无效输入来验证是否正确的输出。 此测试方法可适合大部分的软件测试，例如集成测试、系统测试。 白盒测试 白盒测试，又称透明盒测试、结构测试，是一个测试软件的方法，测试应用程序的内部结构或运作，而不是测试应用程序的功能（即黑盒测试）。在白盒测试时，以编程语言的角度来设计测试案例。测试者完全知道程序的结构和处理算法，按照程序内部逻辑设计测试用例，检测程序中的主要执行通路是否能按照预定要求正确工作，类似测试电路中的节点。 此测试方法可适合单元测试、集成测试和系统的软件测试流程，可测试在集成过程中每一单元之间的路径，或者主系统跟子系统中的测试。 灰盒测试 灰盒测试，是介于白盒测试与黑盒测试之间的，可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。 测试工作流程 按照软件工程自底而上的概念，前端测试一般分为单元测试、集成测试、端到端（E2E）测试。 单元测试 单元测试，也称模块测试，通常可放在编程阶段，由程序员对自己编写的模块自行测试，检查模块是否实现了详细设计说明书中规定的功能和算法。单元测试主要发现编程和详细设计中产生的错误，单元测试计划应该在详细设计阶段制定。 单元测试是指对程序中最小可测试单元进行的，如一个函数、一个模块、一个组件等，着重从以下方面测试：模块接口、局部数据结构、重要的执行通路、出错处理通路及边界条件等。 前端单元测试和后端单元测试最大的区别在于：前端单元测试无法避免的会存在兼容性问题，如浏览器兼容性API、BOM API 的调用，因此前端单元测试需要运行在（伪）浏览器环境下。 单元测试的解决方案： Mocha：是一个专注于灵活性的 JavaScript 测试框架。因为其灵活性，它允许你选择不同的库来满足诸如侦听（Sinon）和断言（Chai）等其它常见的功能。另一个 Mocha 独特的功能是它不止可以在 Node.js 里运行测试，还可以在浏览器里运行测试。 Jest：是一个专注于简易性的 JavaScript 测试框架。一个其独特的功能是可以为测试生成快照 (snapshot)，以提供另一种验证应用单元的方法。 Ava：更轻量高效简单的单测框架，但自身不够稳定，并发运行文件多的时候会撑爆 CPU。 Jasmine：单测框架的“元老”，开箱即用，但是异步测试支持较弱。 Karma：能在真实的浏览器中测试，强大适配器，可配置其他单测框架，一般会配合 Mocha、Jasmine 等一起使用。 每个框架都有自己的优缺点，没有最好的框架，只有最适合的框架。Augular 默认的是 Karma + Jasmine，而 React、Vue 默认的是 Jest。 集成测试 集成测试，也称组装测试、综合测试、联合测试，是指在单元测试的基础上，对由已通过单元测试的模块组装而成的程序进行正确性检测的测试，主要目标是发现模块间的接口和通信问题，检测模块组合在一起是否能正常工作、代码工作是否符合预期。集成测试最大的难点就是颗粒度较大，逻辑更加复杂，外部因素更多，无法保证测试的可控和独立性。 集成测试常用在：耦合度较高的函数/组件、经过二次封装的函数/组件、多个函数/组件组合而成的函数/组件等。 Vue 组件测试推荐 Vue Testing Library、Vue Test Utils。 （Unit Test）有 Mocha, Ava, Karma, Jest, Jasmine 等。 端到端 (E2E，end-to-end) 测试 端到端测试可以说从应用最重要的方面进行测试覆盖：当用户实际使用应用时会发生什么。 换句话说，端到端测试是站在用户的角度进度的，验证应用中的所有层，包括前端代码、后端服务和相应的基础设施，它们更能代表你的用户所处的环境。通过测试用户操作如何影响应用，端到端测试通常是提高应用是否正常运行的信心的关键。 对于前端，端到端测试的一个主要优点是它能够跨多个浏览器测试应用。 端到端测试解决方案： Cypress.io：一个测试框架，旨在通过使开发者能够可靠地测试他们的应用，同时提供一流的开发者体验，来提高开发者的生产率。 Nightwatch.js：一个端到端测试框架，可用于测试 web 应用和网站，以及 Node.js 单元测试和集成测试。 Puppeteer：一个 Node.js 库，它提供高阶 API 来控制浏览器，并可以与其他测试运行程序 (例如 Jest) 配对来测试应用。 TestCafe：一个基于端到端的 Node.js 框架，旨在提供简单的设置，以便开发者能够专注于创建易于编写和可靠的测试。 Mocha mocha 是一个功能丰富的 javascript 测试框架，运行在 node.js 和浏览器中，使异步测试变得简单有趣。Mocha测试连续运行，允许灵活和准确的报告，同时将未捕获的异常映射到正确的测试用例。 安装：npm i mocha -S。 创建一个测试 Js 文件： // test/index.js const assert = require('assert') describe('Array', function() { describe('#indexOf()', function() { it('should return -1 when the value is not present', function() { assert.equal([1,2,3].indexOf(4), -1) }) }) }) 然后在终端运行：./node_modules/mocha/bin/mocha。 mocha 命令的基本格式是： mocha [debug] [options] [files] mocha # 默认运行当目录下 test 目录里面的测试脚本，不包括子文件 mocha add.test.js # 当前目录下面的该测试脚本 mocha file1 file2 file3 # mocha命令后面紧跟测试脚本的路径和文件名，可以指定多个测试用例 mocha spec/{my,awesome}.js mocha test/unit/*.js mocha –recursive # 执行test子目录下面的所有的测试用例 mocha –watch # -w 监控执行 mocha –timeout 5000 timeout.test.js # -t 异步测试中需要，默认时间为 2000 执行结果： Array #indexOf() √ should return -1 when the value is not present 1 passing (3ms) Jest Jest 是一个令人愉快的 JavaScript 测试框架，专注于 简洁明快。 Jest 的目标是在大部分 JavaScript 项目上实现开箱即用， 无需配置。 安装：npm i jest -S。 创建一个测试 Js 文件： // test/index.test.js function sum (a, b) { return a + b } test('adds 1 + 2 to equal 3', () => { expect(sum(1, 2)).toBe(3) }) 然后终端执行：./node_modules/jest/bin/jest.js。 jest # jest 附加参数会以正则表达式来匹配项目中的文件 jest # 默认正则 **/__tests__/**/*.[jt]s?(x), **/?(*.)+(spec|test).[tj]s?(x) jest my-test # 指定目录测试 jest path/to/my-test.js # 指定文件测试，文件名需符合默认的正则匹配。 执行结果： PASS test/index.test.js √ adds 1 + 2 to equal 3 (2 ms) Test Suites: 1 passed, 1 total Tests: 1 passed, 1 total Snapshots: 0 total Time: 0.628 s, estimated 2 s Ran all test suites. Cypress.io Cypress.io 是一个测试框架，旨在通过使开发者能够可靠地测试他们的应用，同时提供一流的开发者体验，来提高开发者的生产率。 Cypress 学习指南 安装：npm i cypress -S。 终端运行：./node_modules/cypress/bin/cypress open，初始化并生成一堆用例（目录结构如下），并打开 Cypress 的界面。如果已初始化，则直接打开 Cypress。 ├─cypress | ├─fixtures | │ example.json | │ | ├─integration | │ ├─1-getting-started | │ │ todo.spec.js | │ │ | │ └─2-advanced-examples | │ actions.spec.js | │ aliasing.spec.js | │ assertions.spec.js | │ connectors.spec.js | │ cookies.spec.js | │ cypress_api.spec.js | │ files.spec.js | │ local_storage.spec.js | │ location.spec.js | │ misc.spec.js | │ navigation.spec.js | │ network_requests.spec.js | │ querying.spec.js | │ spies_stubs_clocks.spec.js | │ traversal.spec.js | │ utilities.spec.js | │ viewport.spec.js | │ waiting.spec.js | │ window.spec.js | │ | ├─plugins | │ index.js | │ | └─support | commands.js | index.js cypress.json 测试文件示例： // cypress\\integration\\test\\index.js describe('端到端测试：示例', () => { before(() => console.log('开始：')); beforeEach(() => cy.visit('https://example.cypress.io/todo')); it('标题文案：todos', () => { cy.get('.todoapp .header h1').should('have.text', 'todos') }) it('有两个li节点', () => { cy.get('.todo-list li').should('have.length', 2) }) it('输入文案：lizhao', () => { cy.get('.todoapp .header input').type('lizhao') cy.get('.todoapp .header input').should('have.value', 'lizhao') }) it('比较', () => { expect(2 + 2).to.equal(4) }) }); 测试文件默认位于cypress/integration，点击该目录下任意 Js 文件，可以在浏览器中模拟用户操作，并在浏览器中显示测试结果。 Cypress 中内置的断言包含了几种类型： Chai：断言。 expect('test').to.be.a('string') // BDD 风格 assert.equal(3, 3, 'vals equal') // TDD 风格 Chai jQuery：关于 DOM 的断言。 expect(\\$el).to.have.attr('foo', 'bar') Sinon-Chai：关于函数调用情况的断言。 expect(spy).to.be.called .should()：在 Cypress 中封装了以上所有可用断言。 cy.get('li.selected').should('have.length', 3) // should cy.get('div').should(($div) => { expect($div)... }) // BDD Nightwatch.js Nightwatch.js是一个集成的、易于使用的 Web 应用程序和网站的端到端测试解决方案，用 Node.js 编写。它使用W3C WebDriver API来驱动浏览器并对 DOM 元素执行命令和断言。 安装：npm i -S nightwatch。 安装浏览器驱动程序：npm i -S geckodriver chromedriver safaridriver。注意： Edge 驱动程序可以从Microsoft Edge 驱动程序官方主页下载；在使用 safaridriver 之前，您需要运行一次以下命令：safaridriver --enable。 创建测试文件： describe('Ecosia', function() { it('demo test', function(browser) { browser .url('https://www.ecosia.org/') .setValue('input[type=search]', 'nightwatch') .click('button[type=submit]') .assert.containsText('.mainline-results', 'Nightwatch.js'); }); it('比较', () => { expect(2 + 2).to.equal(4) }) }); 终端执行：./node_modules/nightwatch/bin/nightwatch --env chrome test/index.js。 参考资料 Vue 测试 前端自动化测试概览 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-03-26 00:03:46 "},"frontend/03-高级-01-前端安全.html":{"url":"frontend/03-高级-01-前端安全.html","title":"高级 01 前端安全","keywords":"","body":"高级篇：前端安全 安全的重要性不言而喻，是所有互联网企业都绕不开的话题。 安全 是个很大的话题，各种安全问题的类型也是种类繁多。如果把安全问题按照所发生的区域来进行分类的话，那么所有发生在后端服务器、应用、服务当中的安全问题就是 后端安全问题，而所有发生在浏览器、单页面应用、Web 页面当中的安全问题则算是 前端安全问题。 比如，SQL 注入漏洞发生在后端应用中，是后端安全问题；跨站脚本攻击（XSS）则是前端安全问题，因为它发生在用户的浏览器里。 本文收集了一些常用的前端安全问题及其防御措施。 XSS攻击 XSS 攻击全称跨站脚本攻击（Cross-Site Scripting），简单的说就是攻击者通过在目标网站上注入恶意脚本并运行，获取用户的敏感信息如 Cookie、SessionID 等，影响网站与用户数据安全。 XSS（Cross-Site Scripting，为了和 CSS 区分，把第一个字母改成了 X）是指跨站脚本攻击，是前端最常见的安全问题。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行，一旦成功运行，攻击者可以做以下危害用户的行为： 获取用户的敏感信息如 Cookie、SessionID 等； 以当前用户的身份发起一些非用户本意的操作请求，比如，删除网站好友、发帖、发私信等等； 实现 DDos（Distributed Denial Of Service） 攻击，即分布式拒绝服务攻击，这种网络攻击形式尝试用恶意流量淹没网站或网络资源，从而导致网站或网络资源无法正常运行。 XSS 攻击的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。 XSS攻击类型 XSS 攻击可分为三类：反射型、存储型、DOM 型。 反射型 反射型 XSS 也被称为非持久性 XSS，是现在最容易出现的一种 XSS 漏洞。它指的是攻击者通过巧妙地构造一个带恶意代码的 URL，然后引导用户点击访问，用户打开该 URL 时，服务端将恶意代码从 URL 中取出，拼接在 HTML 文档中返回给浏览器，浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 反射型 XSS 的恶意代码存在 URL 里，常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 存储型 存储型 XSS 又被称为持久性 XSS，它是最危险的一种跨站脚本，它具有更高的隐蔽性、危害更大，不需要用户手动触发。它是将恶意代码提交到了网站的数据库中，被服务器端接收并存储，当浏览者访问页面时，服务端会将恶意代码从数据库取出，拼接在 HTML 文档中返回给浏览器，浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 存储型 XSS 的恶意代码存在数据库里，常见于带保存数据功能的网站，如论坛发帖、商品评论、用户私信等。 DOM型 DOM 型 XSS 是利用 DOM 本身存在的缺陷进行攻击。攻击者构建了特殊的 URL，其中包含恶意代码，用户打开带有恶意代码的 URL， JavaScript 取出 URL 中的恶意代码并执行，从而窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 XSS攻击示例 XSS 攻击常见的注入方式： 在 HTML 中注入包含脚本的 script 标签、引用外部 Js 的 script 标签； 在标签属性引用包含引号的恶意代码，从而注入其他属性或者标签； 在标签的 href、src 等属性注入包含 javascript: 等可执行代码； 样式中注入 url(\"javascript:...\")、content(\"...\")等代码； 在 onload、onerror、onclick 等事件中，注入不受控制代码； eval()、setTimeout()、setInterval()、new Function() 等 API 中，注入不受控制代码。 \"> alert(0)， 最终渲染会创建一个 script 标签，并执行里面代码，渲染结果如下： --> alert(0)\"> \">跳转 跳转 注意： 反射型 XSS 和 存储型 XSS 中，加载的 HTML 文档是经过服务端处理的，注入了一些业务相关的数据，导致恶意代码混入在 HTML 文档，也就是常说的服务端渲染，如 jsp、asp 等网页。如果是静态 HTML 或者单页面应用，也就是前端渲染，就不会出现这两种攻击，但仍要注意 DOM 型 XSS。 XSS防御措施 限制输入，减少恶意代码的注入： 采用前端过滤不可靠输入、控制输入内容长度等方式，但这种方法的局限性也很明显，一是攻击者可以绕过过滤条件，直接调用 Ajax 写入数据库，二是对于输入值使用场景不确定或者有多个使用场景时，无法准确定义过滤条件，可能导致一些非异常的输入被过滤。 转义输出，避免执行恶意代码： 对数据进行严格的输出编码，使得攻击者提供的数据不再被浏览器认为是脚本而被误执行。例如 在进行 HTML 编码后变成了 &lt;script&gt;，这段数据就会被浏览器认为只是一段普通的字符串，而不会被当做脚本执行，同时，尽量避免使用 innerHTML、 document.write、 outerHTML、 eval 等方法，用安全性更高的 innerText、 setAttribute 等方法做替代； 设置HttpOnly： 对于所有包含敏感信息的 cookie，都在服务端设置 httpOnly，设置了 httpOnly 的 cookie 字段无法通过 JS 获取，也就降低了 XSS 攻击时用户凭据隐私泄漏的风险； 开启 CSP 防护： 内容安全策略（CSP）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本（XSS）和数据注入攻击等； 借助自动扫描工具寻找 XSS 漏洞，例如 Arachni、Mozilla HTTP Observatory、w3af 等。 CSRF攻击 CSRF（Cross-Site Request Forgeries）指的是跨站请求伪造攻击，简单的说就是，攻击者盗用了受害者的身份（Cookie、SessionID 等），以受害者的名义发送恶意请求。 攻击者在目标网站诱导受害者进入第三方网站，然后该网站向目标网站发送跨站请求，利用受害者在目标网站中保存的登录状态，绕过后台的用户验证，冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的事情。 CSRF 攻击的本质是利用了 目标网站保留在浏览器的 cookie，以某种方式绕过跨域限制，冒充受害者的身份，向目标网站的服务器发送请求，在用户不知情的情况下，完成某些操作。 CSRF 的攻击流程： 受害者登录目标网站 A，并保留了登录凭证； 受害者以某种方式接触到恶意网站 B 的链接； 受害者点击链接访问网站 B，网站 B 中的 Javascript 代码执行，偷偷向目标网站 A 发送某个请求； 由于受害者登录过网站 A，因此请求携带了网站 A 的相关 cookie 凭证，最后请求成功执行。 CSRF 攻击一般可分为： GET 类型： img 标签的 src 属性指向一个 Http 请求，当用户进入网站时，会自动发起提交； POST 类型：通常使用的是一个自动提交的表单； 链接类型：链接类型的 CSRF 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招。 CSRF攻击示例 浏览器有同源策略，Ajax 直接发送跨域请求一般会被拦截，但 CSRF 通常可用以下方式发送跨域请求的：img 标签的 scr 属性，a 标签的 href 属性，CORS（跨域资源共享）、Form 提交等。 document.querySelector(\"form\").submit() 泪目！！惊爆！！突发。。。 CSRF防御 CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。 同源检测： CSRF 攻击通常是发生在第三方网站的，因此可以通过域名判断来禁止第三方网站发送请求。服务器根据 HTTP 请求头中 origin、referer 信息来判断请求的来源域名，当域名不符，或者 origin、referer 为空时，则拒绝访问。 这个方法的缺点是，有些情况下 referer 可能没有或者不可信： IE6、7 下使用 location.href = url 进行界面的跳转，会丢失 referer； IE6、7 下使用 window.open，也会缺失 referer； HTTPS 页面跳转到 HTTP 页面，所有 referer 都丢失； 点击 Flash 上到达另外一个网站的时候，referer 的情况就比较杂乱，不太可信。 CSRF Token 验证： 用户打开页面时，服务器创建一个 Token 存到 session，同时将 Token 返回给用户，当网站再次发起请求时，在请求参数中加入服务器端返回的 Token ，然后服务器验证请求中的 Token 与 session 中的是否一致，一致就允许访问，否则拒绝访问。 这种方法的缺点是，需要给网站中的所有请求都添加上这个 Token，操作比较繁琐，还有就是对于不只一台服务器的网站，比如，请求经过负载平衡转移到了其他的服务器，而这个服务器的 session 中没有保留这个 Token 的话，就没有办法验证了。 双重 cookie 验证： 用户打开页面时，服务器向请求域名注入一个 cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。 cookie 的 Samesite 属性： Samesite 一共有两种模式：严格模式（Strict），cookie 在任何情况下都不能跨站使用；宽松模式（Lax），cookie 可以被导航到目标网址的 GET 请求跨站使用，比如，跳转链接、预加载请求、GET 表单。 ClickJacking（点击劫持） 点击劫持（Clickjacking）技术又称为界面伪装攻击（UI redress attack），是一种视觉上的欺骗手段。攻击者使用一个或多个透明的 iframe 覆盖在一个正常的网页上，然后诱使用户在该网页上进行操作，当用户在不知情的情况下点击透明的 iframe 页面时，用户的操作已经被劫持到攻击者事先设计好的恶意按钮或链接上。 这是一种欺骗性比较强，同时也需要用户高度参与才能完成的一种攻击。 通常的攻击步骤是这样的： 攻击者精心构造一个诱导用户点击的内容，比如 Web 页面小游戏； 将目标网站的页面放入到 iframe 当中； 利用 z-index 等样式将这个 iframe 叠加到小游戏的垂直方向的正上方，并把 iframe 设置为 100% 透明度； 受害者访问到这个页面后，肉眼看到的是一个小游戏，如果受到诱导进行了点击的话，实际上点击到的却是 iframe 中目标网站的页面。 点击劫持的危害在于，攻击利用了受害者的用户身份，在其不知情的情况下进行一些操作。如果只是迫使用户关注某个微博账号的话，看上去仿佛还可以承受，但是如果是删除某个重要文件记录，或者窃取敏感信息，那么造成的危害就难以承受了。 点击劫持漏洞的防御 X-FRAME-OPTIONS 机制： 服务器响应头部字段 X-Frame-Options 用来给浏览器指示是否允许一个页面嵌套在 frame、 iframe、 object 中，使用此可以禁止其他网页使用 iframe 载入页面； 通过 Javascript 来禁止网站被其他网站的 iframe 引用，详见下一节； 使用认证码：要求用户输入图形中的验证码； 使用 CSP（Content Security Policy）内容安全策略。 其他安全漏洞 SQL 注入 SQL 注入就是通过给 Web 应用接口传入一些特殊字符，达到欺骗服务器执行恶意的 SQL 命令。 SQL 注入漏洞属于后端的范畴，但前端也可做体验上的优化。 原因： 当使用外部不可信任的数据作为参数进行数据库的增、删、改、查时，如果未对外部数据进行过滤，就会产生 SQL 注入漏洞。 sql = \"select * from users where name=\" + name; 由于 SQL 语句是直接拼接的，也没有进行过滤，所以，当用户输入 '' or '1'='1' 时，这个语句的功能就是搜索 users 全表的记录。 select * from users where name='' or '1'='1'; 解决： 不信任任何外部输入，避免 SQL 语句拼接。 DDoS 攻击 DoS 攻击全称拒绝服务（Denial of Service），一般来说是指攻击者对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。DDoS 攻击（分布式拒绝服务 Distributed Denial of Service）则是 DoS 的升级版。 简单来说： 攻击者不断地提出服务请求，让合法用户的请求无法及时处理，这就是 DoS 攻击。 攻击者使用多台计算机或者计算机集群进行 DoS 攻击，就是 DDoS 攻击。 XXE 漏洞 XXE 漏洞全称 XML 外部实体漏洞（XML External Entity），当应用程序解析 XML 输入时，如果没有禁止外部实体的加载，导致可加载恶意外部文件和代码，就会造成任意文件读取、命令执行、内网端口扫描、攻击内网网站等攻击。 场景1：攻击者尝试从服务端提取数据 ]> ]> &xxe; 场景2.：攻击者通过将上面的实体行更改为一下内容来探测服务器的专用网络 ]> 场景3：攻击者通过恶意文件执行拒绝服务攻击 ]> HTTP 报头追踪漏洞 HTTP/1.1（RFC2616）规范定义了 HTTP TRACE 方法，主要是用于客户端通过向 Web 服务器提交 TRACE 请求来进行测试或获得诊断信息。 当 Web 服务器启用 TRACE 时，提交的请求头会在服务器响应的内容（Body）中完整的返回，其中 HTTP 头很可能包括 Session Token、Cookies 或其它认证信息。攻击者可以利用此漏洞来欺骗合法用户并得到他们的私人信息。 目录遍历漏洞 攻击者向 Web 服务器发送请求，通过在 URL 中或在有特殊意义的目录中附加 ../、或者附加 ../ 的一些变形（如 ..\\ 或 ..// 甚至其编码），导致攻击者能够访问未授权的目录，以及在 Web 服务器的根目录以外执行命令。 命令执行漏洞 命令执行漏洞是通过 URL 发起请求，在 Web 服务器端执行未授权的命令，获取系统信息、篡改系统配置、控制整个系统、使系统瘫痪等。 文件上传漏洞 如果对文件上传路径变量过滤不严，并且对用户上传的文件后缀以及文件类型限制不严，攻击者可通过 Web 访问的目录上传任意文件，包括网站后门文件（webshell），进而远程控制网站服务器。 其他安全隐患 CDN 劫持 出于性能考虑，前端应用通常会把一些静态资源（Js、Css 等）存放到 CDN（Content Delivery Networks，内容分发网络）上面。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全风险。如果攻击者劫持了 CDN，或者对 CDN 中的资源进行了污染，攻击者可以肆意篡改前端页面，对用户实施攻击。 现在的 CDN 以支持 SRI 为荣，script 和 link 标签有了新的属性 integrity。SRI 全称 Subresource Integrity - 子资源完整性，是指浏览器通过验证资源的完整性（通常从 CDN 获取）来判断其是否被篡改的安全特性。 integrity 值分成两个部分，第一部分指定哈希值的生成算法（sha256、sha384、sha512），第二部分是经过 base64 编码的实际哈希值，两者通过中划线（-）分割。integrity 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。 注意： 使用 SRI 需要两个条件，一是要保证资源同域或开启跨域，二是在 script 标签中提供签名以供校验。 不安全的第三方依赖 现如今进行应用开发，无论是后端服务器应用还是前端应用开发，绝大多数时候都是在借助开发框架和各种类库进行快速开发。然而，一些第三方的依赖或者插件存在很多安全性问题，也会存在这样那样的漏洞，所以使用起来得谨慎。 解决方法：一是尽量减少第三方依赖，尽量选用相对成熟的依赖包；二是使用自动化工具检查第三方依赖是否安全，比如，NSP（Node Security Platform）、Snyk 等。 iframe 在需要用到第三方提供的页面时，通常会以 iframe 的方式引入。iframe 带来更多丰富的内容和能力的同时，也带来了不少的安全隐患。因为 iframe 中的内容是由第三方来提供的，默认情况下它们不受我们的控制，它们可以在 iframe 中运行 JavaScirpt 脚本、Flash 插件、弹出对话框等等，这可能会破坏前端用户体验。 如果说 iframe 只是有可能会给用户体验带来影响，看似风险不大，那么如果 iframe 中的域名因为过期而被恶意攻击者抢注，或者第三方被黑客攻破，iframe 中的内容被替换掉了，从而利用用户浏览器中的安全漏洞下载安装木马、恶意勒索软件等等，这问题可就大了。 一般可以通过 Javascript 来禁止网站被其他网站的 iframe 引用： if(top.location != self.location){ top.location.href = 'http://a.example.com' } 另外，也可以使用 html5 的新属性 sandbox，sandbox 主要是提高 iframe 安全系数。 比如，A 网站需要 iframe 引用 B 网站，但是不想被 B 网站操作 DOM、不想加载某些 JS（广告、弹框等）、当前窗口被强行跳转链接等，我们可以设置 sandbox 属性。 ... sandbox 属性值如下，多项可用空格分隔： allow-same-origin：允许被视为同源，即可操作父级 DOM 或 cookie 等； allow-top-navigation：允许当前 iframe 的引用网页通过 URL 跳转链接或加载； allow-forms：允许表单提交； allow-scripts：允许执行脚本文件； allow-popups：允许浏览器打开新窗口进行跳转； “”： 设置为空时上面所有允许全部禁止。 opener 通过 window.open 或者 a 标签带 target=\"_blank\" 打开的页面，能使用 window.opener 来访问源页面的 window 对象进行篡改原页面，采用以下方法可以阻止： window.open('http://target.example.com') // 防御方式 const target = window.open() target.opener = null target.location = 'http://target.example.com' 注意： 随着浏览器发展，其安全机制也越来越完善，大多数据情况，即使能访问源页面的 window 对象，能使用的方法和属性也有限制。 安全策略 HSTS（强制安全传输） HSTS（HTTP Strict Transport Security）是国际互联网工程组织 IETF 发布的一种互联网安全策略机制。采用 HSTS 策略的网站将保证浏览器始终连接到该网站的 HTTPS 加密版本，不需要用户手动在URL地址栏中输入加密地址，以减少会话劫持风险。 在网站全站 HTTPS 后，如果用户手动敲入网站的 HTTP 地址，或者从其它地方点击了网站的 HTTP 链接，通常依赖于服务端 301/302 跳转才能使用 HTTPS 服务。而第一次的 HTTP 请求就有可能被劫持，导致请求无法到达服务器，从而构成 HTTPS 降级劫持。 HSTS 并不是 HTTP 会话劫持的完美解决方案。用户首次访问某网站是不受 HSTS 保护的。这是因为首次访问时，浏览器还未收到 HSTS，所以仍有可能通过明文 HTTP 来访问。解决方案：一是在浏览器预置 HSTS 域名列表，二是将 HSTS 信息加入到域名系统记录中。 HSTS并不是HTTP会话劫持的完美解决方案。用户首次访问某网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能通过明文HTTP来访问。 通过 Chrome 的 chrome://net-internals/#hsts 工具，可以查询某个网站是否在预置列表中，还可以手动把某个域名加到本机预置列表。 CSP（内容安全策略） CSP（Content Security Policy）是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括 XSS 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。 CSP 的本质是建立一个白名单，告诉浏览器哪种类型资源可以从哪个或者哪些域名下加载和执行。 为使 CSP 可用，可以配置服务器在响应头部返回 Content-Security-Policy （X-Content-Security-Policy 是旧版本写法，无须再如此指定) 来指定内容安全策略，一个策略由一系列策略指令所组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略： # 所有内容均来自站点的同一个源 (不包括其子域名) Content-Security-Policy: default-src 'self' # 允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同) Content-Security-Policy: default-src 'self' *.trusted.com # 允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码 Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com 除此之外, meta 元素也可以被用来配置该策略： 相关问题 为什么不推荐使用 iframe？ iframes 提供了一种简单的方式把一个网站的内容嵌入到另一个网站中，其缺点是： 阻塞页面加载：及时触发 window 的 onload 事件是非常重要的，而 window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。 链接导航问题：使用 iframe 布局必须保证正确设定导航链接，否则，被链接的页面呈现在导航框架内，让浏览者无法退后，只能离开。 分散访问者注意力：iframe 布局的网站除了有时会让浏览者迷惑，分散注意力之外，还会给浏览者带来浏览麻烦，滚动条会使 iframe 布局混乱，让浏览者望而止步。 不利于 SEO 优化：引擎蜘蛛访问 iframe 布局的网站时，它只会看到框架，框架里面的内容是看不到的，也就无法按照顺序解读页面，会认为这个网站是个死站点，以后绝不会再来了。 安全问题：点击劫持、源页面全局对象暴露等问题。 请求头 origin、referer、host 区别？ Host： 指明了请求服务器的域名/IP地址和端口号，在任何类型请求中，请求头都会包含此信息。 HTTP/1.1 的所有请求报文中必须包含一个 Host 头字段。如果一个 HTTP/1.1 请求缺少 Host 头字段或者设置了超过一个的 Host 头字段，一个 400（Bad Request）状态码会被返回。 Referer： 指明了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的，包括协议、域名、端口号、路径、参数（不包含 hash 值）。如，https://target.example.com/。 Referer 一般情况下，只要浏览器能获取到请求源都会携带，而以下场景不会携带 Referer： 来源页面采用的协议为表示本地文件的 \"file\" 或者 \"data\" URI； 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）； 直接输入网址或通过浏览器书签访问； 使用 JavaScript 的 Location.href 或者是 Location.replace()； 使用 html5 中 noreferrer。 Origin： 指示了请求来自于哪个站点。该字段仅指示来源服务器的名称，并不包含任何路径信息。除了不包含路径信息，该字段与 Referer 字段相似。如，https://target.example.com。 只有跨域请求（响应头部有对应的 Access-Control-Allow-Origin），或者同域时发送 Post 请求，才会携带 Origin 请求头。如果浏览器不能获取请求源，那么 Origin 满足上面情况也会携带，不过其值为 null。 参考资料 前端安全系列（一）：如何防止XSS攻击？ 前端安全系列之二：如何防止CSRF攻击？ web安全之--点击劫持攻击与防御技术简介 开启HSTS让浏览器强制跳转HTTPS访问 前端安全汇总（持续更新） 8大前端安全问题（上） | 洞见 内容安全策略( CSP ) © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-01-14 12:34:08 "},"frontend/04-重读Vue教程.html":{"url":"frontend/04-重读Vue教程.html","title":"重读Vue教程","keywords":"","body":"重读Vue教程 Vue.js 是什么? Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。 Vue 只关注视图层， 采用自底向上增量开发的设计。 Vue 是一个提供了 MVVM 模式的双向数据绑定的 Javascript 库，专注于 View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel 负责连接 View 和 Model，保证视图和数据的一致性。 MVVM是什么？ MVVM 是 Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对 View 和 ViewModel 的双向数据绑定，这使得 View 的变化会自动更新到 ViewModel，ViewModel 的变化也会自动同步到View 上显示，即所谓的数据双向绑定。 View： 视图，即 DOM；对应 HTML 部分（代表 UI 组件），它负责将数据模型转化成 UI 展现出来。 Model： 模型，即数据模型；对应 Vue 组件里的 data，或者说是 vuex 里的数据；也可以在 Model 中定义数据修改和操作的业务逻辑。 ViewModel： 监听模型数据，也就是 data 的的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View。 MVVM 是基于 MVC 的设计，开发人员在 HTML 标签上写一些指定，利用一些指令绑定，就能在 Model 和ViewModel 保持不变的情况下，很方便的将 UI 设计与业务逻辑分离，从而大大的减少繁琐的 DOM 操作。 MVVM 框架与 MVC 框架的主要区别有两点： 实现数据与视图的分离 通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了。 Vue响应式原理 一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。 每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。 Class 与 Style 绑定 用 v-bind 绑定 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 事件处理 事件的绑定 v-on 指令： 指令可以直接运行一些 JavaScript 代码，也可以绑定事件处理方法，还可以在内联 JavaScript 语句中调用方法。 hello hello hello 需要注意：绑定事件处理方法，不能传参，但会将 event 做为方法的第一个参数；而直接调用方法 hello()，是可以指定传参的。同时，如果需要用到 event 时，可以传入特殊变量 $event 。 hello vm.$on( event, callback )： 监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数。 vm.$on('test', msg => { console.log(msg) }) vm.$emit('test', 'hello') // hello 将原生事件绑定到组件 使用 v-on 的 .native 修饰符，可以在一个组件的根元素上直接监听一个原生事件。 不过，有时候你可能并不是想将事件传递给组件的根元素，而是组件中的某个特定元素。 Vue 提供了一个 $listeners property，它是一个对象，里面包含了作用在这个组件上的所有监听器。再配合 v-on=\"$listeners\" 将所有的事件监听器指向组件中的某个特定的子元素。 { focus: function (event) { /* ... */ } input: function (value) { /* ... */ }, } 从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。 事件修饰符 .stop： 阻止事件冒泡； .prevent： 阻止事件默认行为； .capture： 添加事件监听器时使用事件捕获模式； .self： 只当在 event.target 是当前元素自身时触发处理函数； .once： 事件将只会触发一次； .passive： 事件的默认行为会立即触发，优先级高于 prevent； :keyup.enter： 监听键盘 enter 按键； :keyup.page-down： 监听键盘 pageDon 按键； 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 需要注意：键盘按键的键值，在不同浏览器可以不一样。Vue 内置了以下别名，支持旧浏览器：.enter, .tab, .delete, .esc, .space, .up, .down, .left, .righ。 组件注册 全局注册： Vue.component('my-component-name', { // ... 选项 ... }) 局部注册： const ComponentA = { /* ... */ } const ComponentB = { components: { 'component-a': ComponentA }, // ... } 自动化全局注册： Webpack 有一个 API require.context()，用来获取指定的文件夹内的特定文件。require.context 返回的结果是一个函数，该函数的传参是匹配的文件名的相对路径，返回的是一个模块。 require.context(directory，useSubdirectories，regExp) require.context 返回的函数，还有以下三个属性： resolve：函数，接文件夹下面匹配文件的相对路径，返回该文件相对于整个工程的相对路径； keys：函数，返回匹配成功文件的名字组成的数组； id：执行环境的id，返回的是一个字符串，主要用在 module.hot.accept ，应该是热加载？ 我们可以使用 require.context 全局注册一些非常通用的基础组件。 // 入口文件，如：src/main.js import Vue from 'vue' const requireComponent = require.context( '../../../components/form_items', // 其组件目录的相对路径 false, // 是否查询其子目录 /\\.(vue|js)$/ // 匹配基础组件文件名的正则表达式 ) requireComponent.keys().forEach(fileName => { const componentName = fileName.split('/')[1].split('.')[0] const componentConfig = requireComponent(fileName) Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的，那么就会优先使用 `.default`； // 否则回退到使用模块的根。 componentConfig.default || componentConfig ) }) Prop和 Attribute props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。 props: { propB: { type: [String, Array], // 原生构造函数，或原生构造函数组成的数组。包括：String、Number、Boolean、Array、Object、Date、Function、Symbol、任何自定义构造函数。 default: any || () => ({}), // 默认值。对象或数组的默认值必须从一个工厂函数返回。 required：Boolean, // 是否是必传项 validator: value => { // 自定义验证函数，将该 prop 的值作为唯一的参数代入。 return boolean } } } prop传值 传入一个对象的所有 property： 如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post： post: { id: 1, title: 'My Journey with Vue' } 自定义类型： function Person (firstName, lastName) { this.firstName = firstName this.lastName = lastName } props: { author: Person } 通过 instanceof 来来验证 prop 的值是否是通过 new Person 创建的。 非 Prop 的 Attribute 一个非 prop 的 attribute 是指传向一个组件，但是该组件 prop 没有定义对应的 property。 对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件根元素设置好的值。庆幸的是，class 和 style attribute 会稍微智能一些，两边的值会被合并起来。 非 Prop 的 Attribute 通过 $attrs 来访问。 如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。 prop的“伪\"双向绑定 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。也就是说，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值，但是，你不应该在一个子组件内部改变父组件传递的 prop。 子组件修改父组件的 prop，需要在父组件中监听一个事件，并根据需要更新一个本地的数据： // 父组件：监听一个事件，用于更新本地的数据 // 子组件：触发父组件的监听事件，传递更新的值 this.$emit('update:title', newTitle) 为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符： // 父组件：.sync修饰符，相当于添加了一个 update:title 监听事件 自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。因为，有的情况下，你仍然需要对普通 DOM 元素进行底层操作。如：当页面加载时，该元素将获得焦点。 注册全局指令： Vue.directive('focus', { bind: function (el, binding, vnode) {}, inserted: function (el, binding, vnode) { el.focus() }, update: function (el, binding, vnode, oldVnode) {}, componentUpdated: function (el, binding, vnode, oldVnode) {}, unbind: function (el, binding, vnode) {} }) 注册局部指令，在组件中定义 directives 选项： directives: { focus: { inserted: function (el, binding, vnode) { el.focus() } } } 然后你可以在模板中任何元素上使用新的 v-focus property： 钩子函数 一个指令定义对象可以提供如下几个钩子函数（均为可选）： bind： 只调用一次，指令第一次绑定到元素时调用； inserted： 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)； update： 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。 componentUpdated： 指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind： 只调用一次，指令与元素解绑时调用。 钩子函数的参数 指令钩子函数会被传入以下参数： el： 指令所绑定的元素，可以用来直接操作 DOM。除了 el 之外，其它参数都应该是只读的； binding： 一个对象，包含以下 property： name：指令名，不包括 v- 前缀； value：指令绑定的值； oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用； expression：指令绑定的字符串形式的指令表达式； arg：传给指令的参数。如 v-my-directive:foo 中，参数为 \"foo\"； modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：当前虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 函数简写 如果只想在 bind 和 update 时触发相同行为，而不关心其它的钩子，可以这样写： Vue.directive('my-directive', function (el, binding) { el.style.backgroundColor = binding.value }) 过滤器 自定义过滤器可被用于一些常见的文本格式化。比如：双花括号插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： {{ message | capitalize }} 全局定义过滤器： Vue.filter('capitalize', function (value) { return value ? value.replace(/^\\w/, a => a.toUpperCase()) : '' }) 局部定义过滤器，在组件的选项中定义 filters 选项： filters: { capitalize: function (value) { return value ? value.replace(/^\\w/, a => a.toUpperCase()) : '' } } 过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。同时，它可以接收参数： {{ message | filterA('arg1', arg2) }} 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 'arg1' 作为第二个参数，表达式 arg2 的值作为第三个参数。 Vue API Vue.use( plugin ) 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。 该方法需要在调用 new Vue() 之前被调用。 当 install 方法被同一个插件多次调用，插件将只会被安装一次。 provide / inject 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是：一个字符串数组，或一个对象。对象的 key 是本地的绑定名，value 可以是父组件中定义的 provide 中的 key，也可以是一个对象，包含 from、default 两个 property。 // 父组件 export default { provide () { return { provideInst: this } }, } // 子组件 export default { inject: { aliasInst: { from: 'provideInst', default: () => ({}) } }, } model 允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。 默认情况下： 相当于： { name = val }\" > 如果我们在子组件 my-component 加入： export default { model: { prop: 'testValue', event: 'change' }, } 那么： { name = val }\" > v-on 绑定事件监听器。事件类型由参数指定，表达式可以是一个方法的名字或一个 Javascript 内联语句，还可以加对应修饰符（也可以省略）。 用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。 在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 $event property ： v-on:click=\"handle('ok', $event)\"。 从 2.4.0 开始，v-on 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰符的。 myEventObject: { click () => {}, change () => {}, myEvent () => {} } v-bind 动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。在绑定 prop 时，prop 必须在子组件中声明。 可以用修饰符指定不同的绑定类型。 .prop ： 作为一个 DOM property 绑定而不是作为 attribute 绑定，即不会传递到子组件的 $attrs； .camel： (2.1.0+) 将 kebab-case attribute 名转换为 camelCase； .sync： (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器； 没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。 key Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。 key 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。 ref ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。 当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。 常见问题 数据响应问题 必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值； Vue 不能检测对象的 property 的添加或移除： 由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。 对于已经创建的实例，可以使用 Vue.set(object, propertyName, value) 或 vm.$set 实例方法将 property 转换为响应式 。 Vue 不能检测数组的某些变化： 利用索引直接设置一个数组项时、修改数组的长度。 同样，可以使用 Vue.set 或 vm.$set 来转换。 另外，以下数组的变更方法会触发视图更新：push()、 pop()、 shift()、 unshift()、 splice()、 sort()、 reverse()。 异步更新问题 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么。比如： this.visible = true const height = document.querySelector('#MyComponent').clientHeight 这种情况下，document.querySelector('#MyComponent') 很可能会报错，因为 this.visible = true 修改后，DOM 的更新是一个异步操作，也就是这个时候，DOM 是还不存在的。 为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。 this.visible = true let height = null this.$nextTick(() => { height = document.querySelector('#MyComponent').clientHeight }) 为什么 data 必须是一个函数？ 因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。 为什么不推荐 v-for 与 v-if 一同使用？ 当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。 {{ user.name }} 假设 users 有100个子项，而user.isActive 的子项只有一个。实际执行中， li 将被循环100次，再通过 v-if 判断，过滤不符合条件的99个。从性能角度来看，这不太友好。 推荐做法，将 users 替换为一个计算属性，让其返回过滤后的列表： computed: { activeUsers () => this.users.filter(u => u.isActive) } {{ user.name }} this作用域问题 避免在 setTimeout、setInterval 内使用 this。因为，内部的 this 指向的不是 Vue 实例。 不要在选项 property 或回调上使用箭头函数。 created: () => console.log(this.a) vm.$watch('a', newValue => this.myMethod()) 因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 Uncaught TypeError: Cannot read property of undefined 或 Uncaught TypeError: this.myMethod is not a function 之类的错误。 computed、watch、methods的区别 计算属性基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的一个新值，这个新值只会根据所依赖的值的变化而变化，简言之：这个属性依赖其他属性，由其他属性计算而来的。 同样，我们可以将一个计算属性定义为一个方法，在需要引用计算属性的地方直接调用该方法。两种方式的最终结果确实是完全相同的。不同的是计算属性是基于它们的响应式依赖进行缓存的。也就是说，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。相比之下，多处引用方法，每次都会再执行函数。 侦听属性监听 Vue 实例上的属性变化，或某些特定数据的变化，然后执行某些具体的业务逻辑操作。当属性变化时，回调函数自动调用，在函数内部进行计算。其可以监听的数据来源：data，props，computed 内的数据。 虽然计算属性在大多数情况下更合适，但有时也需要自定义的侦听属性。比如：当需要在数据变化时执行异步或开销较大的操作时、一个数据改变影响多个数据。 注意： 组件初始化时，如果 watch 对象的选项 immediate 值为 true，则该 watch 计算会先于 computed 计算，其执行顺序：beforeCreate -> watch -> created -> beforeMount -> computed（如果计算的属性未使用，则不会触发） -> mounted。 Vue 组件有哪些通信方式？ 8 种常规的 Vue 组件通信方案： 通过 props 传递。 通过 $emit 触发自定义事件。 使用 ref。 $parent 或$root。 $attrs 与 $listeners：逐级向下传属性 $attrs 和 $listeners。 Provide 与 Inject：在祖先组件定义 provide 属性，返回传递的值；在后代组件通过inject接收组件传递过来的值。 Vuex：共享数据中心。 EventBus（适用兄弟组件传值）：创建一个中央事件总线 EventBus，兄弟组件通过 $emit 触发自定义事件，另一个兄弟组件通过 $on 监听自定义事件。 // Bus.js class Bus { constructor() { this.callbacks = {}; } $on(name, fn) { this.callbacks[name] = this.callbacks[name] || []; this.callbacks[name].push(fn); } $emit(name, args) { if (this.callbacks[name]) { this.callbacks[name].forEach((cb) => cb(args)); } } } // main.js Vue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上 // 另一种方式 Vue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能 this.$bus.$emit('foo') this.$bus.$on('foo', this.handle) 参考资料 Vue.js教程 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-10-28 21:54:41 "},"frontend/05-重读React教程.html":{"url":"frontend/05-重读React教程.html","title":"重读React教程","keywords":"","body":"重读React教程 使用 React 已经一年多了，这次重读了一篇 React 的文档，将一些主要概念和疑问做了一个整理。本文内容主要来自 React 文档，还有一些网上查询的资料，以及自己的一些使用经验和理解。由于篇幅过长，拆分成 重读React教程 和 你必须知道的React问题 两篇。 React是什么？ React 是 Facebook 推出一个用于构建用户界面的 JavaScript 库。 它起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。 React 负责解决其它 Javascript 框架所面对的一大常见难题，即对大规模数据集的处理。React 使用虚拟 DOM 和 Diff 算法，在数据发生变更时，只对 DOM 中的有差异部分进行重新渲染，使 React 得以实现远超其它框架的速度表现。 React 使创建交互式 UI 变得轻而易举。它可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。这点顺应了 Web 开发组件化的趋势。 React 不是 MVVM 框架。很多人也认为它不是纯粹的 MVC 框架，只是 MVC 中的 V （View，视图），一个以状态驱动视图的单向数据流的库。 React 特点： 声明式设计：以声明式编写 UI，可以让你的代码更加可靠，且方便调试； 高效：React 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互； 灵活：React 可以与已知的库或框架很好地配合； JSX：JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它； 组件：通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中； 单向响应的数据流： React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 React基本原理 作为一个构建用户界面的库，React 的核心始终围绕着更新这一个重要的目标，将更新和极致的用户体验结合起来是 React 团队一直在努力的事情。 在 Web 开发中，我们总需要将变化的数据实时反应到 UI 上，这时就需要对 DOM 进行操作。而复杂或频繁的DOM 操作通常是性能瓶颈产生的原因（如何进行高性能的复杂 DOM 操作通常是衡量一个前端开发人员技能的重要指标）。 为此，React 引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用 Javascript 实现了一套 DOM API。在React 开发中，所有的 DOM 操作都是通过虚拟 DOM 进行，每当数据变化时，React 都会重新构建整个虚拟 DOM 树，再将当前整个虚拟 DOM 树和上一次的虚拟 DOM 树进行对比，得到虚拟 DOM 结构的区别，然后仅仅将需要变化的部分进行实际的浏览器 DOM 更新。 尽管每一次都需要构造完整的虚拟 DOM 树，但是因为虚拟 DOM 是内存数据，性能是极高的，而对实际 DOM 进行操作的仅仅是 Diff 部分，因而能达到提高性能的目的。 React 还优化了批处理虚拟 DOM 的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并。如：连续先将节点内容从 A 变成 B，然后又从 B 变成 A，React 会认为 DOM 不发生任何变化。 这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的 DOM 元素，而只需要关心在任意一个数据状态下，整个界面是如何 Render 的。 简而言之：React 将浏览器中的 DOM 抽象成一个 Javascript 对象（虚拟 DOM）。React 所有的表层操作实际上是在操作虚拟 DOM，再经过 Diff 算法计算出当前虚拟 DOM 与上一次的虚拟 DOM 的差异，然后将差异进行实际的 DOM 操作更新页面。 React的几个重要概念 React 的核心思想是封装组件。 各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。基于这种方式的一个直观感受就是我们不再需要不厌其烦地来回查找某个 DOM元素，然后操作 DOM 去更改 UI。 React 的几个重要概念： 虚拟DOM 虚拟 DOM 是一种编程概念： UI 以一种理想化的，或者说“虚拟的”表现形式保存在内存中，并通过如 ReactDOM 等类库使之与“真实的” DOM 同步。 React 的虚拟 DOM 是由 Javascript 类库基于浏览器 API 来实现的，其本质是一个由浏览器 DOM 转换而成 Javascript 对象。 这是一套独立于浏览器的 DOM 系统，兼顾了性能和跨浏览器的兼容性。 当浏览器载入 HTML 文档并渲染用户界面时，构成 HTML 文档的元素就是 DOM（文档对象模型）。Javascript 通过浏览器 API 操作 DOM。但是，这些操作是非常低效，频繁使用 JS 操作 DOM 元素可能会变得复杂而又耗时。 React 的初衷就是帮助用户更新浏览器的 DOM，让我们不再需要关心 DOM 的操作和复杂单页面应用的性能。React 实现虚拟 DOM 后，我们不需要和 DOM API 打交道，取而代之的是虚拟 DOM，React 会通过 DOM API 为用户尽可能高效地渲染虚拟 DOM。 之所以引入虚拟DOM： 一方面是性能的考虑，访问虚拟 DOM 要比访问 DOM API 更高效，并且还可以采用 Diff 算法进一步优化；更重要的一方面是提供一种一致的开发方式来开发服务端应用、Web 应用和手机端应用。 组件 React 应用都是构建在组件之上。 所谓组件，即封装起来的具有独立功能的 UI 部件。React 推荐以组件的方式去重新思考 UI 构成，将 UI 上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体 UI 的构建。 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素。 React 认为一个组件应该具有如下特征： 可组合： 一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。通过这个特性，一个复杂的 UI 可以拆分成多个简单的 UI 组件； 可重用： 每个组件都是具有独立功能的，它可以被使用在多个 UI 场景； 可维护： 每个小的组件仅仅包含自身的逻辑，更容易被理解和维护； Diff算法 Diff 算法全称叫做 Difference 算法，用于计算出两个虚拟 DOM 的差异，实质上是两个 Javascript 对象的对比。这是 React 中开销最大的地方，也是 React 性能优化的重点。 在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。 在算法领域中，两棵树的转换目前最优的算法复杂度为 O(n3) ，n 为节点数量。 这意味着当树上有 1000 个元素时，需要1000 * 1000 * 1000 = 10亿 次比较，显然远远不够高效。 将两颗树中所有的节点一一对比需要 O(n²) 的复杂度，在对比过程中发现旧节点在新的树中未找到，那么就需要把旧节点删除，删除一棵树的一个节点（遍历找到一个合适的节点，存放被删除节点的子节点）的时间复杂度为 O(n)，同理添加新节点的复杂度也是 O(n)，合起来 Diff 两个树的复杂度就是 O(n³)。 React 在基于以下两个假设的基础上, 提出了一套复杂度为 O(n) 的启发式算法： 不同类型（即标签名、组件名）的元素会产生不同的树； 通过设置 key 属性来标识一组同级子元素在渲染前后是否保持不变。 在实践中, 以上两个假设在绝大多数场景下都成立。 当对比两棵树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。 Diff 算法描述： 不同类型的元素/组件： 当元素的标签或组件名发生变化, 直接卸载并替换以此元素作为根节点的整个子树。 同一类型的元素： 当元素的标签相同时，React 保留此 DOM 节点，仅对比和更新有改变的属性（如：className、title等），然后递归对比其子节点。对于 style 属性，React 会继续深入对比，仅更新有改变的属性（如：color、fontSize等）。 同一类型的组件： 当组件的 props 更新时，组件实例保持不变，React 调用组件的生命周期方法，并执行 render() 方法。Diff 算法会递归比对新旧 render() 执行的结果。 对子节点的递归： 默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个变化。 当一组同级子节点（列表）的末尾添加了新的子节点时，上述 Diff 算法的开销较小。但当新元素被插入到列表开头时，Diff 算法只能按顺序依次比对并重建从新元素开始的后续所有子节点，造成极大的开销浪费。 解决方案是为一组列表项添加 key 属性。Diff 对同一层级的子节点进行处理时，会根据 key 进行简要的复用。两棵树中存在相同 key 的节点时，只会移动节点。 Key 应该具有稳定，可预测，以及列表内唯一的特质。同时，应该避免使用数组索引值作为 key，因为当插入或删除元素后，之后的元素和索引值的对应关系都会发生错乱，导致错误的比对结果。也应该避免使用不稳定的 key （如：随机数），因为每次渲染都会发生改变，从而导致列表项被不必要地重建。 单向数据流 单向数据流：即规范了数据的流向——数据只能由父组件向子组件进行传递，反过来则不行。 单向数据绑定是 React 推崇的一种应用架构的方式：在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。组件可以将自身的 state 向下传递，作为其子组件的 props 属性，并任何组件都是彼此独立地管理其内部 state，每个组件的 state 只能影响组件树下方的组件。 单向数据流（从上到下）与单一数据源这两个原则，限定了 React 中多个组件需要反映相同的变化数据，需要进行状态提升，即将共享状态（变化数据）提升到他们最近的共同父组件中。 也就是说，如果一个组件的状态变化，需要更新另一个组件，先将该状态移到这两个组件最近的共同父组件中。组件状态变更，通过发消息的方式向上传递，触发父组件状态的变更（详见下方逆向通信），而父组件状态的变更后，React 会自动更新其所有子组件的状态，并重新渲染。 单向数据绑定方式比双向绑定方式需要编写更多的代码，但带来的好处是：排查和隔离 bug 所需的工作量将会变少。因为，存在于组件中的任何 state，仅有组件自己能够修改它。 JSX JSX 是一个 JavaScript 的语法扩展，是 React 提出的一种语法。 JSX 类似于模板语言，但它具有 JavaScript 的全部能力。JSX 最终会被编译为 React.createElement() 函数调用，返回称为 “React 元素” 的普通 JavaScript 对象。 JSX 能很好地描述 UI 应该呈现出它应有交互的本质形式（即，书写 JS 语言的文件允许书写 HTML 语言，可以更直观了解最终在浏览器呈现的 UI）。 function formatName(user) { return user.firstName + ' ' + user.lastName } const user = { firstName: 'Harper', lastName: 'Perez' } const element = Hello, {formatName(user)}! ReactDOM.render(element, document.getElementById('root')) JSX 有以下特点： 可以嵌套表达式 {}； 本身就是一个表达式对象； 通过使用 “” 双引号或者 {} 来作为属性； 必须明确声明字对象，没有子对象，应该使用自闭和标签； 可以防止注入攻击； 可以使用 babel 将 JSX 转换为 Javascript 对象； React 并不强制要求使用 JSX。当你不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。 每个 JSX 元素只是调用 React.createElement(component, props, ...children) 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。 组件状态：props和state React 把用户界面当作简单的状态机。把用户界面想像成拥有不同状态，之后渲染这些状态，这样可以轻松让用户界面和数据保持一致。 React 有两种管理状态的数据模型：props 和 state。 props React 定义组件时，会将组件所有接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”，即 props 是从父组件向下传递给子组件的数据。 React 有一条规则：props 是只读的，组件不应以任务方式修改自身的 props。所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。 state state 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。 state 包含了组件中用于渲染且随时可能发生变化的数据，它由用户自定义，是一个普通 JavaScript 对象。除了拥有并设置它的组件，其他组件都无法访问。这就是为什么称 state 为私有的、局部的或封装的。 组件可以选择把它的 state 作为 props 向下传递到它的子组件中。 这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。 如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。 正确地使用 state： 构造函数是唯一可以给 state 赋值的地方； 不要直接修改 state，而是应该使用 setState()； state 的更新可能是异步的：出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用； state 的更新会被合并（浅合并）：当你调用 setState() 的时候，React 会把你提供的对象合并（浅合并）到当前的 state； 逆向通信：子组件向父组件通信 React 中的数据是采用 \"自上而下\"的单向流动，即，父组件向子组件传递数据。现在，我们尝试组件的逆向通信：子组件更新父组件的 state。 前面我们说过，父组件是通过 props 将自身的 state 传递给子组件的，而 props 是只读的，state 只能由拥有并设置它的组件访问。所以，逆向通信实现思路是：让父组件向子组件传递一个能够触发父组件 state 改变的函数，子组件调用该函数通知父组件更新 state。 function ChildComponent(props) { return <> Hello, {props.name}! props.updateStateName('Lizh')}>点击修改 } function ParentComponent() { const [state, setState] = useState({ name: 'World'}) const updateStateName = value => { setState({ name: value }) } return updateStateName(value)} /> } props和state的区别是什么？ props 和 state 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的一个重要的不同点就是：props 是父组件传递给子组件的（类似于调用函数时，传入的的形参），而 state 是在组件内被组件自己管理的（类似于定义函数时，内部声明的变量）。组件不能修改 props，但可以调用 setState() 方法修改 state。 类组件 类组件：使用 ES6 的 class 来定义的组件。类组件继承 React.Component 并且创建 render 函数返回 react 元素。 class MyComponent extends React.Component { render() { return Hello, {this.props.name} } } state 构造函数是唯一可以给 state 赋值的地方，并且允许接收 props 参数（不推荐，除非后续的渲染不依赖于 props 的更新）。 class MyComponent extends React.Component { constructor(props) { super(props) this.state = { name: props.name } } // 或者 // state = { date: new Date() } ... } setState setState() 将对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式。 setState() 应该视为请求，而不是立即更新执行的命令，因为它是异步的。React 并不会保证 state 的变更会立即生效。 setState(updater, [callback]) 第一个参数除了接受函数外，还可以接受对象类型。传入函数，函数中接收的 state 和 props 都保证为最新，函数的返回值会与 state 进行浅合并；传入对象，将传入的对象浅层合并到新的 state 中。 第二个参数为可选的回调函数，它将在 setState 完成合并并重新渲染组件后执行。通常，我们建议使用 componentDidUpdate() 来代替此方式。 this.setState({ name: 'lizh' }) // 第一个参数可以传函数。用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数 this.setState((state, props) => ({ name: state.name + '01' }), () => { console.log('回调函数') }) forceUpdate 默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。如果 render() 方法依赖于其他数据，则可以调用 forceUpdate() 强制让组件重新渲染。 调用 forceUpdate() 将致使组件调用 render()方法，此操作会跳过该组件的 shouldComponentUpdate()。但其子组件会触发正常的生命周期方法，包括 shouldComponentUpdate()方法。 生命周期 setState、forceUpdate 是 React 更新组件的主动调用的方法，而生命周期方法是在组件渲染的不同阶段自动触发的。 常用的生命周期方法如下： render()：class 组件中唯一必须实现的方法。该方法返回以下值之一：一个React 元素、一个包含多个 React 元素的数组或 fragments、字符串或数值类型、布尔类型或 null 或一个 Portals 实例（将子节点渲染到存在于父组件以外的 DOM 节点）。 constructor()：构造函数，在组件挂载之前调用，仅用于：初始化内部 state、为事件处理函数绑定实例。 componentDidMount()： 在组件挂载后（插入 DOM 树中）立即调用。 componentWillUnmount()：在组件卸载及销毁之前直接调用。 shouldComponentUpdate()：在 props 或 state 发生变化后，渲染执行之前被调用。 根据返回值的布尔值，判断是否重新渲染当前 state 或 props 的更改。默认是每次发生变化都会重新渲染组件；如果返回 false，则跳过更新。 请注意：返回 false 并不会阻止子组件在 state 更改时重新渲染；首次渲染或使用 forceUpdate() 时不会调用该方法。 componentDidUpdate()：在更新后会被立即调用。首次渲染不会执行此方法。 componentDidUpdate(prevProps, prevState, snapshot) 第三个参数是生命周期 getSnapshotBeforeUpdate() 方法的返回值；如果没有该生命周期，此参数为 undefined。 请注意：如果 shouldComponentUpdate() 返回值为 false，则不会调用该方法。 static getDerivedStateFromProps()：在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 请注意：此方法无权访问组件实例；不管原因是什么，都会在每次渲染前触发此方法。 getSnapshotBeforeUpdate()：最近一次渲染输出（提交到 DOM 节点）之前调用。 挂载时，生命周期调用顺序：constructor() -> static getDerivedStateFromProps() -> render() -> componentDidMount()。 更新时，生命周期调用顺序：static getDerivedStateFromProps() -> shouldComponentUpdate() -> render() -> getSnapshotBeforeUpdate() -> componentDidUpdate()。 函数组件 函数组件：编写 JavaScript 函数来定义组件。函数组件是一个纯函数，它接收一个 props 对象返回一个 react 元素。 function MyComponent(props) { return Hello, {props.name} } 在 Hook 出现之前，react 中的函数组件通常只负责 UI 的渲染，没有自身的状态和生命周期。可以说，在 Hook 之前的函数组件和类组件最大的区别是：状态和生命周期的有无。 什么是Hook？ Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。它是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。 React 有一些内置的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。 Hook 使用规则： 只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用； 只能在 React 的函数组件中调用 Hook（或者自定义的 Hook 中）。不要在其他 JavaScript 函数中调用。 Hook 在 class 内部是不起作用的。但你可以使用它们来取代 class 。 useState 调用 useState() 会给组件添加一些内部状态。 const [state, setState] = useState(initialState) const [state, setState] = useState(() => { let initialState = null // do something return initialState }) initialState 可以是对象，可以是数字或字符串，也可以不传，还可以传入一个函数，在函数中计算并返回初始的 state。initialState 只有在第一次渲染时会被用到，后续渲染时会被忽略。 useState() 返回一个有两个值的数组：当前状态和一个让你更新状态的函数。在这里，我们定义状态名是 state，更新函数的名称是 setState，这两个变量是数组解构的赋值，我们可以给他们定义任何名称。 setState(newState) setState(prevState => { // do something return prevState }) 更新函数类似 class 组件的 this.setState，但是它是用新的 state 替换旧的 state，而不是将两者进行合并。它的参数除了接收具体的值，还可以接收一个函数。该函数将接收先前的 state，并返回一个更新后的值。 如果更新函数接收的值或接收的函数的返回值与当前 state 完全相同，React 将跳过子组件的渲染及 effect 的执行。（React 使用 Object.is() 比较算法来比较 state。） 需要注意的是，React 可能仍需要在跳过渲染前执行 render 方法。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。 一个组件中可以使用多个 useState。 useEffect 你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。 useEffect 可以让你在函数组件中执行副作用操作。它跟类组件中的 componentDidMount、 componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API。 // 等同于 componentDidMount 和 componentDidUpdate useEffect(() => { // do something }) 默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。 然而，在某些场景下可能不需要每次渲染都调用副作用函数。要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。 useEffect( () => { const subscription = props.source.subscribe(); }, [props.source] ) 此时，只有当 props.source 改变后才会调用副作用函数。如果数组中有多个元素，那么只要有一个元素发生变化，React 就会执行 effect。 如果想只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。 注：与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。 副作用函数还可以通过返回一个函数来指定如何“清除”副作用。 useEffect(() => { // 等同于 componentWillUnmount return function () { // do something } }) 一个组件中多次使用 useEffect 。 useReducer useState 的替代方案。它接收一个形如 (state, action) => newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。dispatch 永远不会变，因此读取它的组件不需要重新渲染。 const initialState = {count: 0} function init(iState) { return {count: iState} } function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1} case 'decrement': return {count: state.count - 1} default: throw new Error() } } function Counter() { const [state, dispatch] = useReducer(reducer, initialState) // 或者 // const [state, dispatch] = useReducer(reducer, initialState, init) return <> Count: {state.count} dispatch({type: 'decrement'})}>- dispatch({type: 'increment'})}>+ } useCallback 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的缓存版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如： shouldComponentUpdate）的子组件时，它将非常有用。 useCallback 可以将组件的某些处理函数挂载到 React 底层原型链上，并返回该处理函数的引用，当组件每次即将要重新渲染时，确保 props 中该处理函数为同一函数（因为是同一对象引用），跳过本次无意义的重新渲染，达到提高组件性能的目的。 const memoizedCallback = useCallback( () => { if (name === 'World') { console.log(`callback1：World`) return } console.log(`callback2：${name}`) }, [name] ) useMemo 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算缓存值。这种优化有助于避免在每次渲染时都进行高开销的计算。 const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]); 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。 useLayoutEffect 其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用副作用。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 自定义Hook 通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。 import { useState, useEffect } from 'react'; function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() => { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () => { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); } }) return isOnline } function FriendStatus(props) { const isOnline = useFriendStatus(props.friend.id); if (isOnline === null) { return 'Loading...'; } return isOnline ? 'Online' : 'Offline'; } Hook 函数与 JavaScript 函数的区别：一、自定义 Hook 函数可以使用其他 Hook 函数，实现类似生命周期的管理；二、React 以某种方式跟踪 Hook 函数调用，即 React 能够将 Hook 函数调用（及其输入和输出）与特定的 React 元素相关联。 类组件和函数组件的区别 了解了类组件和函数组件，你可能马上会有疑问了：我应该用类组件还是函数组件呢？这两者有什么不同？ 两者的区别 实现思想： 类组件根基是向对象编程；函数组件是函数式编程。 复用模式： 类组件可以实现继承，函数组件缺少继承能力。不过，这不重要，因为 React 的思想：组合优于继承（继承的灵活性差，细节屏蔽过多）。 语法上： 函数组件是一个纯函数，它接收一个 props 对象返回一个 React 元素。而类组件是继承 React.Component 并且创建 render 函数返回 react 元素。 状态管理： 类组件通过 setState 管理组件状态；而函数组件呢？它是一个纯函数，是没有 state 的，通常我们也称它为无状态组件。 生命周期： 类组件所有的生命周期钩子都来自于继承的 React.Component；而函数组件是没有生命周期钩子的。 未来趋势： 基于 Hook 的加持，React 社区主推函数组件。 注意：react@16.8 版本添加了 hooks ，可以在函数组件中使用 useState 钩子去管理 state，使用 useEffect 钩子去使用生命周期函数。 本质的差异 两者本质的差异是：心智模式（心智模型、心理模型）， 函数式组件捕获了渲染时所使用的值。 Mental Model：Function components capture the rendered values. 关于这一点，How Are Function Components Different from Classes? 文章讲的非常详细。 个人对此的理解是：类似于 JavaScript 中函数调用时，参数传值和传址的区别。 以下是在 React 中的简单示例： 组件定义时，props 的属性 propA 的默认值是 'word'，并在组件中设置一个定时器，3s 后打印 propA，然后在渲染后，定时器触发前，父组件更新 propA 的值为 'lizhao'。 function MyComponents (props) { useEffect(() => { setTimeout(() => { alert(props.propA) }) }, []) ... } class MyComponents extends React.Component { componentDidMount () { setTimeout(() => { alert(this.props.propA) }) } ... } 那么，定时器触发时，alert 打印出来的值是 'word'，还是 'lizhao'? 代码执行结果：函数组件打印出来的是 'word'，而类组件打印出来的是 'lizhao'。 我们知道，props 是不能被组件以任何方式修改的，组件渲染时接收的是什么值，props 一直（组件当前状态期间）会是这个值。这是也是函数组件的表现，它捕获了渲染时所使用的值。但是，对于类组件呢，它虽然不能修改 props，但它在定时器中访问 propA 属性的方式是 this.props.propA，this 是指向组件实例的，this 是可变的。当组件重新渲染后，this 指向了新的实例的， 定时器触发时， this.props.propA 也指向了新实例的 propA。 所以说，函数组件捕获渲染时的值，而类组件捕获最新实例的值。这在大部分场景区别不大，但两者的思维模式有本质区别。 至于，你最终是希望捕获渲染时的值，还是捕获最新实例的值，决定于你的业务需求。不过，你无需担心选用类组件或函数组件不符合你的期待。类组件可以实现捕获渲染时的值，函数组件也可以实现捕获最新实例的值（使用 useRef() 实现，详见 How Are Function Components Different from Classes?），两者只是关注的方向不同。 为什么会在 React 中加入 Hook？ Hook 解决了类组件中一些问题： 在组件之间复用状态逻辑很难：使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。 复杂组件变得难以理解：将逻辑完全不相关的代码组合在一个方法，这样容易产生 bug，并且导致逻辑不一致。Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。 难以理解的 class：JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。 class 给目前的工具带来了一些问题：class 不能很好的压缩，并且会使热重载出现不稳定的情况。 React 准备让 Hook 覆盖所有 class 组件的使用场景，但是React也将继续为 class 组件提供支持。 性能对比 你可能听过其中一个好处是性能更好了，但是哪个是更好的？很多判断标准都存在缺陷。 一般来说，我们可以认为 Hook 的设计在某些方面更加高效： Hook 避免了 class 需要的额外开支，像是创建类实例和在构造函数中绑定事件处理器的成本。 符合语言习惯的代码在使用 Hook 时不需要很深的组件树嵌套。这个现象在使用高阶组件、render props、和 context 的代码库中非常普遍。组件树小了，React 的工作量也随之减少。 但是，在现代浏览器中，闭包和类的原始性能只有在极端场景下才会有明显的差别。性能主要取决于代码做的事情，而不是取决于你是使用函数或者类。实际上，两者的性能尽管在不同优化策略下有所不同，但差异不大。 两者的优劣性 类组件 this 的模糊性； 业务逻辑散落在生命周期中 类组件缺乏标准的拆分方式。 函数组件 基于函数式编程的优点（输入输出恒定，无副作用等），函数组件更纯粹、简单、易测试； 闭包捕获的值优于 this 的模糊性，捕获的值永远是确定且安全的； 更细腻的逻辑组织和复用，更好的作用于时间切片与并发模式； 由于函数组件的执行从来都是自顶向下，依赖于dom diff算法不至于频繁渲染。 事件处理 由于 fiber（负责调用组件生命周期方法，进行 Diff 运算等） 机制的特点，生成一个 fiber 节点时，它对应的 DOM 节点有可能还未挂载，onClick 这样的事件处理函数作为 fiber 节点的 prop，也就不能直接被绑定到真实的 DOM 节点上。 为此，React提供了一种 “顶层注册，事件收集，统一触发” 的事件机制。这套事件机制被称之为合成事件。 合成事件是 React 基于浏览器的原生事件机制实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等。React 根据 W3C规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口。 React 的合成事件处理和原生事件很相似，但是也有如下不同点： React 事件的命名采用小驼峰式，而不是纯小写。 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。 React 不能通过返回 false 的方式阻止默认行为，必须显式的使用 preventDefault。 如果想要获得原生DOM事件，可以通过 e.nativeEvent 属性获取： const handleClick = e => console.log(e.nativeEvent) const ButtonComponent = 按钮 onClick 事件看似绑定到 DOM 元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听。 这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象。 当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用（先执行原生事件，然后处理 React 事件）。这样做简化了事件处理和回收机制，效率也有很大提升。 如需注册捕获阶段的事件处理函数，则应为事件名添加 Capture。例如，处理捕获阶段的点击事件请使用 onClickCapture，而不是 onClick。 受控组件和非受控组件 在一个受控组件中，表单数据是由 React 组件来管理的，而在非受控组件，表单数据将交由 DOM 节点来处理。 受控组件 如果一个表单元素的值是由 React 控制，就其称为受控组件。当用户将数据输入到受控组件时，触发组件的事件处理器修改状态。 class NameForm extends React.Component { constructor(props) { super(props) this.state = { value: '' } } handleChange(event) { this.setState({value: event.target.value}) } render() { return this.handleChange(e)} /> } } 非受控组件 一个非受控组件，就像是运行在 React 体系之外的表单元素，它的值是存在 DOM 中。当用户将数据输入到表单字段时，React 不需要做任何事情（不需要为每个状态更新都编写数据处理函数）就可以映射更新后的信息。 你可以使用 Refs 来从 DOM 节点中获取表单数据。 class NameForm extends React.Component { constructor(props) { super(props) this.inputRef = React.createRef() } handleSubmit(event) { alert('A name was submitted: ' + this.input.current.value); event.preventDefault(); } render() { return } } Context Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法，即共享那些对于一个组件树而言是“全局”的数据。 类组件：createContext const ThemeContext = React.createContext({ color: 'red' }) class App extends React.Component { render() { return } } function Toolbar() { return } class ThemedButton extends React.Component { static contextType = ThemeContext render() { return Context } } 另外，还有两种方式接收当前的 context 值： export class ThemedButton extends React.Component { render() { return { value => Context } } } export class ThemedButton extends React.Component { render() { return Context } } ThemedButton.contextType = ThemeContext Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。 如果你只是想避免层层传递一些属性，可以考虑在 props 中传一个封装好的组件、或者调整组件的层级。 函数组件：useContext 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 的value prop 决定。 当组件上层最近的 更新时，该 Hook 会触发重渲染，并使用最新传递给 的 value 值。 function ThemedButton () { const theme = useContext(ThemeContext) return Context } Refs 在典型的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。比如：管理焦点、文本选择、媒体播放、触发强制动画、集成第三方 DOM 库、非受控组件取值。 Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。 React 支持一个特殊的、可以附加到任何组件上的 ref 属性。此属性可以是一个由 React.createRef() 函数创建的对象、或者一个 useRef() 勾子返回的对象、或者一个回调函数。 谨慎使用 ref。 在使用 ref 前，不妨先考虑下，是否能采用更合理的状态来控制。 类组件：createRef 使用 React.createRef() 创建 ref 对象，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。 class MyComponent extends React.Component { constructor(props) { super(props) this.myRef = React.createRef() } render() { return } } 通过 ref 的 current 属性访问该节点： const node = this.myRef.current ref 的值根据节点的类型而有所不同： 当 ref 属性用于 HTML 元素时，接收底层 DOM 元素作为其 current 属性； 当 ref 属性用于自定义 class 组件时，接收组件的挂载实例作为其 current 属性。 函数组件：useRef useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。 function MyComponent() { const inputEl = useRef(null) const onButtonClick = () => inputEl.current.focus() return <> Focus the input } 本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。 如果不将 inputEl 传给节点的 ref 属性，则 inputEl.current 的值将是我们传入的初始值。 如果将inputEl 以 形式传入节点，则无论该节点如何改变，React 都会将 inputEl.current 设置为相应的 DOM 节点。 useRef() 的返回对象是一个普通 Javascript 对象。它和自建一个 {current: ...} 对象的唯一区别是，它会在每次渲染时返回同一个 ref 对象。 请记住，ref 对象的 .current 属性变更不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。 回调refs React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。 给 ref 属性传递一个函数，该函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。这也是官方强烈推荐的用法。 这个函数执行的时机为： 组件被挂载后，回调函数被立即执行，回调函数的参数为该组件的具体实例。 组件被卸载或者原有的ref属性本身发生变化时，回调也会被立即执行，此时回调函数参数为null，以确保内存泄露。 class MyComponent extends React.Component { constructor () { buttonEl = null } getButtonRef (inst) { this.buttonEl = inst } render() { return 点击 } } React 将在组件挂载时，会调用 ref 回调函数并传入 DOM 元素，当卸载时调用它并传入 null，而更新时它被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。 回调函数在 componentDidMount 或 componentDidUpdate 前触发，React 会保证 refs 一定是最新的。 转发 refs 到 DOM 组件 组件中，props 的 ref 属性是不会透传下去。这是因为 ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。也就是说，你在子组件中，是无法通过 props.ref 获取父组件传递的 ref 值。 我们可以通过以下两个方法，将组件的 ref 传递（即，转发）给子组件： 方法一： 使用 React.forwardRef。 const MyRefComponent = React.forwardRef((props, ref) => ( 转发 refs 到 DOM 组件 )) class MyApp extends React.Component { ref = React.createRef() render() { return <> console.log(this.ref.current)}>点击 } } 第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref。 也就是说，如果没有 React.forwardRef， MyRefComponent 无法接收 ref，也就无法绑定到其内的节点中。 方法二： 传 ref、key 除外的 props 属性。 上面我们说过，ref、key 被 React 进行了特殊处理，无法透传到子组件，而 props 又是可以传任何值的。那么，我们可以通过定义一个普通的 props 属性来传递 ref 对象。 const MyRefComponent = props => ( 转发 refs 到 DOM 组件 ) class MyApp extends React.Component { ref = React.createRef() render() { return <> console.log(this.ref.current)}>点击 } } 高阶组件 高阶组件（HOC）是 React 中用于复用组件状态和逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。 具体而言，高阶组件是参数为组件，返回值为新组件（可追加一些 props）的函数。 区别： 组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。 请注意，HOC 不应该修改传入的组件，也不应该使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。 // 封装一个自动获取被包裹的组件中某个DOM可以父节点中使用的区域大小 function calcDomSize = dom => {} const AutoCalcSize = WrappedComponent => props => { const innerRef = useRef() const [state, setState] = useState({ width: 0, height: 0 }) useEffect(() => { setState({ width: calcDomSize(innerRef.current).width, height: calcDomSize(innerRef.current).height }) }, []) return } 使用 HOC 的一些约定： 约定：透传被包裹的组件的原有的所有 props； 约定：最大化可组合性。HOC 一般仅接受一个参数，也就是被包裹的组件。而 HOC 通常可以接收多个参数，用来区分不同场景的一些逻辑； 约定：包装显示名称以便轻松调试。 使用 HOC 的一些注意事项： 不要在 render 方法中使用 HOC； 务必复制静态方法； Refs 不会被传递； 相关问题 为什么 Virtual DOM 比原生 DOM 快？ Virtual DOM 对于需要有大量的 DOM 操作时，能够很好的提高效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。 参数资料 React中文文档 How Are Function Components Different from Classes? 【译】React函数组件和类组件的区别 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-02-03 10:52:59 "},"frontend/09-如何理解HTTP响应的状态码.html":{"url":"frontend/09-如何理解HTTP响应的状态码.html","title":"如何理解HTTP响应的状态码","keywords":"","body":"如何理解HTTP响应的状态码 HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。状态代码由 section 10 of RFC 2616定义。响应分为五类： 1xx：信息 2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 一般故障排除提示 当使用Web浏览器测试Web服务器时，在更改服务器后刷新浏览器 检查服务器日志以获取有关服务器如何处理请求的更多详细信息。 例如，网络服务器，如Apache或Nginx的生成两个文件名为access.log和error.log ，可以为相关的信息进行扫描。 请记住：HTTP状态代码定义是由提供请求的应用程序实现的标准的一部分。 这意味着返回的实际状态代码取决于服务器软件如何处理特定错误 – 本指南通常应该指向正确的方向 一些常见的状态码为： 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应只包含状态行和某些可选的响应头信息，并以空行结束。 由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 100（继续）：迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。 服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送Expect: 100-continue作为头部，并在发送正文之前接收100 Continue状态代码。 101 （切换协议）：该代码是响应客户端的 Upgrade标头发送的，并且指示服务器也正在切换的协议。 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如WebSocket）以传送利用此类特性的资源。 102 Processing（WebDAV；RFC 2518）： WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。 103 Early Hints： 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。 2xx （成功） 表示请求已成功被服务器接收、理解、并接受。 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回。 成功的含义取决于HTTP方法： GET：资源已被提取并在消息正文中传输。 HEAD：实体标头位于消息正文中。 POST：描述动作结果的资源在消息体中传输。 TRACE：消息正文包含服务器收到的请求消息 201（已创建）：该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。 202（已接受）：服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。如：需要的资源无法及时创建。 203（非授权信息）（自HTTP / 1.1起）：服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）：服务器成功处理了请求，没有返回任何内容。 205（重置内容）：服务器成功处理了请求，但没有返回任何内容。 但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 （部分内容）：服务器成功处理了部分 GET 请求。实现断点续传或者将一个大文档分解为多个下载段同时下载。如：视频播放时的数据加载请求。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 207 （多状态）：由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 208 (已报告) （WebDAV；RFC 5842）：在 DAV 里面使用: propstat响应元素以避免重复枚举多个绑定的内部成员到同一个集合。 226（IM Used）（RFC 3229）：服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。 3xx （重定向） 表示要完成请求，需要进一步操作。 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。 300（多种选择）：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 （永久移除）：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303（查看其他位置）：对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 （未修改）：表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。 304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 305（使用代理）：被请求的资源必须通过指定的代理才能被访问。 Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306（临时重定向）： 在最新版的规范中，306状态码已经不再被使用。 307（临时重定向）： 请求的资源现在临时从不同的URI 响应请求。 由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 308（永久重定向）：这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。 4xx（客户端错误）表示请求可能出错，妨碍了服务器的处理。 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。 如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。 400（错误请求）：由于明显的客户端错误，服务器不能或不会处理该请求。 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 请求参数有误。比如：传参的数据结构不对 请求格式有误。如：由于浏览器故障，导致请求格式错误 参数数据量太大 无效的请求消息或欺骗性路由请求 与该网站相关联的用户Cookie已损坏。 清除浏览器的缓存和Cookie可以解决此问题 恶意代码的请求由于人为错误手动形成HTTP请求时（例如，使用curl错误） 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。 注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。 402 （要求付费）：此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。 如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。 403（禁止）：服务器已经理解请求，但是拒绝执行它。 与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。 执行访问被禁止。 读访问被禁止。 写访问被禁止。 要求 SSL。 要求 SSL 128。 IP 地址被拒绝。 要求客户端证书。 站点访问被拒绝。 用户数过多。 配置无效。 密码更改。 拒绝访问映射表。 客户端证书被吊销。 拒绝目录列表。 超出客户端访问许可。 客户端证书不受信任或无效。 客户端证书已过期或尚未生效。 在当前的应用程序池中不能执行所请求的 URL。 不能为这个应用程序池中的客户端执行 CGI。 Passport 登录失败。 404（未找到）： 请求失败，请求所希望得到的资源未被在服务器上发现。 没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 资源的链接是否有打字错误？ 用户键入的网址有误吗？ 文件是否存在于服务器上的正确位置？ 资源是否已在服务器上移动或删除？ 服务器配置是否具有正确的文档根位置？ 拥有Web服务器工作进程的用户是否有权限遍历到请求的文件所在的目录？ （提示：目录需要访问读取和执行权限） 访问的资源是否是符号链接？ 如果是，请确保Web服务器配置为遵循符号链接 405（方法禁用）：请求行中指定的请求方法（post、get、put、delete等）不能被用于请求相应的资源。 该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406（（不接受） ）：请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407（（需要代理授权））：与401响应类似，只不过客户端必须在代理服务器上进行身份验证。 代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。 408（（请求超时） ）：请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409（冲突）：由于和被请求的资源的当前状态之间存在冲突，请求无法完成。 这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。如：多个同步更新之间的编辑冲突。 410（已删除）：被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。 这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。 411（需要有效长度）：服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412（前提条件失败）：服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413（请求实体过大）：服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。 此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414（请求的 URI 过长）：请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。 415（不支持的媒体类型） ：对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416（请求范围不符合要求） （RFC 7233）：如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头。 417（未满足期望值）：此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。 418 （I'm a teapot）（RFC 2324）：本操作码是在1998年作为IETF的传统愚人节笑话，在RFC 2324超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。 这个HTTP状态码在某些网站（包括Google.com）与项目（如Node.js、ASP.NET和Go语言）中用作彩蛋。 420（保持冷静）：Twitter Search与TrendsAPI在客户端被限速的情况下返回。 421（错误请求）（RFC 7540）：该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。 422 （无法处理的实体）（WebDAV；RFC 4918 ）：请求格式良好，但由于语义错误而无法遵循。 423 （锁定）（WebDAV；RFC 4918）：正在访问的资源被锁定。 424 （依赖）（WebDAV；RFC 4918）：由于先前的请求失败，所以此次请求失败。 425 （太早了）：服务器不愿意冒着风险去处理可能重播的请求。如：安全验证未完成。 426 （需要升级）（RFC 2817）：服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 428 （需要前提条件） (RFC 6585)：原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。 429 （请求过多） （RFC 6585）：用户在给定的时间内发送了太多请求（“限制请求速率”）。 431 （请求头过大）（RFC 6585）：服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。 444 (不响应)：Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。 450（被Windows家长控制系统阻止）：这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。 451（由于法律原因无法使用）：用户请求非法资源，例如：由政府审查的网页。 5xx（服务器错误） 表示服务器在尝试处理请求时发生内部错误。 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。 500（内部服务器错误）：通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。 这此错误最常见的原因是服务器配置错误（例如，一个畸形.htaccess文件）或缺失的软件包（如试图在没有安装正确PHP执行的PHP文件）。 501（尚未实施）：此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。 502（错误网关）：这意味着服务器的网关或代理服务器，它没有收到来自实际应该履行请求的后端服务器的有效响应。 如果有问题的服务器是逆向代理服务器，例如负载均衡器，则需要检查以下几项： 后端服务器（HTTP请求转发到的）是正常的 正确配置逆向代理，指定适当的后端 后端服务器和逆向代理服务器之间的网络连接是正常的。 如果服务器可以在其他端口上通信，请确保防火墙允许它们之间的流量 如果Web应用程序配置为侦听套接字，请确保套接字存在于正确的位置，并且具有适当的权限 503（服务不可用）： 表示服务器超载或正在维护。 这个错误意味着服务应该在某个时候可用。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。 如果服务器未处于维护状态，则这可以指示服务器没有足够的CPU或内存资源来处理所有传入的请求，或者Web服务器需要配置为允许更多的用户，线程或进程 504（网关超时）：当服务器作为网关，不能及时得到响应时返回此错误代码。 服务器之间的网络连接很差 由于性能不佳，履行请求的后端服务器太慢 网关或代理服务器的超时持续时间太短 505 （HTTP 版本不受支持）：服务器不支持请求中所使用的HTTP协议版本。 506 （协商引起的异常）（RFC 2295）：对请求的透明内容协商导致循环引用。 507 （存储不足）（WebDAV；RFC 4918）：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。 508 （循环检测）（WebDAV；RFC 5842）：服务器在处理请求时陷入死循环。 可代替 208状态码 510 （扩展不足）（RFC 2774）：获取资源所需要的策略并没有被满足，客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。 511 （网络身份验证要求） （RFC 6585）：客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。如：连接WiFi热点时的强制网络门户 参考链接 MDN HTTP 响应代码 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-11-08 19:47:36 "},"frontend/代码规范/":{"url":"frontend/代码规范/","title":"代码规范","keywords":"","body":"Web标准 Web 标准不是某一个标准，而是由 W3C（万维网联盟，World Wide Web Consortium）和其他标准化组织制定的一系列标准的集合。 万维网联盟（World Wide Web Consortium，以下简称W3C）创建于1994年，是Web技术领域最具权威和影响力的国际中立性技术标准机构。它的使命是开发促进万维网发展、确保万维网互操作性的通用协议，从而尽展万维网的全部潜能。 狭义的 Web 标准是指网页设计的 DIV + CSS 化，广义的 Web 标准是指网页设计要符合 W3C 和 ECMA 规范。 网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。 对应的标准也有三方面： 结构化标准语言主要包括 XHTML 和 XML； 表现标准语言主要包括 CSS； 行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。 这些标准大部分由 W3C 起草和发布，也有一些是其他标准组织制订的标准，比如 ECMA（European Computer Manufacturers Association）的 ECMAScript 标准。 结构标准语言 XML（The Extensible Markup Language，可扩展标识语言） 目前推荐遵循的是 W3C 于2000年10月6日发布的 XML1.0。和 HTML 一样，XML 同样来源于 SGML，但 XML 是一种能定义其他语言的语言。XML 最初设计的目的是弥补 HTML 的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。关于 XML 的好处和技术规范细节这里就不多说了，网上有很多资料，也有很多书籍可以参考。　 　 XHTML （The Extensible HyperText Markup Language，可扩展标识语言） 目前推荐遵循的是 W3C 于2000年1月26日推荐 XML1.0。XML 虽然数据转换能力强大，完全可以替代HTML，但面对成千上万已有的站点，直接采用 XML 还为时过早。因此，我们在 HTML4.0 的基础上，用 XML 的规则对其进行扩展，得到了 XHTML。简单的说，建立 XHTML 的目的就是实现 HTML 向 XML 的过渡。　 　 表现标准语言 CSS是Cascading Style Sheets 层叠样式表的缩写。 目前推荐遵循的是 W3C 于1998年5月12日推荐CSS2。W3C 创建 CSS 标准的目的是以 CSS 取代 HTML 表格式布局、帧和其他表现的语言。纯 CSS 布局与结构式 XHTML 相结合能帮助设计师分离外观与结构，使站点的访问及维护更加容易。　 行为标准 DOM （Document Object Mode，文档对象模型） 根据 W3C DOM 规范，DOM 是一种与浏览器，平台，语言的接口，使得你可以访问页面其他的标准组件。简单理解，DOM 解决了Netscaped 的 Javascript 和 Microsoft的 Jscript 之间的冲突，给予 web 设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对像。　 ECMAScript ECMAScript 是 ECMA（European Computer Manufacturers Association）制定的标准脚本语言（JAVAScript）。目前推荐遵循的是 ECMAScript 262。 怎样通过W3C标准的验证？ 图片的 alt=\"\" 属性必须每张图片都加上，而且对齐属性用 CSS 来定义。 每个文档必须加上DTD声明。 !DOCTYPE html PUBLIC \"-//W3C//DTDXHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> 去掉后能通过验证，但有警告：No DOCTYPE found! Checking with default XHTML 1.0 Transitional Document Type。 RSS 的 XML 通过时其中的域名地址必须与检测的地址一致，否则会报错。 标签的链接属性加上 JAVASCRIPT 事件时必须为#空链，不能为 javascript:; 或 javascript:void(null); 同一个页面当中，同名的 ID 会产生冲突。所以以 ID 定义样式的必须改成类引用。 不可省略双引号或单引号。这个是指属性，标准是双引号~，但，单引号也能通过验证。 标签之间不可错位嵌套。 所有的标签都使用小写。 所有的标签中含有的属性必须有值(官方的说法)。 标签必须配对完成，单标签必须以/关闭。 JS 和 CSS 外部引入文件必须加上类型定义。 所有的样式全部写在外部文件。用类名定义。在使用的地方引用。 页面上的一些特殊字符必须用HTML代码来标识.如“&”写成“&“ 不能缺少 title标签 为什么要遵循Web标准？ 因为不同的浏览器可能会解析出不一致的结果，所以开发者经常需要努力地开发多版本，通过 web 标准-----可以显示统一的内容，从而大大提高开发效率。 使用 Web 标准主要有以下几个好处： 让 Web 的发展前景更广阔 内容能被更广泛的设备访问 更容易被搜寻引擎搜索 降低网站流量费用 使网站更易于维护 提高页面浏览速度等 总结来说：让机器能更好的读懂代码，让人（自己、其他开发者）能更好的读懂代码。 另外，遵循 Web 标准，创建易维护的代码是一个项目成功与否的关键。易维护的代码意味着具有如下特性： 阅读性好：如良好的注释和命名规范，有文档； 具有一致性：看起来如同一个人编写； 代码的松耦合、高度模块化：将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码。HTML、CSS、JS 三个层面都要考虑模块化。 什么是高质量代码？ 高质量代码有三要素：可读性、可维护性、可变更性。 代码的可读性： 是指代码让人容易阅读、跟踪和理解的程度。 代码的可维护性： 是指理解、改正、改动、改进代码的难易程度。 代码的可变更性：是指开发完成后，为应对需求的变更或者新需求而进行的代码修改，其所需要付出的代价。 代码的可变更性是建立在代码的可维护性上的，而代码的可维护性又是建立在代码的可读性上。提高代码的可读性可以为代码阅读者节约时间和精力，Debug、扩展功能或是性能优化的前提条件是你要读懂代码。 参考资料 W3C 标准教程 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-11-28 16:54:00 "},"frontend/代码规范/01-HTML.html":{"url":"frontend/代码规范/01-HTML.html","title":"HTML","keywords":"","body":"HTML代码规范 DOCTYPE 声明 DOCTYPE（document type）文档类型的简写，用来说明你用的 XHTML 或者 HTML 是什么版本。 其中 DTD 叫文档类型定义，里面包含了文档的规则，浏览器就根据你定义的 DTD 来解释你页面的标识，并展现出来。要建立符合标准的网页，DOCTYPE 声明是必不可少的关键组成部分；除非你的 XHTML 确定了一个正确的 DOCTYPE，否则你的标识和 css 都不会生效。 XHTML 1.0 提供了三种DTD声明可供选择：有过度的（Transitional）、严格的（strict）、框架的（frameset）。 HTML5 由以下语句声明： 单击 DOCTYPE：文档类型与浏览器模式，了解更多 DOCTYPE 信息。 命名空间namespace xmlns 是 XHTML namespace 的缩写，称为命名空间。它在 XHTML 中是必要的，而在 HTML 中则是可选的。 XHTML 是 HTML 向 XML 过渡的标识语言，它需要符合 XML 文档规则，因此也需要定义名字空间。又因为 XHTML1.0 不能自定义标识，所以它的名字空间都相同，就是\"http://www.w3.org/1999/xhtml\"。 xmlns 属性可以在文档中定义一个或多个可供选择的命名空间，可以放置在文档内任何元素的开始标签中。 xmlns 提供避免元素命名冲突的方法。因为 XML 中的元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。 如果需要使用符合 XML 规范的 XHTML 文档，则应该在文档中的 标签中至少使用一个 xmlns 属性，以指定整个文档所使用的主要命名空间： 如果需要在一个 div 元素中显示一串数学公式，则可以为该 div 元素定义一个数学命名空间。比如这样： x3/x 如果您不希望在每次显示除法公式时都在 div 元素中定义 xmlns 属性，那么更好的办法是在文档的开头处定义具有前缀的命名空间： 然后，您就可以在 div 中使用该前缀了，就像这样： x3/X 常用的命名空间值： HTML：http://www.w3.org/1999/xhtml。 MathML：http://www.w3.org/1998/Math/MathML。MathML 指数学标记语言，是XML语言的一个子集，用来在 Web 网页，甚至部分软件中显示数学公式。简言之，就是使用特殊的类似 HTML 的标记在网页中显示数学公式。 svg：http://www.w3.org/2000/svg。 xllink：http://www.w3.org/1999/xlink。XLink 是一种通过 W3C推荐标准 认证的XML标记语言，用于在 XML 文档中创建超链接，以及提供与这些链接相关联的元数据。 namespace：http://www.w3.org/XML/1998/namespace。？ xmlns：http://www.w3.org/2000/xmlns/。？ 页面语言LANG Lang 属性的取值应该遵循互联网工程任务组–IETF（The Internet Engineering Task Force）制定的关于语言标签的文档。推荐使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值 定义语言编码CHARSET 为了被浏览器正确解释和通过 W3C 代码校验，所有的 HTML 文档都必须声明它们所使用的编码语言。 HTML5 默认的字符编码是 UTF-8。 注意：请尽量统一写成标准的 UTF-8，不要写成 utf8、UTF8。根据 IETF 定义，其编码标准的写法是 UTF-8，而 UTF8、utf8 的写法只是出现在某些编程系统中。 HTML标签闭合 HTML元素共有以下5种： 空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr 原始文本元素：script、style RCDATA元素：textarea、title 外来元素：来自 MathML 命名空间和 SVG 命名空间的元素。 常规元素：其他 HTML 允许的元素都称为常规元素。 为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定： 所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。 空元素标签都不加 “/” 字符 HTML代码风格 HTML 标签名、类名、标签属性和大部分属性值统一用小写； HTML 文本、CDATA、JavaScript、meta 标签某些属性等内容可大小写混合； 不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含； 元素属性值使用双引号语法。 给所有属性赋一个值：XHTML 规定所有属性都必须有一个值，没有值的就重复本身。 图片添加有意义的 alt 属性； 在 form 表单中增加 lable，以增加用户友好度； 元素属性顺序： class id name data-* src, for, type, href, value , max-length, max, min, pattern placeholder, title, alt aria-*, role required, readonly, disabled 特殊字符引用: HTML 中不能使用小于号 “” 特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体。 HTML 特殊符号编码对照表 原代码 显示结果 描述 &lt; 大于号或显示标记 &amp; & 可用于显示其它特殊字符 &quot; “ 引号 &reg; ® 已注册 &copy; © 版权 &trade; ™ 商标 &ensp; 半个空白位 &emsp; 一个空白位 &nbsp; 不断行的空白 代码缩进: 使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 两个空格： 使用两个空格可以一眼就知道是两个空格而不是一个制表符（大部分编辑器默认一个制表符占四个空格的位置）。所以两个空格更容易保持一致性。 能和其他语言统一。比如写 JSON、Python、YAML 时就不用切换习惯了 四个空格：更具有层次感，便于观察代码的逻辑结构。 代码嵌套: 元素嵌套规范，每个块状元素独立一行，内联元素可选。段落元素与标题元素只能嵌套内联元素。减少标签数量，需要尽量避免多余的父节点。 列表中的条目必须总是放置于、或 中，永远不要用一组 或 来表示。 注释规范 单行注释:一般用于简单的描述，如某些状态描述、属性描述等。注释位于要注释代码的上面，单独占一行 模块注释:一般用于描述模块的名称以及模块开始与结束的位置。 HTML模板示例 HTML5 标准模版： HTML5标准模版 移动端 HTML5 模版： PC 端 HTML5 模版： PC端HTML模版 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-05-20 00:45:34 "},"frontend/代码规范/02-CSS.html":{"url":"frontend/代码规范/02-CSS.html","title":"CSS","keywords":"","body":"CSS代码规范 @charset 样式文件必须写上 @charset 规则，并且一定要在样式文件的第一行首个字符位置开始写，编码名用 UTF-8 。 @charset \"UTF-8\"; UTF-8 编码：为世界统一编码，可以兼容全世界的操作系统，不会出现乱码情况。缺点是体积稍大点。 gb2312 编码：国外的浏览者可能会出现乱码，获提示安装语言包。一般，网站提供给全球看的一般用UTF-8，仅仅针对国内的用gb2312 就可以了。体积稍小点，因为程序产生的网页文本使用 ANSI 编码格式，会比 UTF-8 文本编码节省一些体积，访问速度会稍微快一点点。 使用 UTF-8 编码有 2 个要注意： 网页的 meta 必须有这句：。 网页的文本格式必须保存为 UTF-8 格式。 代码风格 class用\"-\"连接，id用驼峰命名。 使用展开格式书写样式，即一个属性一行，每个属性声明末尾都要加分号。 选择器：尽量少用通用选择器 *。 不使用 ID 选择器。 不使用无具体语义定义的标签选择器。 代码缩进：统一使用两个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）。 左括号与类名之间一个空格，冒号与属性值之间一个空格。 逗号分隔的取值，逗号之后一个空格。 为单个css选择器或新申明开启新行。 十六进制数值能用简写的尽量用简写，例如使用 #fff 替代 #ffffff。 不要为 0 指明单位。 去掉小数点前面的 0。 css属性值需要用到引号时，统一使用单引号。 图片引入不需要引号。 属性书写顺序 布局定位属性：display、position、float、clear、visibility、overflow。 自身属性：width、height、margin、padding、border、background。 文本属性：color、font、text-decoration、text-align、vertical-align、white- space、break-word。 其他属性（CSS3）：content、cursor、border-radius、box-shadow、text-shadow、background: linear-gradient …。 body { /* 定位属性 */ display: flex; position: absolute; float: left; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; clear: both; z-index: 100; content: ''; list-style: square; visibility: visible; /* 自身属性 */ width: 100px; height: 100px; border: 10px solid #fff; padding: 10px; margin: 10px; background: #fff; /* 文字样式 */ color: white; font-family: '微软雅黑'; font-size: 14px; font-style: normal; font-weight: bold; font-varient: normal; /* 文本属性 */ text-align: center; vertical-align: middle; text-transform: none; text-indent: 2px; text-decoration: underline; letter-spacing: 10px; word-spacing: 10px; white-space: 10px; text-overflow: ellipsis; } 有浏览器前缀的属性在前，标准属性在后。 .border-radius { -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px; } © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-05-20 00:44:00 "},"frontend/代码规范/03-JS.html":{"url":"frontend/代码规范/03-JS.html","title":"JS","keywords":"","body":"JS代码规范 严格模式 严格模式是采用具有限制性 Javascript 变体的一种方式，从而使代码隐式地脱离 “马虎模式/稀松模式/懒散模式“ （sloppy）模式。 严格模式的改变 通过抛出错误来消除了一些原有静默错误。 修复了一些导致 Javascript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。 禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。 开启严格模式 整个文件开启： 在文件所有语句之前，放一个特定语句 \"use strict\"; 或者 'use strict';。 单个函数开启：在函数体所有语句之前，放一个特定语句 \"use strict\"; 或者 'use strict';。 不要在封闭大括号（{}）内这样做，在这样的上下文中这么做是没有效果的。 严格模式的具体变化 将过失错误转成异常。 无法再意外创建全局变量，比如，a = 1。 引起静默失败的赋值操作抛出异常，包括：对一个对象的只读属性进行赋值、对一个使用 getter 方法读取的属性进行赋值、对禁止扩展的对象添加新属性等。 试图删除不可删除的属性时会抛出异常。 一个对象内的所有属性名在对象内必须唯一。 函数的参数名唯一。 禁止八进制数字语法，非严格模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100，但严格模式禁止这种表示法，整数第一位为 0，将报错。 禁止设置原始值的属性，如，(1).prop = 'a'。 简化变量的使用。 禁止 with 语句。 eval 语句会创建 eval 作用域，不会给上层函数或者全局引入一个新的变量。 禁止删除声明变量。 让 eval 和 arguments 变的简单。 eval、arguments 不能作变量名或赋值。 函数的传参不会随 arguments 对象的值的改变而变化。 不再支持 arguments.callee。 让 JavaScript 更安全。 JavaScript 提供了一些方法（eval、Function等），给用户编写能够被其他用户执行的 Javascript 代码。在浏览器环境下，Javascript 能够获取用户的隐私信息，因此这类 Javascript， 有部分必须在运行前转换，检查是否有访问禁用功能的权限。有些函数如果滥用，会导致运行时的检查带来相当大的性能成本。 一些严格模式的调整，要求用户提交的 Javascript 代码是严格模式，并以特定的方式调用，大大减少了运行时检查的需要。 通过 this 传递给一个函数的值不会被强制转换为一个对象。比如，call、apply、bind 方法的第一个参数是原始值时，不会自动转换为对象。 禁止存取函数的 caller、arguments 属性。 function func() { \"use strict\"; func.caller.name func.arguments } function f1(a, b) { return func(a, b); } f1(1, 2); // Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them fun.caller 指向最后一个调用 fun 的函数，而且 fun.arguments 是最后一个调用时的传参。严格模式下，caller、arguments 是不可存取的。 禁止存取 arguments 的 callee 属性。 function func() { \"use strict\"; arguments.callee } func() // Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them 为未来的 ECMAScript 版本铺平道路。 新增一些保留字：implements、interface、let、package、private、protected、public、static、yield。ECMAscript 第五版本身还规定了另一些保留字：class、enum、export、extends、import、super，以及各大浏览器自行增加的 const 保留字。 只允许在全局作用域或函数作用域的顶层声明函数，也就是，if、for 代码块内或者其他大括号（{}）块内不允许声明函数。 最后，记得在支持或者不支持严格模式的浏览器中测试代码。如果只在不支持严格模式的浏览器中测试，那么在支持的浏览器中就很有可能出问题，反之亦然。 代码规范 遵循严格模式。 尽量使用 ES6 语法。 使用 const、let 关键字声明变量。 使用拓展运算符 ... 复制数组、对象。 使用解构赋值。 使用箭头函数。 最外层统一使用单引号，有变量时，使用模板字符串 (``)。 使用标准的 ES6 模块语法 import 和 export。 使用对象方法、对象属性的简写方式。 使用字面量值创建对象。 const obj1 = {} // 推荐 const obj2 = new Object{} 禁止使用保留字作为对象的键值，这样在 IE8 下不会运行 避免嵌套函数中直接使用 this，建议先赋值给另一个变量，如，_this|that|self。 避免使用 ==、!= ，尽量使用 ===、!== 避免在内置对象（Array、String、Date等）的原型上添加方法 一次只声明一个变量 常量采用大写字母，下划线连接的方式 每个语句的末尾不使用分号 for、if 语句必需在大括号内 switch 语句必须带有 default 分支 不加空格 前缀一元运算符后 后缀一元运算符前 函数调用括号前 函数名和 () 之间 对象的属性名后 数组的 [ 后和 ] 前 对象的 { 后和 } 前 运算符 ( 后和 ) 前 加空格 二元运算符前后 三元运算符 ?: 前后 代码块 { 前 关键字 else、while、catch、finally 前 关键字 if、else、for、while、do、switch、case、try,catch、finally、with、return、typeof 后 单行注释 // 后，若单行注释和代码同行，则 // 前也需要；多行注释 * 后 对象的属性值前 for 循环：分号后留空格；前置条件如果有多个，逗号后留空格 函数的参数之间 空行 变量声明后 注释前 代码块后 文件最后 命名规范 采用一致的方法命名变量和函数可提高代码可预测性和可维护性。 普通变量命名 驼峰式命名：第一个单词首字母小写，后面其他单词首字母大写。 匈牙利命名：前缀字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，单词第一个字母大写。 JavaScript变量起名类型 变量命名前缀 举例 Array 数组 a aList，aGroup Boolean 逻辑 b bChecked，bHasLogin Function 函数 f fGetHtml，fInit Integer 数字 n nPage，nTotal Object 对象 o oButton，oDate Regular Expression 正则 r rDomain，rEmail String 字符 s sName，sHtml 函数命名 普通函数：fn + 动词 + 名词形式。如：fnGetVersion() 内部函数：_fn + 动词 + 名词形式，内部函数必需在函数最后定义。如： _fnGetNumber 对象方法：fn + 对象类名 + 动词 + 名词形式。如：fnAddressGetEmail() 事件响应函数：fn + 触发事件对象名 + 事件名或者模块名。如：fnDivClick() 函数方法常用的动词： get 获取 set 设置 add 增加 remove 删除 create 创建 destory 移除 start 启动 stop 停止 open 打开 close 关闭 read 读取 write 写入 load 载入 save 保存 create 创建 destroy 销毁 begin 开始 end 结束 backup 备份 restore 恢复 import 导入 export 导出 split 分割 merge 合并 inject 注入 extract 提取 attach 附着 detach 脱离 bind 绑定 separate 分离 view 查看 search 搜索 edit 编辑 modify 修改 select 选取 mark 标记 copy 复制 paste 粘贴 undo 撤销 redo 重做 insert 插入 delete 移除 clean 清理 clear 清除 find 查找 sort 排序 increase 增加 decrease 减少 play 播放 pause 暂停 compile 编译 execute 执行 debug 调试 trace 跟踪 observe 观察 listen 监听 build 构建 publish 发布 input 输入 output 输出 encode 编码 decode 解码 encrypt 加密 decrypt 解密 compress 压缩 decompress 解压缩 pack 打包 unpack 解包 parse 解析 emit 生成 connect 连接 disconnect 断开 send 发送 receive 接收 download 下载 upload 上传 refresh 刷新 synchronize 同步 update 更新 revert 复原 lock 锁定 unlock 解锁 submit 提交 commit 交付 push 推送 pull 拉取 expand 展开 collapse 折叠 start 开始 finish 完成 enter 进入 exit 退出 abort 放弃 quit 离开 构造函数（类）命名 大驼峰式命名 class MyArticle { constructor(props) { this.author = props.author } } new MyIndexedDB({ author: 'lizhao' }) 其他命名 作用域不大临时变量可以简写。比如：str、num、bol、obj、fun、arr。 循环变量可以简写。比如：i、j、k。 某些作为不允许修改值的变量认为是常量，全部字母都大写，单词以_分割。例如：COPYRIGHT、PI、AUTHOR_NAME。 API 文档（注释） 编写特殊格式的代码块（即一些注释块）； 运行工具来解析代码和注释（工具如：JsDoc Toolkit 和 YUIDoc）； 发布工具解析的结果，大多数情况是采用 HTML 格式发布。 参考资料 MDN - 严格模式 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-05-29 00:56:01 "},"html探索系列/00-HTML基础知识.html":{"url":"html探索系列/00-HTML基础知识.html","title":"HTML基础知识","keywords":"","body":"HTML基础知识 Web标准 Web标准的三个规范 结构（Structure） HTML：HTML英语意思是：Hypertext Marked Language，即超文本标记语言,使用HTML语言描述的文件，需要通过 WWW 浏览器显示出效果。是一种最为基础的语言。所谓超文本，因为它可以加入图片、声音、动画、影视等内容，因为它可以从一个文件跳转到另一个文件，与世界各地主机的文件连接。所谓标记，就是它采用了一系列的指令符号来控制输出的效果，这些指令符号用“”来表示。 XHTML：XHTML 是 HTML 向 XML 的过渡语言，删除了部分表现层的标签，标准要求提高，有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个\"/\"来关闭它。 XML：XML（eXtensible Markup Language）即可扩展标记语言，最初设计的目的是弥补 HTML 的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。XML 是一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式建立，虽然 XML 占用的空间比二进制数据要占用更多的空间，但 XML 极其简单易于掌握和使用。 表现（Behaivor） 表现标准语言主要包括 CSS（Cascading Style Sheets）层叠式样式表，通过 CSS 样式表，W3C 创建 CSS 标准的目的是以 CSS 取代HTML 表格式布局、帧和其他表现的语言，通过 CSS 样式可以使页面的结构标签更具美感、网页外观更加美观。 行为（Presentation） 行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化。 标准主要包括：ECMAScript(核心)，DOM（文档对象模型），BOM（浏览器对象模型）。 ECMAScript(核心)： ECMAScript 是一个语言标准，javascript 则是基于这个标准实现的脚本语言。 ECMAScript 是一种可以在宿主环境中执行计算并能操作可计算对象的基于对象的程序设计语言。ECMAScript 最先被设计成一种 Web 脚本语言，用来支持 Web 页面的动态表现以及为基于 Web 的客户机—服务器架构提供服务器端的计算能力。但作为一种脚本语言， ECMAScript 具备同其他脚本语言一样的性质，即“用来操纵、定制一个已存在系统所提供的功能，以及对其进行自动化”。 DOM（文档对象模型）： DOM全称 Document Object Model，即文档对象模型，它允许脚本(js)控制 Web 页面、窗口和文档。 DOM 标准分为 ：核心DOM，针对任何结构化文档的标准模型；XML DOM，针对 XML 文档的标准模型；HTML DOM，针对 HTML 文档的标准模型。 BOM（浏览器对象模型）: BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 常见的BOM对象有： window：代表整个浏览器窗口（window是BOM中的一个对象，并且是顶级的对象）； Navigator ：代表浏览器当前的信息，通过 Navigator 我们可以获取用户当前使用的是什么浏览器； Location： 代表浏览器当前的地址信息，通过 Location 我们可以获取或者设置当前的地址信息； History：代表浏览器的历史信息，通过 History 我们可以实现上一步/刷新/下一步操作（出于对用户的隐私考虑，我们只能拿到当前的浏览记录，不能拿到所有的历史记录）； Screen：代表用户的屏幕信息。 Web标准之可访问性、可用性、可维护性 可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 Web标准的优点 代码的效率：在HTML文件中使用最精简的代码，而把样式和页面布局信息包含进 CSS 文件中；则放在服务器上的文件越小，下载文件需要的时间就越短。 易于维护：页面的样式和布局信息保存在单独的 CSS 文件中，如果你想改变站点的外观时，仅需要在单独的 CSS 文件中做出更改可。整站统一 css 则可带来巨大的便利。 可访问性：上网用户中那些视力受损的人，通过屏幕阅读器使用键盘命令将网页的内容读给他们听。以语义化的HTML（结构和表现相分离的HTML）编写的网页文件，就可以让此类用户更容易导航，且网页文件中的重要信息也更有可能被这些用户找到。 设备兼容性：纯HTML，无附加样式信息，可以针对具有不同特点（如屏幕尺寸等）的设备而被重新格式化，只需要引用一套另外的样式表即可。同时，CSS 本身也可以让你为不同的呈现方式和媒体类型（如在屏幕上阅读网页，打印网页，在移动设备上阅读网页等）规定不同的样式表。 网络爬虫/搜索引擎：搜索引擎使用“爬虫”，解析你的网页。语义化的HTML能更准确更快速的被解析，从而知道哪些才是重要的内容，那么你的网页在搜索结果中的排名就会大受影响 HTML的lang属性，用\"zh\" 还是\"zh-cn\"？ “zh” 是中文，代表的是宏语言（Macrolanguage），单独使用表示 \"中文” 整体，可以是方言、文言文、简体、繁体等单独一种，也可以是任意组合的混合内容。 “zh-CN” 理论上表示的是 “中文 (中国大陆)”，因为中国大陆的官方语言是 “普通话 (简体)”。所以，“zh” 的局限性就体现出来了：比如“尋尋覓覓，冷冷清清，悽悽慘慘戚戚”，用 “zh-CN” 描述没法表达出繁體和文言文，但描述成 “zh-TW” 则成了 “中文 (繁體, 台灣)”，虽然指明了 繁体，但还是没能体现出文言文，同时还丢失了 “中国大陆”。 针对这种情况，按照 BCP 47 规范，应该使用独立语种更精确地描述： cmn 普通话（官话、国语） wuu 吴语（江浙话、上海话） czh 徽语（徽州话、严州话、吴语-徽严片） hak 客家语 yue 粤语（广东话） nan 闽南语（福建话、台语） cpx 莆仙话（莆田话、兴化语） cdo 闽东语 mnp 闽北语 zco 闽中语 gan 赣语（江西话） hsn 湘语（湖南话） cjy 晋语（山西话、陕北话） 语言文字标签书写顺序： language - extlang - script - region - variant - extension - privateuse 语言文字种类 - 扩展语言文字种类 - 书写格式 - 国家和地区 - 变体 - 扩展 - 私有 大小写约定： language 是小写的，region 是大写的，script 以首字母大写开始。 这只是个惯例！您可以按照自己喜欢的方式进行书写，除非您受到所使用系统规则的约束。 对于 HTML 和 XML 语言标记，大小写应该无关紧要。 language: zh 中文 fr 法语 es 西班牙语 language-extlang: zh-lzh 中文 (文言文) sgn-csl 手语 (中国大陆) language-script: cmn-Hans 普通话 (简体) yue-Hant 粤语 (繁体) language-region: zh-CN 中文 (简体, 中国大陆) en-US 英语 (美国) language-script-region： cmn-Hans-CN 普通话 (简体, 中国大陆) cmn-Hant-TW 普通话 (繁体, 台湾) language-script-variant: zh-Latn-pinyin 汉语拼音（例：nǐ，拉丁字母形式） zh-Bopo-pinyin 注音拼音（例：ㄋ丨ˇ，罗马字形式，中国大陆 1958 年以前使用，台湾目前使用） 常见的一般有 language、language-script 和 language-region 三种。 ？？Hans 是 han simplified 简写？Hant 是 hans Traditional 简写？? cmn、wuu、yue 等 2005 年确定的 extlang 标记已于 2009 年提升为 language 标记，维基百科中 吴语、粤语 等页面均已使用最新的标准写法。 以下以 zh 开头的写法已被废弃并不再推荐使用，请直接去掉 zh- 前缀并使用 cmn、wuu、yue 等代替即可： zh-Hans, zh-Hans-CN, zh-cmn, zh-cmn-Hans, zh-wuu, zh-yue, zh-gan.... 类似还有 zh-Hans-HK、zh-Hans-MO、zh-Hans-TW、zh-Hant 废弃可能原因：在语言学的分类上，中国语言学者多认为 吴语、粤语、闽语 等是汉语的方言，而西方学者多认为这些语言是一门和 普通话 同级关系的单独语种。 中国大陆常见划分： 1. 汉藏语系 1.1. 汉语族 1.1.1. 汉语 1.2. 藏缅语族 1.3. 苗瑶语族 1.4. 壮侗语族 “汉语族”仅包含“汉语”一门语言，“吴语”“客家语”“粤语”“闽语”等均归属于“汉语”的不同方言。 西方常见划分： 1. 汉藏语系 1.1. 汉语族 1.1.1. 普通话（官话、国语） 1.1.2. 吴语（江浙话、上海话） 1.1.3. 徽语（徽州话、严州话、吴语-徽严片） 1.1.4. 客家语 1.1.5. 粤语（广东话） 1.1.6. 闽南语（福建话、台语） 1.1.7. 莆仙话（莆田话、兴化语） 1.1.8. 闽东语 1.1.9. 闽北语 1.1.10. 闽中语 1.1.11. 赣语（江西话） 1.1.12. 湘语（湖南话） 1.1.13. 晋语（山西话、陕北话） 1.2. 藏缅语族 1.3. 苗瑶语族 1.4. 壮侗语族 “汉语族”包含“普通话”“吴语”“徽语”“客家话”“粤语”等多种语言。 重点来了！ 以下两种写法均正确，后者描述更精准，但大部分程序和操作系统都只能识别前者，使用新标准可能会造成无法匹配浏览器用户定义字体、网页翻译、程序语言自动切换等功能，为了兼容性的考量，推荐使用前者： zh-CN 中文 (简体, 中国大陆) -> cmn-Hans-CN 普通话 (简体, 中国大陆) zh-SG 中文 (简体, 新加坡) -> cmn-Hans-SG 普通话 (简体, 新加坡) zh-HK 中文 (繁体, 香港) -> yue-Hant-HK 粤语 (繁体, 香港) zh-MO 中文 (繁体, 澳门) -> yue-Hant-MO 粤语 (繁体, 澳门) zh-TW 中文 (繁体, 台湾) -> cmn-Hant-TW 普通话 (繁体, 台湾) 简体中文页面默认或书面语均标记为 “cmn (普通话)”，全文使用地方方言表达时，使用相应语言文字标签标记： “你” “我们” 用 cmn-Hans 普通话 (简体) “侬” “啊啦” 用 wuu-Hans 吴语 (简体) “你” “我哋” 用 yue-Hans 粤语 (简体) 一般情况不用 region 选项，但如果要针对特定地区特定用语的友好性，则应设置区域： “消息” “黄梨” “自行车” 用 cmn-Hans-SG 普通话 (简体, 新加坡) “消息” “菠萝” “自行车” 用 cmn-Hans-CN 普通话 (简体, 中国大陆) “消息” “菠蘿” “自行車” 用 cmn-Hant-CN 普通话 (繁体, 中国大陆) “訊息” “菠蘿” “单车” 用 cmn-Hant-HK 普通话 (繁体, 香港) “訊息” “鳳梨” “腳踏車” 用 cmn-Hant-TW 普通话 (繁体, 台湾) “analyse” “color” “elevator” 用 en-US 英语 (美国) “analyze” “colour” “lift” 用 en-GB 英语 (英国) 最后来回答下问题：”zh“ 表示中文，”zh-CN“ 表示 “中文（中国）\"。两者有细微的差别：后者特指在中国大陆使用的中文。如果网页面向多个国家（如：新加坡），可用 \"zh\"；如果只是面向中国大陆，用 \"zh-CN\"。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-01-14 12:52:14 "},"html探索系列/00-HTML经典实践用例.html":{"url":"html探索系列/00-HTML经典实践用例.html","title":"HTML经典实践用例","keywords":"","body":"HTML经典实践用例 实现圆形点击区域 纯 html 实现： 使用 map、area 来给图像标记热点区域的方式。map 标签用来定义一个客户端图像映射，area 标签用来定义图像映射中的区域（矩形、圆形、多边形），area 标签必需嵌套在 map 元素内部。 纯 css 实现： 使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。 纯 Js 实现： 通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在规定的圆形区域内。 查看 图像映射 DEMO map map 标签用于与其他标签来定义图像映射（可点击链接区域）。 通过 map 标签的 name 属性为提供了一个名称，以便可以对其进行引用。该属性必须存在并且必须具有不带空格字符的非空值，不得等于同一文档另一个 map 标签的 name 属性值。如果指定了 id 性，则 id 属性必须与 name 相同。 图片和热点区域元素关联是使用图片的 usemap 属性，其值对应 map 标签的 id 或者 name。出于兼容性考虑，最好两个属性都加上。比如，Chrome 只支持 name 属性。 area area 标签可以在热点区域内定义几何区域与相关联的超文本链接。 shape： 定义热点的形状。 rect 表示定义了一个矩形区域； circle 表示定义了一个圆形区域； poly 表示定义一个多边形； default 表示超出任何定义形状的整个区域。 coords： 说明了的坐标 shape 的大小、形状和位置，坐标值都是以 px 为单位。 rect对应值是 x1,y1,x2,y2，指定矩形左上角和右下角的坐标； circle对应值是 x,y,radius，指定圆心坐标和半径； poly 对应值是 x1,y1,x2,y2,..,xn,yn，指定多边形边缘的坐标。如果第一个和最后一个坐标对不一样，浏览器会添加最后一个坐标对来闭合多边形； default 则不需要该属性，即使定义了也是无效r 。 href： area 的超链接目标，是一个有效的 URL。该属性可以省略；如果省略，则该 area 标签不代表超链接。 注意： area 标签必须拥有一个 map 祖先标签，但不一定是直接的父标签。 注意： 如果某个 area 标签中的坐标和其他区域发生了重叠，会优先采用最先出现的 area 标签。浏览器会忽略超过图像边界范围之外的坐标。 注意： Tab 键索引可以看到 area 区域。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-08-28 13:13:34 "},"html探索系列/01-HTML元素的宽高及位置详解.html":{"url":"html探索系列/01-HTML元素的宽高及位置详解.html","title":"HTML元素的宽高及位置详解","keywords":"","body":"HTML元素的宽高度及位置详解 元素的宽度 window.innerWidth //除去菜单栏的窗口宽度。安卓、ios都认别 window.innerHeight //除去菜单栏的窗口高度。安卓、ios都认别 window.outerWidth //包括菜单栏的窗口宽度。安卓手机识别，ios不认别。 window.outerHeight //包括菜单栏的窗口宽度。安卓手机识别，ios不认别。 window.screen.height //屏幕的高度 window.screen.width //屏幕的宽度 window.screen.availHeight //屏幕的可利用高度 window.screen.availWidth //屏幕的可利用宽度 //screen.width/height，屏幕宽度/高度(即：屏幕分辩率。比如1920 * 1080） //screen.availWidth/availHeight，屏幕的可利用宽度/高度(即：屏幕分辩率 - (工具栏 + mac的dock等) window.screenTop //浏览器距离屏幕的高度 window.screenLeft //浏览器距离屏幕的宽度 window.scrollX //属性返回页面的水平滚动距离 window.scrollY //属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。 window.pageXOffset //window.scrollX别名 window.pageYOffset //window.scrollY别名 document.body.clientWidth //指元素的自身宽度（包括padding） document.body.clientHeight //指元素的自身的高度（包括padding） document.body.clientLeft //子级div内容位置到父级内容区域的宽度距离(即border值) document.body.clientTop //子级div内容位置到父级内容区域的高度距离(即border值) document.body.offsetWidth //指定元素的宽度（包括padding，border和内容） document.body.offsetHeight //指定元素的高度（包括padding，border和内容） document.body.offsetTop //距离父级元素的高度 document.body.offsetLeft //距离父级元素的宽度 document.body.scrollWidth //获取的是文档的宽度（当指定的宽度小于浏览器窗口的时候，为浏览器的宽度） document.body.scrollHeight //获取的是文档的高度（当指定的高度小于浏览器窗口的时候，为浏览器的高度） document.body.scrollTop //文档被滚动上去的时候（即滚动条往上滚动的距离） document.body.scrollLeft //文档被滚动右去的时候（即滚动条往右滚动的距离） document.documentElement.scrollWidth //获取的是文档的宽度（当指定的宽度小于浏览器窗口的时候，为浏览器的宽度） document.documentElement.scrollHeight // document.documentElement.scrollTop //垂直方向滚动的值 document.documentElement.scrollLeft //clientX，clientY是事件中的概念 event.clientX //鼠标点击时候距离可视区的左侧坐标 event.clientY //鼠标点击时候距离可视区的上侧坐标 event.clientX + document.documentElement.scrollLeft //鼠标点击时候相对文档左侧的水平距离 document.body.scrollTop与document.documentElement.scrollTop两者有个特点，就是同时只会有一个值生效。比如document.body.scrollTop能取到值的时候，document.documentElement.scrollTop就会始终为0；反之亦然。所以，如果要得到网页的真正的scrollTop值，可以这样： document.body.scrollTop + document.documentElement.scrollTop。 offset：指定元素的border+padding+内容的宽度和高度 IE6/7中: offsetLeft = (offsetParent的padding-left)+(当前元素的margin-left)IE8以上: offsetLeft = (offsetParent的margin-left)+(当前元素的margin-left)火狐中: offsetLeft = (offsetParent的margin-left)+(当前元素的margin-left)+(offsetParent的padding-left) client: 指定元素的宽度和高度 即内容+padding 如果没有滚动条，即元素本身设定的宽度如果出现滚动条，滚动条会遮盖元素宽高，那么，该属性就是其本来宽高减去滚动条的宽度读取元素border的宽度和高度（子级内容区域到父级内容区域的距离）: document.body.clientLeft、document.body.clientTop scroll： 元素的宽度（client）+滚动部分?? 文档渲染模式 文档的渲染模式有\"混杂模式\"和\"标准模式\"。还有另外一种渲染模式, Gecko的\"准标准模式\", 该模式和标准规范模式的区别仅为表格单元内的图片布局方式不同. 且该模式的类型字符串仍为: \"CSS1Compat\". document.compatMode用来判断当前浏览器采用的渲染方式。官方解释：BackCompat：标准兼容模式关闭。CSS1Compat：标准兼容模式开启。 当document.compatMode等于BackCompat时，浏览器客户区宽度是document.body.clientWidth； 当document.compatMode等于CSS1Compat时，浏览器客户区宽度是document.documentElement.clientWidth。 documentElement 对应的是 html 标签，而 body 对应的是 body 标签。 浏览器窗口可视区域兼容性写法 浏览器窗口的大小，则是指在浏览器窗口中看到的那部分网页面积，又叫做viewport（视口）。 IE8及IE8以下不兼容： window.innerWidth/window.innerHeight 标准模式下：document.documentElement.clientWidth/document.documentElement.clientHeight 怪异模式下：document.body.clientWidth/document.body.clientHeight function getViewport(){ if (document.compatMode == \"BackCompat\"){ return { width: document.body.clientWidth, height: document.body.clientHeight } } else { return { width: document.documentElement.clientWidth, height: document.documentElement.clientHeight } } } 一个准确获取网页客户区的宽高、滚动条宽高、滚动条Left和Top的代码（兼容目前流行的全部浏览器，包括：IE、Firefox、Safari、Opera、Chrome）： if (document.compatMode == \"BackCompat\") { cWidth = document.body.clientWidth; cHeight = document.body.clientHeight; sWidth = document.body.scrollWidth; sHeight = document.body.scrollHeight; sLeft = document.body.scrollLeft; sTop = document.body.scrollTop; } else { //document.compatMode == \"CSS1Compat\" cWidth = document.documentElement.clientWidth; cHeight = document.documentElement.clientHeight; sWidth = document.documentElement.scrollWidth; sHeight = document.documentElement.scrollHeight; sLeft = document.documentElement.scrollLeft == 0 ? document.body.scrollLeft : document.documentElement.scrollLeft; sTop = document.documentElement.scrollTop == 0 ? document.body.scrollTop : document.documentElement.scrollTop; } 必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。 大多数情况下，都是document.documentElement.clientWidth返回正确值。但是，在IE6的quirks模式中，document.body.clientWidth返回正确的值，因此加入了对文档模式的判断 clientWidth和clientHeight都是只读属性，不能对它们赋值。 网页的大小 首先，要明确两个基本概念。 一张网页的全部面积，就是它的大小。通常情况下，网页的大小由内容和CSS样式表决定。 很显然，如果网页的内容能够在浏览器窗口中全部显示（也就是不出现滚动条），那么网页的大小和浏览器窗口的大小是相等的。如果不能全部显示，则滚动浏览器窗口，可以显示出网页的各个部分。 function getPagearea(){ if (document.compatMode == \"BackCompat\"){ return { width: Math.max(document.body.scrollWidth, document.body.clientWidth), height: Math.max(document.body.scrollHeight, document.body.clientHeight) 　　} } else { return { width: Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth), height: Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight) } } } 网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth应该相等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值。 网页元素的位置 获取网页元素的绝对位置 网页元素的绝对位置，指该元素的左上角相对于整张网页左上角的坐标。这个绝对位置要通过计算才能得到。每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器（offsetParent对象）左上角的距离。所以，只需要将这两个值进行累加，就可以得到该元素的绝对坐标。 function getElementLeft(element) { var actualLeft = element.offsetLeft var current = element.offsetParent while (current !== null) { 　　actualLeft += current.offsetLeft 　　current = current.offsetParent } return actualLeft } function getElementTop(element) { var actualTop = element.offsetTop var current = element.offsetParent while (current !== null) { 　　actualTop += current.offsetTop 　　current = current.offsetParent } return actualTop } 获取网页元素的相对位置 网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标。有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是document对象的scrollTop属性；滚动条滚动的水平距离是document对象的scrollLeft属性。 function getElementViewLeft(element) { var actualLeft = element.offsetLeft var current = element.offsetParent while (current !== null) { actualLeft += current.offsetLeft current = current.offsetParent } var elementScrollLeft = document.compatMode == \"BackCompat\" ? document.body.scrollLeft : document.documentElement.scrollLeft return actualLeft - elementScrollLeft } function getElementViewTop(element) { var actualTop = element.offsetTop var current = element.offsetParent while (current !== null) { actualTop += current. offsetTop current = current.offsetParent } var elementScrollTop = document.compatMode == \"BackCompat\" ? document.body.scrollTop :document.documentElement.scrollTop return actualTop - elementScrollTop } scrollTop和scrollLeft属性是可以赋值的，并且会立即自动滚动网页到相应位置，因此可以利用它们改变网页元素的相对位置。另外，element.scrollIntoView()方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角。 获取元素位置的快速方法 除了上面的函数以外，还有一种快速方法，可以立刻获得网页元素的位置。那就是使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。 相对位置: var X = this.getBoundingClientRect().left var Y = this.getBoundingClientRect().top 绝对位置(相对位置+滚动距离): var X = this.getBoundingClientRect().left + document.documentElement.scrollLeft + document.body.scrollLeft var Y = this.getBoundingClientRect().top + document.documentElement.scrollTop + document.body.scrollTop 目前，IE、Firefox 3.0+、Opera 9.5+都支持该方法，而Firefox 2.x、Safari、Chrome、Konqueror不支持。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"html探索系列/02-video元素的使用和常见问题总结.html":{"url":"html探索系列/02-video元素的使用和常见问题总结.html","title":"Video元素的使用和常见问题总结","keywords":"","body":"video元素的使用和常见问题总结 HTML元素 用于在HTML或者XHTML文档中嵌入媒体播放器，用于支持文档内的视频播放。你也可以将 标签用于音频内容，但是audio元素可能在用户体验上更合适。 以下是一个局域播放的示例，允许html元素在视频上方： --> Your browser doesn't support HTML5 video. Here is a link to the video instead. 查看DEMO 标签的内容是针对浏览器不支持此元素时候的降级处理。浏览器并不是都支持相同的视频格式，所以你可以在 元素里提供多个视频源，然后浏览器将会使用它所支持的第一个源。 标签它允许指定时序文本字幕（或者基于时间的数据），例如自动处理字幕。 其他使用注意事项： 如果你没有指定controls属性，那么视频不会展示浏览器自带的控件，你也可以用 JavaScript和 HTMLMediaElement API来创建你自己的控件。 HTMLMediaElement会激活许多不同的事件，以便于让你可以控制视频（和音频）内容。 你可以用CSS属性 object-position 来调整视频在元素内部的位置，它可以控制视频尺寸适应于元素外框的方式。 如果想在视频里展示字幕或者标题，你可以在 元素和WebVTT格式的基础上使用 JavaScript 来实现。 video的属性 autoplay：布尔属性；指定后，视频会马上自动开始播放，不需要手动调用play()方法。 自动播放受浏览器政策限制，不同浏览器的表现不一样。移动端的app，可以设置参数来控制是否允许自动播放。 autobuffer：布尔属性；指定后，视频会自动开始缓存，即使没有设置自动播放。该属性适用于视频被认为可能会播放（比如，用户导航到专门播放视频的页面，而不是那种嵌入视频还有其它内容的页面）。视频会一直缓存到媒体缓存满。 controls：加上这个属性，Gecko 会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。 controlslist： 当浏览器显示自己的控件集(例如，当指定了Controls属性时)，Controlslist属性将帮助浏览器选择在媒体元素上显示的控件。允许接受的值有nodownload,nofullscreen和noremoteplayback crossorigin：该枚举属性指明抓取相关图片是否必须用到CORS（跨域资源共享）。 支持CORS的资源 可在元素中被重用，而不会被污染。允许的值如下： anonymous 跨域请求（即，使用 Origin: 的HTTP头）会被执行。但是不发送凭证（即，不发送cookie， X.509 证书或者 HTTP Basic 授权）。如果服务器不提供证书给源站点 (不设置Access-Control-Allow-Origin: HTTP头)，图片会被 污染 并且它的使用会受限。 use-credentials 跨域请求A cross-origin request (i.e. with Origin: HTTP header)会被执行，且凭证会被发送 (即， 发送一个 cookie, 一个证书和HTTP Basic授权会被执行)。如果服务器不提供证书给源站点 (通过Access-Control-Allow-Credentials: HTTP头)，图像会被污染且它的使用会受限。 不加这个属性时，抓取资源不会走CORS请求(即，不会发送 Origin: HTTP 头)，保证其在元素中使用时不会被污染。如果指定非法值，会被当作指定了枚举关键字 anonymous一样使用。 currentTime： 读取CurentTime返回一个双精度浮点值，指示以秒为单位的媒体的当前播放位置。如果video尚未开始播放，则会在开始播放后返回偏移量。通过CurentTime将当前播放位置设置为给定时间，会在加载媒体时将媒体查找到该位置（从指定的位置开始播放）。 媒体正在播放的情况下，如果媒体缓冲区的数据已经过期（视频已经播放完），则user agent有可能无法正常拿到数据。有些媒体可能有一个不以0秒开始的媒体时间线（不是从头开始播放的），因此应该将currentTime的时间设置在其数据失效之前。getStartDate()这个方法可以用来确定媒体时间线起始的坐标。 document.querySelector('video').currentTime = 100 实测，By lizhao，2020.06.07： 1.直接在元素写currentTime属性，有兼容问题，有些浏览器可以无效，如：chrome\\安卓微信。 2.只有视频开始播放后设置的currentTime才有效。 3.不能canplay事件中使用：会陷入死循环。 disablePictureInPicture：防止浏览器建议图片中的上下文菜单或在某些情况下自动请求图片中的图片。 disableRemotePlayback：一个布尔属性，用于禁用使用有线连接的设备(HDMI、DVI等)的远程播放功能。无线技术(Miracast、Chromecast、DLNA、AirPlay等)。 duration（只读）：一个双精度浮点值，它指示媒体的持续时间(总长度)，以秒为单位，在媒体的时间线上。如果元素上没有媒体，或者媒体无效，则返回的值为NaN。如果媒体没有已知终点(例如时间未知的实时流、网络广播、来自WebRTC的媒体等等)，那么这个值就是Infinity。 document.querySelector('video').duration height：视频展示区域的高度，单位是CSS像素。 intrinsicsize： 此属性将覆盖媒体元素的实际固有大小。具体来说，图像将在这些尺寸处进行光栅化，图像上的naturalWidth / naturalHeight 将返回在此属性中指定的值。在视频元素上，视频将以此大小进行光栅化，而视频 上的videoWidth / videoHeight将返回固有大小值。 请确保启用Experimental Web Platform features标志。chrome中输入chrome://flags/，搜索该标志并设置为enabled。 注：chrome中实测无效。By lizhao，2020/05/29。 loop：布尔属性，设置循环播放。指定后，会在视频结尾的地方，自动返回视频开始的地方，重新播放。 muted：布尔属性，指明了视频里的音频的默认设置。设置后，音频会初始化为静音。默认值是false，意味着视频播放的时候音频也会播放 。 document.querySelector('video').muted = true 直接在video写muted属性，有兼容问题 playsinline： 一个布尔属性，标志视频播放时局域播放，不脱离文档流 。请注意，没有此属性并不意味着视频始终是全屏播放的。 playsinline是标准写法 webkit-playsinline在iOS 10 之前的写法，它的浏览器厂商前缀在iOS 10 中被移除。但是目前 iOS微信还不支持去掉前缀的写法。 x5-playsinline是X5内核的写法（微信、QQ浏览器等腾讯产品的内核） playsinline属性比较特别， 需要嵌入网页的APP，比如wechat中UIwebview的allowsInlineMediaPlayback = YES、webview.allowsInlineMediaPlayback = YES，才能生效。 换句话说，如果APP不设置，你页面中加了这标签也无效，这也就是为什么安卓手机WeChat播放视频总是全屏，因为APP不支持playsinline，而ISO的WeChat却支持。 在iOS 10 Safari中，通过可以让视频内联播放。设置了 playsinline属性的视频在播放时不会自动全屏，但用户可以点击全屏按钮来手动全屏；没有设置 playsinline的视频会在播放时自动全屏。无论是否设置 playsinline属性，退出全屏后视频都会继续播放。 注意：如果是想做全屏直播或者全屏H5体验的用户，IOS需要设置删除 webkit-playsinline 标签，因为你设置 false 是不支持的 ，安卓则不需要，因为默认全屏。但这时候全屏是有播放控件的，无论你有没有设置control。 played：返回 TimeRanges对象。TimeRanges对象表示用户已经播放或看到的视频范围。 已播范围指的是被播放视频的时间范围。如果用户在视频中跳跃，则会获得多个播放范围。 document.querySelector('video').played.length //已播放的范围个数 document.querySelector('video').played.start(0) //第一段的开始时间 document.querySelector('video').played.end(0) //第一段的结束时间 preload： 该枚举属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么。可能是下列值之一： none: 提示作者认为用户不需要查看该视频，服务器也想要最小化访问流量；换句话说就是提示浏览器该视频不需要缓存。 metadata: 提示尽管作者认为用户不需要查看该视频，不过抓取元数据（比如：长度）还是很合理的。 auto: 用户需要这个视频优先加载；换句话说就是提示：如果需要的话，可以下载整个视频，即使用户并不一定会用它。 空字符串：也就代指 auto 值。 假如不设置，默认值就是浏览器定义的了 （即，不同浏览器会选择自己的默认值），即使规范建议设置为 metadata。 使用备注： autoplay 属性优先于 preload。假如用户想自动播放视频，那么很明显浏览器需要下载视频。同时设置autoplay 和 preload属性在规范里是允许的。 规范没有强制浏览器去遵循该属性的值；这仅仅只是个提示。 poster：一个海报帧的URL，用于在用户播放或者跳帧之前展示。如果属性未指定，那么在第一帧可用之前什么都不会展示；之后第一帧就像海报帧一样展示。 poster，在不同环境下有兼容问题 readyState：返回音频/视频的当前就绪状态。就绪状态指示音频/视频是否已准备好播放。表示音频/视频元素的就绪状态： HAVE_NOTHING 0 没有关于音频/视频是否就绪的信息 HAVE_METADATA 1 音频/视频已初始化 HAVE_CURRENT_DATA 2 数据已经可以播放(当前位置已经加载) 但没有数据能播放下一帧的内容 HAVE_FUTURE_DATA 3 当前及至少下一帧的数据是可用的(换句话来说至少有两帧的数据) HAVE_ENOUGH_DATA 4 可用数据足以开始播放-如果网速得到保障 那么视频可以一直播放到底 seeking：返回用户目前是否在音频/视频中寻址。寻址中（Seeking）指的是用户在音频/视频中移动/跳跃到新的位置。 src：要嵌到页面的视频的URL。可选；你也可以使用video块内的元素来指定需要嵌到页面的视频。 volume： 设置或返回音频/视频的音量 width：视频显示区域的宽度，单位是CSS像素。 以下为非标准属性： x-webkit-airplay：IOS webkit属性，支持Airplay的设备（如：音箱、Apple TV)播放。这个属性应该是使此视频支持ios的AirPlay功能。通过AirPlay可以把当前的视频投放到支持此技术的其他设备上。 x5-video-player-type： 功能：启用同层H5播放器。 可选值：h5-page 特点：在视频全屏的时候（即不加x5-playsinline=\"true\"属性），页面中元素可以呈现在视频层上，也是WeChat安卓版特有的属性 x5-video-orientation： 功能：声明播放器支持的方向 可选值： landscape横屏, portraint竖屏 默认值：portraint //横屏 //竖屏 //跟随手机自动旋转 注： 此属性只在声明了x5-video-player-type=”h5”情况下生效 x5-video-player-fullscreen： 功能：视频播放时将会进入到全屏模式。 可选值：true支持全屏播放，false不支持全屏播放 默认值：false 如果不申明此属性，页面得到视口区域为原始视口大小(视频未播放前)，比如在微信里，会有一个常驻的标题栏，如果不声明此属性，这个标题栏高度不会给页面，播放时会平均分为两块（上下黑块） 注： 声明此属性，需要页面自己重新适配新的视口大小变化。可以通过监听resize 事件来实现 video的方法 addTextTrack：向音频/视频添加新的文本轨道。 注：所有主流浏览器都不支持 addTextTrack()方法。 document.querySelector('video').addTextTrack(kind,label,language) canPlayType：检测浏览器是否能播放指定的音频/视频类型，返回String。如下： probably：浏览器最可能支持该音频/视频类型 maybe：浏览器也许支持该音频/视频类型 \"\" ： （空字符串）浏览器不支持该音频/视频类型 document.querySelector('video').canPlayType('video/mp4') load：重新加载音频/视频元素 document.querySelector('video').load() play：开始播放音频/视频 document.querySelector('video').play() pause：暂停当前播放的音频/视频 document.querySelector('video').pause() video的事件 事件名称 描述 abort 在播放被终止时触发。例如：当播放中的视频重新开始播放。 canplay 在媒体数据已经有足够的数据（至少播放数帧）可供播放时触发。 canplaythrough 表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。注意：手动设置currentTime会使得firefox触发一次canplaythrough事件，其他浏览器或许不会如此。 durationchange 表明媒体的长度发生了改变。例如：在媒体已被加载足够的长度从而得知总长度时会触发这个事件。 emptied 媒体被清空（初始化）时触发。 ended 播放结束时触发。 error 在发生错误时触发。元素的error属性会包含更多信息。参阅 HTMLMediaElement.error 获得详细信息。 loadeddata 媒体的第一帧已经加载完毕。 loadedmetadata 媒体的元数据已经加载完毕，现在所有的属性包含了它们应有的有效信息。 loadstart 在媒体开始加载时触发。 mozaudioavailable 当音频数据缓存并交给音频层处理时 pause 播放暂停时触发。 play 在媒体回放被暂停后再次开始时触发。即：在一次暂停事件后恢复媒体回放。 playing 在媒体开始播放时触发（不论是初次播放、在暂停后恢复、或是在结束后重新开始）。 progress 告知媒体相关部分的下载进度时周期性地触发。有关媒体当前已下载总计的信息可以在元素的buffered属性中获取到。 ratechange 在回放速率变化时触发。 seeked 在跳跃操作完成时触发。 seeking 在跳跃操作开始时触发。 stalled 在尝试获取媒体数据，但数据不可用时触发。 suspend 在媒体资源加载终止时触发，这可能是因为下载已完成或因为其他原因暂停。 timeupdate 元素的currentTime属性表示的时间已经改变。 volumechange 在音频音量改变时触发（既可以是volume属性改变，也可以是muted属性改变）。 waiting 在一个待执行的操作（如回放）因等待另一个操作（如跳跃或下载）被延迟时触发。 source HTML元素为、、元素指定多个媒体资源。 这是一个空元素。它通常用于以不同浏览器支持的多种格式提供相同的媒体内容。 track HTML元素 被当作媒体元素—和的子元素来使用。它允许指定时序文本字幕（或者基于时间的数据），例如自动处理字幕。字幕格式有 WebVTT格式（.vtt格式文件）— Web 视频文本字幕格式，以及指时序文本标记语言（TTML）格式。 default属性：该属性定义了该track应该启用，除非用户首选项指定了更合适一个track。每个媒体元素里面只有一个 track 元素可以有这个属性。 kind属性： 定义了 text track 应该如何使用。如果省略了该属性，默认的 kind 值就是 subtitles。 subtitles。字幕给观影者看不懂的内容提供了翻译。比如英文电影里非英文的对话框或者文字。字幕可能包含额外的内容，通常有附加的背景信息。比如在电影星球大战开头的文字，或者某个场景的日期，时间，还有地点。 captions。隐藏式字幕提供了音频的转录甚至是翻译。可能包含重要的非言语的信息，比如音乐提示或者音效。可以指定提示音的源文件 (e.g. music, text, character)。适用于耳聋的用户或者当调成静音的时候。 descriptions。视频内容的文本描述。适用于失明用户或者当视频不可见的场景。 chapters。章节标题。用于用户浏览媒体资源的时候。 metadata。脚本使用的track。 对用户不可见。 label属性：当列出可用的text tracks时，给浏览器使用的text track的标题，这种标题是用户可读的。 src属性：track的地址。必须是合法的URL。该属性必须定义。 srclang属性： track文本数据的语言。它必须是合法的 BCP 47 语言标签。如果 kind 属性被设为 subtitles, 那么srclang 必须定义。如 zh中文 zh-cmn 中文普通话 zh-Hans （简体字） zh-yue（广东话） zh-Hant-HK （香港使用繁体中文） zh-cmn-Hans 中文普通话简体 en （英语） en-GB （英式英语） 一个media 元素的任意两个 track 子元素不能有相同的 kind, srclang, 和 label属性。 注意：元素是 HTML5 中的新元素。需注意其兼容性 WebVTT Web 视频文本轨格式（WebVTT） Web视频文本跟踪格式 (WebVTT) 是一种使用元素显示定时文本轨道（如字幕或标题）的格式。 WebVTT文件的主要用途是将文本叠加添加到。 WebVTT是一种基于文本的格式，必须使用UTF-8进行编码。 在可以使用空格的地方，您也可以使用制表符。 还有一个小的API可用于表示和管理这些轨道以及在正确的时间执行文本回放所需的数据。 WebVTT 文件的 MIME 类型为 text/vtt。 一个 WebVTT 文件（.vtt） 包含任意条带时间的提示性内容（cue）（可理解为一条或多条字幕），可以是单行或多行，如下所示： WEBVTT 美人谷 00:02.000 --> 00:05.000 美人谷 - 阿兰 00:07.950 --> 00:15.760 词：毛慧 曲：阿兰/毛慧 编曲：叶月/王晨 制作人：毛慧 录音：张生磊（记忆时刻录音棚） 00:38.130 --> 00:44.180 越过山河的神秘 幕自然的洗礼 看见山川出云泽被着大地 ... 可以修改字幕样式： /*写在css文件中*/ video::cue { background-image: linear-gradient(to bottom, dimgray, lightgray); color: papayawhip; } video::cue(b) { /*表示.vtt中，标签内文本的样式*/ color: peachpuff; } /*写在.vtt文件中*/ ... STYLE ::cue { background-image: linear-gradient(to bottom, dimgray, lightgray); color: papayawhip; } 00:38.130 --> 00:44.180 越过山河的神秘 幕自然的洗礼 看见山川出云泽被着大地 ... 自动播放 早期的安卓和IOS都需要用户手势才能自动播放，后期逐渐放宽的自动播放的策略，逐渐开始支持自动播放，当然在不同的机型和对应的浏览器上，展示略有差异，这个没有完全清楚所有机型展示情况。 检测当前的浏览器是否能支持自动播放： let promise = document.querySelector('video').play(); if (promise !== undefined) { promise.then(() => { // video can play }).catch(err => { // video cannot play }) } 移动端应用中内嵌的浏览器（如：wkWebView），有参数控制是否允许自动播放。因此，不同的应用下，展示情况略有差异。比如：钉钉可以支持，但是微信就禁止。 微信提供了内置的事件来支持自动播放： //实测：iPhone 11 Pro的微信可以自动播放；小米10的微信无法自动播放。By lizhao，2020/06/07 //必须加载JSAPI的JS文件。如：http://res.wx.qq.com/open/js/jweixin-1.2.0.js document.addEventListener(\"WeixinJSBridgeReady\", function (){ document.querySelector('video').play(); }, false) Chrome自动播放 实测：By lizhao，2020/05/30 使用muted属性后，可以自动播放。 Android自动播放 小米10实测：By lizhao，2020/05/30 UC浏览器、微信不支持自动播放（无论是否设置muted属性），video设置 autoplay属性和JS调用play()方法都一样无效。QQ浏览器支持自动播放（无论是否设置muted属性） IOS自动播放政策 IOS 8自动播放政策 允许使用 preload=\"metadata\"来预加载视频 Meta信息，但无法自动播放，也无法内联播放，只能在【用户主动操作】后才能播放，且播放时必须全屏。 至于「用户主动操作」具体指的是哪些行为，苹果官方有详细的说明： 点击视频播放按钮； 触发 touchend、click、doubleclick 、 keydown 事件，且在事件处理函数中直接调用 video.play()方法。 显然，button.addEventListener('click', () => { video.play(); })满足要求；而 video.addEventListener('canplaythrough', () => { video.play(); })不满足要求； 值得注意的是：上面讨论的是 IOS自带 Safari的视频播放政策。对于IOS APP 而言，开发者在给 webview设置 mediaPlaybackRequiresUserAction和 allowsInlineMediaPlayback属性之后，页面中的 标签就可以通过 autoplay和webkit-playsinline 属性来启用自动播放和内联播放功能。 IOS 10自动播放政策 随着视频的进一步普及，在IOS 10 中，苹果终于进一步放松了 Safari视频播放政策。IOS 10 Safari允许自动播放以下两种视频： 无音轨视频； 无声音视频（设置了 muted 属性）； 对于这两种类型的视频，可以通过或video.play()两种方式来自动播放，无需用户主动操作。但是，如果它们在播放时变得有声音（获取了音轨，或者 muted 属性被取消），Safari 会暂停播放。 通过 自动播放的视频元素还需要满足一个条件：在可视区域内。同样，如果它们在播放时因为页面滚动等原因导致不可见，Safari也会暂停播放。 全屏/局域播放 全屏和局域播放的区别主要在于： 全屏播放：一般是调用系统的native播放器来打开全屏观看，覆盖在webview之上，即，播放界面位于所有页面元素的上方，并且控制条无法隐藏。Android和IOS，在微信环境下打开，默认都是全屏播放。 局域播放：视频是在文档内播放的，即，可以在视频上方显示html元素。video不加controls属性，可以隐藏控制条（实测：微信内置浏览器、QQ浏览器、UC浏览器。By lizhao，2020/05/30）。 IOS全屏处理： 全屏播放：IOS默认打开的是全屏模式。 局域播放：video设置 webkit-playsinline='true'属性。 Android全屏处理： 全屏播放：微信默认全屏播放，QQ、UC浏览器默认局域播放。 小米10实测：By lizhao，2020/05/30 微信、QQ浏览器，横屏的全屏状态下，点击【旋转】，回到竖屏状态，页面样式有问题；UC浏览器旋转正常。 局域播放：video设置x5-playsinline=\"true\"。 同层播放：video设置x5-video-player-type：h5-page。 同层全屏播放：video不设置x5-playsinline属性，设置x5-video-player-type：h5-page。 同层全屏形态下的控件前端可以自定义，native形态不支持自定义。native形态播放器是处于顶层的独立view会遮盖视频区域的其它元素。 伪全屏：采用局域播放状态，即video标签设置playsinline（注意兼容问题，具体可查看上文playsinline属性），通过设置样式和布局将视频内容撑满屏幕。应用场景：视频播放区域占满手机屏幕，视频上方需要显示弹幕、评论区等。 CSS实现控制条隐藏：在video外层套一个div，height设置固定值，并且设置overflow:hidden，video的高度设置为大于外层的高度，就能把控制条顶到视窗外。注意：这个时候对于video可能会造成放大，视频要留有一定的安全区，防止遮挡主体内容。 video播放的控制 video元素有提供多个行为事件供开发者控制视频播放，兼容性比较好的有 onended 、 ontimeupdate、onplay、onplaying等，有些事件在不同浏览器不同设备上的的表现情况并不一致，不同的系统，设备，浏览器显示的特性还是很不一样的，还是看业务场景需要兼容到什么样，尽量不要大量处理这些事件，不然用户去浏览的时候，兼容问题较多。 进入全屏的事件： //腾讯浏览器：进入/退出全屏事件（支持版本: TBS中从>=036900开始支持，QB中是>=7.2开始支持）： video.addEventListener(\"x5videoenterfullscreen\", () => { console.log(\"进入全屏通知\"); }) video.addEventListener(\"x5videoexitfullscreen\", () => { console.log(\"退出全屏通知\"); }) //IOS 微信：进入/退出全屏的事件： video.addEventListener(\"webkitbeginfullscreen\", () => { console.log(\"进入全屏通知\"); }) video.addEventListener(\"webkitendfullscreen\", () => { console.log(\"退出全屏通知\"); }) // 监听暂停事件 video.addEventListener('pause', () => { console.log('暂停了') }) // 监听停止事件 video.addEventListener('ended', () => { console.log('停止了') }) 事件在不同环境的表现： vent pc侧 IOS Android loadstart 文件加载，video初始化，未加载任何数据 一致 一致 stalled 视频没有播放，没有取回任何媒介数据：一般是由于网络状况不佳，导致视频下载中断 一致 可能在play()事件触发前 play 触发后，状态是开始播放，但视频并未真正开始播放 一致 一致 waiting play()事件触发后，等待数据 一致 一致 durationchange 获取到视频长度，duration属性能获得真实视频长度 一致 可能在play()事件触发前，可能没有获取到真实的视频长度：可能触发多次， 只有最后一次才能获取到真实的duration，之前的值有可能为0或者1 loadedmetadata play()事件触发后，获取到元数据 一致 play()事件触发前，没有获取到真实的元数据 loadeddata play()事件触发后，获取到媒介数据 一致 play()事件触发前，没有获取到真实的媒介数据 canplay 可以播放，但视频可能还未真正开始播放，并且中途可能因为加载而暂停 一致 一致 playing 视频开始播放 一致 可能还未真正开始播放，并且可能还未获取到视频长度 canplaythrough 视频开始播放后，可以流畅播放 一致 数据可能还没有开始加载，视频可能还未开始播放， 视频仍然会卡住 timeupdate 视频播放后，更新播放进度， 会有明确的进度变化，可以获取到currentTime 一致 第一次可能会有误差，如果 timeupdate事件的currentTime发生变化，代表视频一定开始播放 progress 视频播放后，持续下载， 可以获取到当前的缓存buffer，并且全部下载完毕后不再触发 一致 第一次可能会有误差， 全部下载完毕后依然继续触发 suspend 缓冲中，视频可能卡顿也可能在流畅播放中，全部缓存完毕后不再触发。视频还未真实播放前，pause()事件会触发suspend 一致 一致 pause 可能是响应pause()事件暂停，或者是切出页面自动暂停 一致 一致 seeking 拖动进度条时，寻找播放位置。或者播放完毕，寻找下一个视频 一致 一致 seeked 拖动进度条时，定位到播放位置。或者开始播放下一个视频，或者是从头开始循环播放 一致 一致 error 错误，无法定位错误原因，无法通过paly()事件继续播放 一致 一致 关于X5内核的一些问题 微信内置浏览器的内核： Android：微信6.1版本以上都是使用的QQ浏览器的X5内核。5.4-6.1之间的版本，若用户安装了QQ浏览器就是使用的X5内核，若用户未安装浏览器，使用的是系统内核。 IOS：采用WKWebview或UIWebview内核，从IOS8开始支持WKWebview。 最简单的检测X5内核方法：打开一个网页，然后下拉。页面顶部有【QQ浏览器X5内核提供技术支持】，表明用的是X5内核；没有表示非X5内核。 关闭/禁用/安装X5内核： 微信端打开 http://debugtbs.qq.com，进入X5内核的调试页面。 若未安装X5内核，此链接打不开。已安装，可点击左上方【查看版本号】，如果内核版本信息显示为0的话，就表示X5内核已经被关闭了。 点击【安装线上内核】，在下载或者安装过程中强行关闭微信，就可以禁用X5内核了。 安装X5内核：可以打开https://debugmm.qq.com/?forcex5=true安装 关闭X5内核不会导致微信出问题，甚至会让微信整体更加流畅，因为微信某些原生框架也是需要借助Webview来实现的。 X5内核的视频播放形态： 全屏播放 X5内核视频默认播放形态，用户点击视频区域后开始进入全屏播放，视频区域内的所有事件行为会由X5内核视频组件全权托管。视频层级最高，会遮挡所在区域所有html元素。（仅使用于安卓微信、手机QQ等非安卓QQ浏览器的X5内核场景） 页面内播放 X5内核视频在用户点击后默认会进入全屏播放，前端可以设置video的x5-playsinline属性来将视频限定于网页内部播放 同层页面内播放 同层页面内播放是标准的视频播放形态，在video标签中添加x5-video-player-type：h5-page属性来控制网页内部同层播放，可以在视频上方显示html元素。 X5内核的一些特性： X5内核竖屏播放视频时，横置手机会自动切到横屏全屏播放，但再竖屏时，视频无法切回来。这个是产品策略，需要用户点击全屏上的返回按钮后返回到竖屏。 X5内核不支持多个视频同时播放、不技持视频与音频同时播放 同层全屏形态时不会盖住网页上的html元素；native形态播放器是处于顶层的独立view会遮盖视频区域的其它元素。 x5内核video的currentTime，只有视频开始播放后设置才有效 X5内核的视频播放不支持字幕功能 音视频同步播放 需求背景：同一视频面向不同客户时，根据具体的客户信息，将音轨中的一段内容替换（比如：音轨中的【先生，您好】，替换成具体姓氏【李先生，你好】）。 实现思路： 思路一：服务端根据不同的客户信息，直接处理视频中的音轨。（不可行） 原因：处理速度太慢。以40M的视频为例，视轨、音轨分离 -> 修改音轨 -> 合成视轨、音轨 -> 上传合成后的视频文件，整个流程跑完，大概3分钟。 思路二：将视频拆分成一个没有声音的视频文件和一个音频文件，服务端只对音频文件处理；前端同时播放一个视频和一个音频，并保持两者同步。（可行，需要解决的问题如下） 问题一：安卓微信中不支持同时播放一个视频和一个音频 这是X5内核的限制。目前大多安卓机的微信浏览器采用的是X5内核（可以禁用微信X5内核，但，很显然，我们不可能要求客户这么做。。。）。 解决方法调研： 视频折分成多个小视频，前端串行播放（体验不好） 实现思路：视频折分成多个小视频，服务端只需要处理其中一个小视频，处理速度可以控制在合理范围。 问题：多段视频串行播放，在播放下一个视频时，会有停顿（停在前一视频的海报画面，等待下一视频加载）；播放进度控制问题。 canvas播放视频（不可行） 实现思路：用canvas播放视频代替video元素。 问题：canvas播放视频是通过页面重绘事件或者定时器，不停的抓取video每帧的画面，即，它是依赖video元素的。 适用场景：用于对video的画面进行一此处理，如同步模糊背景、视频截图、灰色视频。 Web audio API播放音频（可行，下一节将详细介绍） 实现思路：用Web audio API代替audio元素。 其他标签代替video、audio （不可行） 实现思路：embed或object代替video、audio元素。embed和object都是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像Java小程序和Flash，PDF这样的插件技术，甚至像视频，SVG和图像的内容！ 问题：embed、object播放视频或音频，类似在页面中嵌入一个包含video或audio元素的iframe。 无法避开不支持音频、视频同时播放的问题 音频控制不方便 播放会出现控制界面。android可以小窗口播放，IOS会占满全屏。 有些属性不可用。比如：embed的starttime 小程序 （暂未调研） 实现思路：取决于小程序是否放开不能同时播放视频和音视的限制。 问题二：视频和音视的同步播放 主要在于三点： 一：视频和音视同时开始播放 视频和音频的加载所需时间不一样，需要等两者都可以播放了，才能真正开始播放。 实现：在canplay事件标识视频、音频是否可播，再通过定时器轮询，监听两者都可播放时，再触发播放。 注意：部分机型，需要【用户主动操作】才能播放视频，直接在定时器中调用play()方法可能无效。解决方法是：在点击时，先触发一次播放，再在定时器中加暂停或播放的判断。 二：拖动进度条后，保持视频和音视同步 拖动进度条后，改变currentTime的值，也会引起视频和音频的加载所需时间不一样的问题，而此时无法通过canplay事件解决，因为IOS在currentTime改变后不会触发canplay事件。 这时，我们可以用seeked事件监听视频、音频是否加载完成。 canplay、seeked事件的兼容情况（实测：一台IOS机、一台android机）： 事件 IOS app IOS WeChat android app android wechat canplay（开始播放） 触发 触发 触发 触发 canplay（改currentTime后） 不触发 不触发 触发 触发 seeked 触发 触发 触发 触发 三：视频和音视不同步，纠正时差 正常来说，第一次播放、拖动进度条后的播放都是两者加载完成后同时播放的，视、音频应该不会出现时差。然而，现实是残酷的，部分机型还是出现了时差，有时还可能偏差几十秒（具体原因未知）。 这时，我们需要一个定时器实时监听两者的时差。当两者时差超过某个阈值时（如：0.5s），纠正音频的currentTime值。 问题三：无音轨视频文件的问题 部分IOS手机播放无音轨视频，需要等待很长时间才会开始播放（android、pc chrome无此问题）。 以40M的视频为例：无音轨的视频，必需等视频加载30多M（约20~30秒，跟网速有关）后，才开始播放；而同一视频，保留音轨（不需要声音，可以将音量调为0），加载1M~2M就可以开始播放。原因未知 Web Audio API 安卓微信（采用X5内核）不支持同时播放一个视频和一个音频，即，video、audio不能同时播放。调研发现，web audio api可以控制音频，可以替代audio，且它与video可以同时播放。 简单示例 const URL = 'path/music.mp3' const audioContext = new (window.AudioContext || window.webkitAudioContext)() //加载音频文件 const getBuffer = function (url) { const request = new XMLHttpRequest(); return new Promise((resolve, reject) => { request.open('GET', url, true); request.responseType = 'arraybuffer'; request.onload = () => { audioContext.decodeAudioData(request.response, buffer => buffer ? resolve(buffer) : reject('decoding error')); }; request.onerror = error => reject(error); request.send(); }); }; const playAudio = function (buffer) { const source = audioContext.createBufferSource(); source.buffer = buffer; source.connect(audioContext.destination); source.start(); }; const buffer = await getBuffer(URL); buffer && playAudio(buffer) 一些问题： currentTime：不是当前音频播放的时间节点，而是当前时间 - 音频上下文创建时间点的时长。 如何修改音量、设置静音？？（按标准文档中的方法试了，有问题） 有些浏览器限制，页面最多只能同时存在6个音频上下文，即最多可以new AudioContext()6次。可用音频上下文的close()方法，及时关闭无用的音频上下文。 https://github.com/otalk/hark/issues/38 部分机型（如：乐视 android 6.0），app端无法正常播放（微信端正常）。原因是：decodeAudioData方法无法解码音频数据。 部分机型（如：vivo X7 android 5.1.1），不支持Howler插件。 Howler是一款web audio api的封装插件。 兼容问题 视频、音频的播放\\暂停行为 切出应用 -> 再切换回来、锁屏 -> 解屏，video、audio、web audio api的播放/暂停行为不一致，体现在不同系统（IOS、Android）、不同应用（微信、保险师）中，如： 切出微信时，video会自动停止播放，而audio仍在播放。当然，并不是所有机型都如此，Android中腾讯X5浏览器处理的就比较完善，在切出后台时，video、audio会停止播放并且切回页面后自动续播。 切换出应用，部分机型中web audio api不会停止播放，即使在visibilitychange事件，调用stop方法也无法停止。 切换回应用，部分机型（如：华为 P30 android 9）中，video自动续播，web audio api不会。 解决方法： 对于切出微信，audio不停止播放的问题，可以在visibilitychange事件中，调用pause方法来暂停。 浏览器标签页被隐藏或显示的时候会触发 visibilitychange事件，可以通过Document.visibilityState 只读属性来获取当前标签页在浏览器中的激活状态： document.addEventListener(\"visibilitychange\", e => { //用户离开了当前页面 if (document.visibilityState === 'hidden') { video.pause() } // 用户打开或回到页面 if (document.visibilityState === 'visible') {} //或者 if (e.target.hidden) {} }) 另外，对于切换回应用，video、audio、web audio api的播放/暂停行为不一致，可以考虑在visibilitychange事件中，document.visibilityState === 'visible'时，刷新页面或更新音、视频模块。 其他属性、事件的兼容问题 canplay、canplaythrought事件 IOS在加载时不会触发这两个方法，即使preload=\"auto\"也没用，需要播放后才会触发。readyState也是播放后，才能取到值的。而Android、PC端Chrome是会在加载阶段就触发这两个事件。 修改video的currentTime值，android会触发canplay事件，但IOS不会。 loadedmetadata事件 安卓微信（华为 meta 8）：取回的duration\\videoWidth\\videoHeight值为0。 解决方法：在timeupdateg事件中获取duration\\videoWidth\\videoHeight值 muted属性 部分安卓机（如：华为 meta 8）的微信中：video标签中写了muted属性后，通示Js切换muted的值，无效。 解决方法：video标签不设置muted属性，在页面初始化时，用Js对muted赋值。 volume属性 IOS中无法通过volume属性修改视频音量，直接写在video标签或者js修改都不行。 poster属性 在不同设备上表现不同，浏览器没问题，但是微信浏览器和IOS可能会显示空白。 解决方案一 ：自定义一个div，将封面放在div中，然后div盖在video的上面。 解决方案二：通过canvas截取视频第一帧作为默认显示的图片。 function cut () { let canvas = document.createElement(\"canvas\"); canvas.width = video.videoWidth * scale; canvas.height = video.videoHeight * scale; canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height); let img = document.createElement(\"img\"); img.src = canvas.toDataURL(\"image/png\"); Dom.appendChild(img); }; video.addEventListener('loadeddata',cut) 安卓手机的一些问题： 视频播放结束后，可能会有广告弹出 解决方法：在视频播放完成事件中添加，先播放视频再暂停视频即可 let isiOS = !!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/) let video = document.getElementById('video'); video.addEventListener('ended', () => { if (!isiOS) { video.play(); setTimeout(() => { video.pause(); }, 100) } } Android微信端（如：小米 10），局域播放状态下，有【全屏】按钮 这个是X5做了video劫持的结果，目前解决方法（网上搜索答案）： 成为腾讯的合作伙伴 将视频的 width撑大，如：width: 120%；然后再用 object-position 将画面通过计算居中显示，两边裁剪 参考链接 MDN video 视频H5 video标签最佳实践 iOS 10 Safari 视频播放新政策 video标签在不同平台上的事件表现差异分析 video在安卓与ios实际应用中遇到的问题及解决 腾讯-H5同层播放器接入规范 腾讯-X5内核视频之问答汇总 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:15:10 "},"html探索系列/07-HTML布局的几种方式.html":{"url":"html探索系列/07-HTML布局的几种方式.html","title":"HTML布局的几种方式","keywords":"","body":"HTML布局的几种方式 Web 页面布局是指文本、图像、以及块元素在页面上的呈现方式。 从传统的静态布局到目前主流的响应式布局，随着 Web 的发展，布局变得越来越复杂，实现方式也更加多样化。 本文简单讲述了各种布局的定义，并从页面元素的布局和大小的角度，描述各种布局方式之间的差异。特别要注意，响应式布局与其他布局方式不同，它是一种布局的设计，而不是某种具体的实现方式，是一系列技术的统称。 静态布局（px布局） 传统 Web 布局，网页上的所有元素一律使用 px 作为单位。 布局特点： 任何屏幕分辨率下，页面元素的布局和大小都不会变化，网页始终按照最初写代码时的布局来显示。 设计方法（常规PC端）： 页面内容居中布局，所有样式使用绝对宽度/高度（px）。如果屏幕宽度小于页面内容宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景。 设计方法（移动端，会改变元素大小）： 在 viewport meta 标签上设置 width=320，页面的各个元素也采用 px 作为单位。通过用 Js 动态修改标签的initial-scale 使得页面等比缩放，从而刚好占满整个屏幕。 设在 viewport meta 标签上设置 content=width=640,user-scalable=no，页面的各个元素也采用 px 作为单位。由于 640px 超出了手机宽度，浏览器会自动缩小页面至刚好全屏。 优点： 对设计师和 CSS 编写者来说都是最简单的，亦没有兼容性问题。 缺点： 显而易见，即不能根据用户的屏幕尺寸做出不同的表现。 流式布局（百分比布局） 流式布局是使用百分数（搭配min-、max-属性使用）为单位定义元素的宽度。页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。 布局特点： 屏幕分辨率变化时，页面元素的大小会变化但布局不变。 设计方法： 使用百分比定义宽度，高度大都还是用 px。宽度往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。 缺点： 宽度会按照屏幕进行适配调整，但高度不会。**如果屏幕尺寸相对其原始设计过大或过小，对用户体验并不是特别好。因为在过大或过小屏幕下，有些页面元素的宽度也可能过大或者过小，和固定大小的高度、文字显得非常不协调。 自适应布局（@media布局） 用 @media 为不同的屏幕分辨率定义布局，即创建多个静态布局， 每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（即，元素布局会发生变化），但在每个静态布局中，页面元素大小不随窗口大小的调整发生变化。 布局特点： 屏幕分辨率变化时，页面元素的布局会变化但大小不变。 设计方法： 使用 @media + min-width、min-height 给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。 缺点： 媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高；要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。 响应式布局（综合布局） 响应式布局不是单独的技术，它是描述 Web 设计的一种方式、一组最佳的实践，其目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的 Web 浏览器等等）都能显示出令人满意的效果。 响应式布局不是指具体的某种布局方式，它通常是糅合了 流式布局 + 自适应布局 + rem/em/flex/vw/vh 等各种技术来实现的。通常可以认为：用 @media 为不同的屏幕分辨率定义布局，每个布局可以使用流式布局、弹性布局（下方会提到）、vw/vh 单位等技术来实现。 响应式布局几乎已经成为优秀页面布局的标准。 布局特点： 屏幕分辨率变化时，页面元素的布局和大小都会变化。 设计方法： 通常使用 @media 为不同屏幕分辨率定义不同布局，用流式布局、flex、grid 配合相对布局单位进行布局，也可以用其他任何有助于为单一网页在不同设备呈现更好画面的技术和实现。 优点： 适应 PC 和移动端，如果足够耐心，效果完美。 缺点： 各种屏幕分辨率不同的设备越来越多，开发和测试的工作量不小，设计稿也需要多个版本。 弹性布局 弹性布局的概念并不确定，已知的三种说法：一是指 rem/em 布局；二是指 flex 布局；还有一种说法是，弹性布局只是一种实现响应式布局的一部分，不应该单独归为一种布局形式。 rem/em 布局 使用 rem/em 单位进行相对布局。rem 是相对于 html 节点（即根节点）字体大小的单位，em 是相对于父节点字体大小的单位，它们随着字体大小的变化而变化。与百分比相比，rem/em 更加灵活，它们能适应缩进、字体大小、padding、margin 以及元素宽高等情况。 布局特点： 元素采用 em/rem 为单位，在不同屏幕分辨率下，页面元素的大小会等比例缩放但布局不变。 设计方法： 由于 em 为单位，在元素多层嵌套后，其最终计算出来的值比较难控制。所以，一般使用 rem 为单位进行弹性布局，rem 是相对 html 节点的字体大小（即 1rem = html 节点的字体大小，浏览器一般默认为 16px）的单位。页面元素使用 rem 为单位，当 html 节点的字体大小变化时，元素也会自动缩放。 实际应用中，可以根据屏幕尺寸的不同，用 Js 修改 html 节点的字体大小： // 以 375px 为基准，根据屏幕宽度调整根节点 fontSize，最大不超过32px。 document.documentElement.style.fontSize = `${Math.min(16 * document.documentElement.clientWidth / 375, 32)}px` 优点： 理想状态是所有屏幕的高宽比和最初的设计高宽比一样，或者相差不多，完美适应。 缺点： 最终计算出来的值可能带有小数，在某些情况下可能引起一些 Bug。 flex 布局 目前比较流行的一种布局，使用传统布局难以实现一些复杂的布局，使用 flex 布局实现就变得非常容易。 优点： 简便、完整、响应式地实现各种页面布局。 缺点： 部分浏览器不支持（如：IE10以下）；适用于元素布局，元素大小的响应还需另外处理。 常见问题 响应式与自适应布局有什么区别？ 自适应： 当屏幕尺寸变小时，内容的布局会发生变化，比如由一行展示变为分行展示。而内容的大小，宽高不会随着尺寸变化而实时改变。 响应式： 当屏幕尺寸变小时，内容的布局会发生变化，比如由一行展示变为分行展示。而内容的大小，也会随着尺寸变化而实时变化。 vw 和 vh 是什么？ vw 和 vh 是视口单位。所谓视口，就是根据你浏览器窗口的大小的单位，不受显示器分辨率的影响。 vw 是相对于视窗的宽度，视窗宽度是100vw，1vw = 可视窗口的宽度的百分之一。 vh 是相对于视窗的高度，视窗高度是100vh，1vh = 可视窗口的高度的百分之一。 vmin 是指 vw 和 vh 中最小的那个。 vmax 是指 vw 和 vh 中最大的那个。 vw + vh + rem 可以帮助实现完美的响应式布局。 如何选择布局方式？ 如果只做 PC 端，那么静态布局（定宽度）是最好的选择； 如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局是最好的选择； 如果 PC、移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-12-12 11:54:53 "},"html探索系列/_关于html.html":{"url":"html探索系列/_关于html.html","title":" 关于Html","keywords":"","body":"关于HTML HTML（Hyper Text Markup Language），即超文本标记语言，是一种使用结构化 Web 网页及其内容的标记语言。就其核心而言， HTML 是一种相当简单的、由不同元素组成的标记语言，它可以应用于文本片段，使文本在文档中具有不同的含义（段落、列表、表格），将文档结构化为逻辑块（头部、主要内容、导航栏），并且可以将图片、影像等内容嵌入到页面中。 HTML常用标记： HTML 文档本身是一种文本文件，其内容由信息和为信息指定的标记符组成，通过专用的浏览器来识别，并将这些 HTML 文件 “翻译” 成可以识别的信息，即现在所见到的网页内容（如：文字如何处理、画面如何安排、图片如何显示等）。此外，也可以引入其它文件，用来描述一个网页的表现（如 CSS）或行为（如 JavaScript）等。 网页标题 这是一段文本 超文本是一种组织信息的方式，它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，或是地理位置相距遥远的某台计算机上的文件。 HTML的诞生 HTML 是由 Web 的发明者 Tim Berners-Lee 和同事 Daniel W. Connolly 于 1990 年创立的一种标记语言，它是标准通用化标记语言 SGML 的应用。用 HTML 编写的超文本文档称为 HTML 文档，它能独立于各种操作系统平台（如 UNIX、Windows等）。 自 1990 年以来，HTML 就一直被用作万维网的信息表示语言，使用 HTML 描述的文件需要通过 Web 浏览器显示出效果。HTML 是一种建立网页文件的语言，通过标记式的指令（Tag），将影像、声音、图片、文字动画、影视等内容显示出来。 HTML发展史 HTML 是用来标记 Web 信息如何展示以及其他特性的一种语法规则，是基于更古老一些的语言 SGML 定义，并简化了其中的语言元素。 HTML 历史上有如下版本： HTML 1.0：在 1993 年 6 月作为互联网工程工作小组（IETF）工作草案发布； HTML 2.0：1995 年 11 月作为 RFC 1866 发布，于 2000 年 6 月发布之后被宣布已经过时； HTML 3.2：1997 年 1 月 14 日，W3C 推荐标准； HTML 4.0：1997 年 12 月 18 日，W3C 推荐标准； HTML 4.01（微小改进）：1999 年 12 月 24 日，W3C 推荐标准； HTML 5：HTML5 是公认的下一代 Web 语言，极大地提升了 Web 在富媒体、富内容和富应用等方面的能力，被喻为终将改变移动互联网的重要推手。Internet Explorer 8 及以前的版本不支持。 指南与教程 MDN HTML（超文本标记语言） w3school HTML 教程 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-03-05 21:59:18 "},"js探索系列/05-Canvas基础入门篇.html":{"url":"js探索系列/05-Canvas基础入门篇.html","title":"Canvas基础入门篇","keywords":"","body":"Canvas基础入门篇 Canvas API 提供了一个通过 JavaScript 和 HTML 的 canvas 元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。 Canvas API 主要聚焦于2D图形。而同样使用 canvas 元素的 WebGL API 则用于绘制硬件加速的 2D 和 3D 图形。 获取渲染上下文(2D环境) 除一些过时的浏览器不支持 canvas 元素外，所有的新版本主流浏览器都支持它。Canvas 的默认大小为 300px X 150px。但是，可以使用 HTML 的高度和宽度属性来自定义 Canvas 的尺寸。为了在 Canvas 上绘制图形，先使用一个 JavaScript 上下文对象，它能动态创建图像。 注意： CSS 中的 width、height 控制的是画布在文档中的宽高，当宽度比例与 canvas 属性中定义的宽度不一致时，会拉伸 Canvas 元素，相当于把固定的图片拉伸了。 const canvas = document.getElementById(\"canvas_base\") const context = canvas.getContext(\"2d\") function getContext2D () { return new Promise((resolve, reject) => { const canvas = document.getElementById(\"canvas_base\") const context = canvas.getContext(\"2d\") if (context) { resolve(context) } else { reject() } }) } 状态的保存和恢复 Canvas 是基于状态的绘制，包括：当前应用的变形、当前的裁切路径、以及以下属性： strokeStyle fillStyle globalAlpha lineWidth lineCap lineJoin miterLimit lineDashOffset shadowOffsetX shadowOffsetY shadowBlur shadowColor globalCompositeOperation font textAlign textBaseline direction imageSmoothingEnabled Canvas 可通过以下方法管理状态： save()：保存画布的所有状态 restore()：save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 Canvas 状态存储在栈中，每当 save() 方法被调用后，当前的状态就被推送到栈中保存。 从线条开始 移动画笔： context.moveTo(x, y) 这句代码的意思是移动画笔至(x, y)这个点（单位是px）。记住，这里是以 canvas 画布的左上角为笛卡尔坐标系的原点，且y轴的正方向向下，x轴的正方向向右。 笔画停点： context.lineTo(x, y) 这句的意思是从上一笔的停止点绘制到(x, y)这里。不过要清楚，这里的 moveTo()、lineTo() 都只是状态而已，是规划，是我准备要画，还没有开始画，只是一个计划而已！ 选择画笔： context.lineWidth = 2 // 设置画笔(线条)的粗细为2px context.fillStyle = \"#0dd\" // 设置或返回用于填充绘画的颜色、渐变或模式 context.strokeStyle = \"#0dd\" // 设置或返回用于笔触的颜色、渐变或模式 Canvas是基于状态的绘制，所以我们在选择画笔粗细和颜色的同时，其实也是选择了线条的粗细和颜色。 确定绘制： 确定绘制只有两种方法，fill() 和 stroke() ，前者是指填充，后者是指描边。 // 绘制线条：青色 function drawLine (context) { context.moveTo(100, 100) context.lineTo(300, 200) context.lineWidth = 2 context.strokeStyle = \"#0dd\" context.stroke() } // 绘制折线：粉红 -> 深蓝 function drawBrokenLine (context) { context.lineWidth = 2 context.moveTo(100, 100) context.lineTo(300, 300) context.strokeStyle = \"#d0d\" context.stroke() context.moveTo(300, 300) context.lineTo(100, 500) context.strokeStyle = \"#00d\" context.stroke() } getContext2D().then(context => { drawLine(context) drawBrokenLine(context) }) 查看DEMO 期待绘制结果：第一条线是青色，第二条线是粉红色，第三条线是深蓝。 然而，最终绘制结果：三条线都是深蓝色。这里的原因就是前面强调——Canvas是基于状态的绘制。 什么意思呢？就是说每当状态发生改变，Canvas 会重新渲染。 从上面示例来说：每次使用 stroke() 时，它都会把之前设置的状态再绘制一遍。如，第一次 stroke() 时，绘制一条青色的折线；第二次 stroke() 时，会再重新绘制之前的那条青色的折线，但是这个时候的画笔已经被更换成粉红色的了，所以画出的折线全是粉红色的；第三次 stroke() 同理，画笔更换成了深蓝色，所以最终三条线都是深蓝！ 实际上，这里看到的三条折线，其实绘制了 3 次，一共绘制了 6 条折线。 创建新路径： beginPath() 是 Canvas 2D API 通过清空子路径列表开始一个新路径的方法。 在每次绘制之前加上 beginPath() ，表示下次绘制的起始处为 beginPath() 之后的代码。beginPath() 设置的绘制状态的作用域结束于 stroke()、fill() 或者 closePath() 方法。 function drawMultBrokenLine (context) { context.lineWidth = 2 context.beginPath() context.moveTo(100, 100) context.lineTo(300, 200) context.strokeStyle = \"#0dd\" context.stroke() context.beginPath() context.moveTo(100, 100) context.lineTo(300, 300) context.strokeStyle = \"#d0d\" context.stroke() context.beginPath() context.moveTo(300, 300) context.lineTo(100, 500) context.strokeStyle = \"#00d\" context.stroke() } 查看DEMO 线条属性概述： lineCap 属性定义上下文中线的端点，可以有以下 3 个值： butt：默认值，端点是垂直于线段边缘的平直边缘。 round：端点是在线段边缘处以线宽为直径的半圆。 square：端点是在选段边缘处以线宽为长、以一半线宽为宽的矩形。 lineJoin 属性定义两条线相交产生的拐角，可将其称为连接。在连接处创建一个填充三角形，可以使用 lineJoin 设置它的基本属性。 miter：默认值，在连接处边缘延长相接。miterLimit 是角长和线宽所允许的最大比例(默认是 10)。 bevel：连接处是一个对角线斜角。 round：连接处是一个圆。 lineWidth 属性定义线的宽度（默认值为 1.0）。 strokeStyle 属性定义线和形状边框的颜色和样式。 填充颜色 基本颜色： context.fillStyle = \"red\" context.fillStyle = \"#FF0000\" context.fillStyle = \"#F00\" context.fillStyle = \"rgb(255,0,0)\" context.fillStyle = \"rgba(255,0,0,1)\" context.fillStyle = \"hsl(0,100%,50%)\" context.fillStyle = \"hsla(0,100%,50%,1)\" 线性渐变： const gradient = context.createLinearGradient(x0,y0,x1,y1) // x0 渐变开始点的 x 坐标 // y0 渐变开始点的 y 坐标 // x1 渐变结束点的 x 坐标 // y1 渐变结束点的 y 坐标 gradient.addColorStop(stop, color) // stop 介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。 // color 在结束位置显示的 CSS 颜色值 function createLinearGradient (context) { context.rect(100, 100, 300, 300); let grd = context.createLinearGradient(100, 100, 300, 300) grd.addColorStop(0, \"#dd0\") grd.addColorStop(0.5, \"#fd0\") grd.addColorStop(1, \"#0dd\") context.fillStyle = grd context.fill() } 查看DEMO 径向渐变： const gradient = context.createRadialGradient(x0,y0,r0,x1,y1,r1) // x0 渐变的开始圆的 x 坐标 // y0 渐变的开始圆的 y 坐标 // r0 开始圆的半径 // x1 渐变的结束圆的 x 坐标 // y1 渐变的结束圆的 y 坐标 // r1 结束圆的半径 gradient.addColorStop(stop, color) // stop 介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。 // color 在结束位置显示的 CSS 颜色值 function createRadialGradient (context) { let grd = context.createRadialGradient(75, 50, 5, 90, 60, 100) grd.addColorStop(0, \"#0aa\") grd.addColorStop(1, \"white\") context.fillStyle = grd context.fillRect(10, 10, 300, 300) } 查看DEMO 填充纹理： 纹理其实就是图案的重复，填充图案通过 createPattern() 函数进行初始化。 context.createPattern(image,\"repeat|repeat-x|repeat-y|no-repeat\") // 第一个参数：Image对象、canvas对象、video对象 // 平面上重复：repeat; // x轴上重复：repeat-x; // y轴上重复：repeat-y; // 不使用重复：no-repeat; function createPattern (context) { let canvas = document.createElement(\"canvas\") let context2 = canvas.getContext('2d') canvas.width = 200 canvas.height = 200 let img = new Image() img.src = \"./img/pins_3338674420.jpg\" img.onload = function() { context2.drawImage(img, 0, 0, 200, 200) let pattern = context.createPattern(canvas, 'no-repeat') context.fillStyle = pattern context.fillRect(0, 0, 500, 500) context.lineWidth = 1 context.strokeStyle = '#0dd' context.strokeRect(0, 0, 500, 500) } } 查看DEMO 绘制矩形 context.rect(x,y,width,height)/ context.fillRect(x,y,width,height) context.strokeRect(x,y,width,height) context.clearRect(x,y,width,height) // x 矩形左上角的 x 坐标 // y 矩形左上角的 y 坐标 // width 矩形的宽度，以像素计 // height 矩形的高度，以像素计 绘制标准圆弧 context.arc(x,y,r,sAngle,eAngle,counterclockwise); // x 圆的中心的 x 坐标。 // y 圆的中心的 y 坐标。 // r 圆的半径。 // sAngle 起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。 // eAngle 结束角，以弧度计。 // counterclockwise 可选。规定应该逆时针还是顺时针绘图。False = 顺时针(默认)，true = 逆时针。 context.arcTo(x1,y1,x2,y2,r); // x1 弧的起点的 x 坐标 // y1 弧的起点的 y 坐标 // x2 弧的终点的 x 坐标 // y2 弧的终点的 y 坐标 // r 弧的半径 function drawArc (context) { context.beginPath() context.lineWidth = 1 context.strokeStyle = '#0dd' context.arc(100, 75, 100, 0, (120 / 180) * Math.PI, false) context.stroke() } 查看DEMO function drawArcTo (context) { context.beginPath() context.lineWidth = 1 context.strokeStyle = '#0dd' context.moveTo(20, 20) context.lineTo(100, 20) context.arcTo(150, 20, 150, 70,50) context.lineTo(150, 100) context.stroke() } 查看DEMO 贝塞尔曲线 二次贝塞尔曲线 context.quadraticCurveTo(cpx,cpy,x,y); // cpx 贝塞尔控制点的 x 坐标 // cpy 贝塞尔控制点的 y 坐标 // x 结束点的 x 坐标 // y 结束点的 y 坐标 二次贝塞尔曲线需要两个点。第一个点是用于二次贝塞尔计算中的控制点，第二个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点 function drawQuadraticCurveTo (context) { context.lineWidth = 1 context.strokeStyle = '#0dd' context.beginPath() context.moveTo(20, 20) context.quadraticCurveTo(20, 100, 200, 20) context.stroke() } 查看DEMO 三次贝塞尔曲线 context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); // cp1x 第一个贝塞尔控制点的 x 坐标 // cp1y 第一个贝塞尔控制点的 y 坐标 // cp2x 第二个贝塞尔控制点的 x 坐标 // cp2y 第二个贝塞尔控制点的 y 坐标 // x 结束点的 x 坐标 // y 结束点的 y 坐标 三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 文本设置 font // 设置或返回文本内容的当前字体属性 textAlign // 设置或返回文本内容的当前对齐方式 textBaseline // 设置或返回在绘制文本时使用的当前文本基线 context.font = \"[font-style] [font-variant] [font-weight] [font-size/line-height] [font-family]\" // font-style // 规定字体样式：normal\\italic\\oblique // font-variant // 规定字体变体：normal\\small-caps // font-weight // 规定字体的粗细：normal\\bold\\bolder\\lighter\\100~900 // font-size/line-height // 规定字号和行高，以像素计。 // font-family // 规定字体系列。 context.textAlign = \"center|end|left|right|start\" // 默认。 文本在指定的位置开始。 // end 文本在指定的位置结束。 // center 文本的中心被放置在指定的位置。 // left 文本左对齐。 // right 文本右对齐。 context.textBaseline = \"alphabetic|top|hanging|middle|ideographic|bottom\" // alphabetic 默认。文本基线是普通的字母基线。 // top 文本基线是 em 方框的顶端。。 // hanging 文本基线是悬挂基线。 // middle 文本基线是 em 方框的正中。 // ideographic 文本基线是表意基线。 // bottom 文本基线是 em 方框的底端。 fillText() // 在画布上绘制“被填充的”文本 strokeText() // 在画布上绘制文本（无填充） measureText() // 返回包含指定文本宽度的对象 context.fillText(text,x,y,maxWidth) context.strokeText(text,x,y,maxWidth) // text 规定在画布上输出的文本。 // x 开始绘制文本的 x 坐标位置（相对于画布）。 // y 开始绘制文本的 y 坐标位置（相对于画布）。 // maxWidth 可选。允许的最大文本宽度，以像素计。 function drawText (context) { context.fillStyle = \"#0aa\" context.strokeStyle = \"#0aa\" context.font = \"normal normal bold 30px/150px Times\" context.textAlign = \"center\" context.textBaseline = \"middle\" context.fillText(\"Hello Canvas\", 200, 250) context.strokeText(\"width:\" + context.measureText(\"Hello Canvas\").width, 200, 300, 200) } 查看DEMO 变换设置 context.scale(scalewidth,scaleheight); // scalewidth 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) // scaleheight 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.) context.rotate(angle); // angle 旋转角度，以弧度计。 // 如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。 // 举例：如需旋转 5 度，可规定下面的公式：5*Math.PI/180。 context.translate(x,y); // x 添加到水平坐标（x）上的值 // y 添加到垂直坐标（y）上的值 对于缩放变换有两点问题需要注意： 1.缩放时，图像左上角坐标的位置也会对应缩放 2.缩放时，图像线条的粗细也会对应缩放 context.transform(a,b,c,d,e,f); context.setTransform(a,b,c,d,e,f); // a 水平缩放(1) // b 水平倾斜(0) // c 垂直倾斜(0) // d 垂直缩放(1) // e 水平位移(0) // f 垂直位移(0) // 平移变换： x’ = x + dx， y’ = y + dy。 // 也即是说可以使用 context.transform (1,0,0,1,dx,dy)代替context.translate(dx,dy)。 // 同理可以使用 context.transform(sx,0,0,sy,0,0)代替context.scale(sx, sy); // 也可以使用context.transform(0,sy,sx,0,0,0); // context.transform(Math.cos(θ*Math.PI/180)，Math.sin(θ*Math.PI/180), -Math.sin(θ*Math.PI/180),Math.cos(θ*Math.PI/180)，0，0）可以替代context.rotate(θ)。 // 也可以使用 context.transform(-Math.sin(θ*Math.PI/180),Math.cos(θ*Math.PI/180)， Math.cos(θ*Math.PI/180)，Math.sin(θ*Math.PI/180)，0，0）替代。 // 区别：transform()变换是指在上一次变换的状态基础上再次变换；setTransform()变换是指先重置到最初始的状态再开始变换。 function transform (context) { context.save() context.fillStyle = \"#0aa\" context.scale(1, 0.5) context.rotate(10 * Math.PI / 180) context.translate(20, 0) context.fillRect(0, 0, 150, 150) console.log('scale') context.restore() //transform context.save() context.translate(100, 0) context.fillStyle = \"yellow\" context.fillRect(0, 0, 150, 100) context.transform(1, 0.5, -0.5, 1, 30, 10) context.fillStyle = \"red\" context.fillRect(0, 0, 150, 100) context.transform(1, 0.5, -0.5, 1, 30, 10) context.fillStyle = \"blue\" context.fillRect(0, 0, 150, 100) context.restore() //setTransform context.save() context.translate(400, 0) context.fillStyle = \"yellow\" context.fillRect(0, 0, 150, 100) context.setTransform(1, 0.5, -0.5, 1, 100, 0) context.fillStyle = \"red\" context.fillRect(0, 0, 150, 100) context.setTransform(1, 0.5, -0.5, 1, 100, 0) context.fillStyle = \"blue\" context.fillRect(0, 0, 150, 100) context.restore() } 查看DEMO 注意保存和恢复Canvas状态 变换只会影响 transform() 等方法调用之后的绘图 裁剪区域 clip() 方法来实现 Canvas 的图像裁剪功能。该方法使用路径来对Canvas画布设置一个裁剪区域。因此，必须先创建好路径。创建完整后，调用 clip() 方法来设置裁剪区域。 需要注意的是裁剪是对画布进行的，裁切后的画布不能恢复到原来的大小，也就是说画布是越切越小的，要想保证最后仍然能在canvas最初定义的大小下绘图需要注意 save() 和 restore() 。画布是先裁切完了再进行绘图。并不一定非要是图片，路径也可以放进去~。 function setClip (context) { context.save() context.beginPath() context.fillStyle = '#0aa' context.arc(100, 100, 100, 2 * Math.PI, false) context.clip() let img = new Image() img.src = require(\"@/assets/image/01eb485e44bf8fa8012165187fa336.jpg@1280w_1l_2o_100sh.jpg\") img.onload = function() { context.drawImage(img, 0, 0, 350, 250) context.closePath() context.restore() context.beginPath() context.moveTo(100, 100) context.lineTo(300, 100) context.strokeStyle = '#0aa' context.stroke() context.closePath() } } 查看DEMO 绘制图像 Canvas 更有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面等等。浏览器支持的任意格式的外部图片都可以使用，比如 PNG、GIF、JPEG。 你甚至可以将同一个页面中其他 Canvas 元素生成的图片作为图片源。 Canvas 的 API 可以使用下面这些类型中的一种作为图片的源： HTMLImageElement：Image() 函数构造出来的，或者任何的 img 元素。 HTMLVideoElement： video 元素作为图片源，可以从视频中抓取当前帧作为一个图像。 HTMLCanvasElement：可以使用另一个 Canvas 元素作为图片源。 ImageBitmap：一个高性能的位图。 这些源统一由 CanvasImageSource 类型来引用。 context.drawImage(img,x,y) context.drawImage(img,x,y,width,height) context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height) // img 规定要使用的图像、画布或视频。 // sx 可选。开始剪切的 x 坐标位置。 // sy 可选。开始剪切的 y 坐标位置。 // swidth 可选。被剪切图像的宽度。 // sheight 可选。被剪切图像的高度。 // x 在画布上放置图像的 x 坐标位置。 // y 在画布上放置图像的 y 坐标位置。 // width 可选。要使用的图像的宽度。（伸展或缩小图像） // height 可选。要使用的图像的高度。（伸展或缩小图像） function drawImage (context) { let img = new Image() img.src = \"./img/pins_3338674420.jpg\" img.onload = function() { // context.drawImage(img, 0, 0, 500, 500, 0, 0, window.innerWidth, window.innerHeight) context.drawImage(img, 0, 0, 350, 250) } } 查看DEMO 非零环绕原则与奇偶原则 我们一般使用Canvas的fill方法时，是直接进行填充路径。其实fill方法有两个参数可选：nonzero | evenodd。nonzero - 非零环绕原则，也是默认值；evenodd - 奇偶原则。 非零环绕原则nonzero 是用来判断哪些区域属于路径内( 计算结果非0，即为路径内 )。 * 在路径包围的区域中，随便找一点，向外发射一条射线， * 和所有围绕它的边相交， * 然后开启一个计数器，从0计数， * 如果这个射线遇到顺时针围绕，那么+1， * 如果遇到逆时针围绕，那么-1， * 如果最终值非0，则这块区域在路径内。结果为0，代表这块区域不要填充，否则，必须填充 奇偶原则 * 在路径包围的区域中，随便找一点，向外发射一条射线， * 和所有围绕它的边相交， * 查看相交线的个数，如果为奇数，就填充，如果是偶数，就不填充 drawCircular (context) { context.shadowColor = \"#545454\"; context.shadowOffsetX = 5; context.shadowOffsetY = 5; context.shadowBlur = 2; context.globalCompositeOperation = 'source-over' context.fillStyle = \"#00AAAA\" context.arc(200, 200, 100, 0, Math.PI * 2 ,false) context.arc(200, 200, 115, 0, Math.PI * 2 ,true) context.fill() } 查看DEMO 其他属性 阴影设置： shadowColor // 设置或返回用于阴影的颜色 shadowBlur // 设置或返回用于阴影的模糊级别 shadowOffsetX // 设置或返回阴影距形状的水平距离 shadowOffsetY // 设置或返回阴影距形状的垂直距离 需要注意的是，这里的阴影同其他属性设置一样，都是基于状态的设置。因此，如果只想为某一个对象应用阴影而不是全局阴影，需要在下次绘制前重置阴影的这四个属性。 全局透明： globalAlpha // 默认值为1.0，代表完全不透明，取值范围是0.0（完全透明）~1.0。这个属性与阴影设置是一样的，如果不想针对全局设置不透明度，就得在下次绘制前重置globalAlpha。 橡皮擦： context.clearRect(x,y,w,h) // 清空指定矩形上的画布上的像素。它接受四个参数，和其他绘制矩形的方法一样 检测点： isPointInPath 用于判断在当前路径中是否包含检测点的方法。 isPointInPath(x, y) isPointInPath(x, y, fillRule) isPointInPath(path, x, y) isPointInPath(path, x, y, fillRule) /* x：检测点的 X 坐标 y：检测点的 Y 坐标 fillRule：用来决定点在路径内还是在路径外的算法，允许的值： nonzero - 非零环绕规则，默认的规则 evenodd - 奇偶环绕原则 path：Path2D 应用的路径 */ 绘制圆角矩形 function roundRect (ctx, x, y, w, h, r) { var min_size = Math.min(w, h); if (r > min_size / 2){ r = min_size / 2 } ctx.beginPath() ctx.moveTo(x + r, y) ctx.arcTo(x + w, y, x + w, y + h, r) ctx.arcTo(x + w, y + h, x, y + h, r) ctx.arcTo(x, y + h, x, y, r) ctx.arcTo(x, y, x + w, y, r) ctx.closePath() } 查看DEMO 绘制圆角图片 function drawRoundImg (ctx, x, y, w, h, r) { ctx.save(); let img = new Image() img.src = \"./img/pins_3338674420.jpg\" img.onload = function() { roundRect(ctx, x, y, w, h, r) ctx.clip(); ctx.drawImage(img, x, y, w, h) ctx.restore() } } function drawRoundImg2 (ctx, x, y, w, h, r) { ctx.save(); let img = new Image() img.src = \"./img/pins_3338674420.jpg\" img.onload = function() { let pattern = ctx.createPattern(img, \"no-repeat\"); roundRect(ctx, x, y, w, h, r) ctx.fillStyle = pattern ctx.fill() } } 查看DEMO 圆角图片1 查看DEMO 圆角图片2 参考链接 Canvas API中文文档首页地图 MDN - canvas 原生HTML5 Canvas 参考API文档 canvas © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-04-08 18:04:53 "},"js探索系列/06-SVG基础入门篇.html":{"url":"js探索系列/06-SVG基础入门篇.html","title":"SVG基础入门篇","keywords":"","body":"SVG基础入门篇 可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述二维的矢量图形，基于 XML 的标记语言。作为一个基于文本的开放网络标准，SVG能够优雅而简洁地渲染不同大小的图形，并和 CSS，DOM，JavaScript 和 SMIL 等其他网络标准无缝衔接。本质上，SVG 相对于图像，就好比 HTML 相对于文本。 和传统的点阵图像模式，像 JPEG 和 PNG 不同，SVG 格式提供的是矢量图，这意味着它的图像能够被无限放大而不失真或降低质量，并且可以方便地修改内容。 SVG 是由万维网联盟（W3C）自 1999 年开始开发的开放标准。 SVG 是指可伸缩矢量图形 SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或缩小（改变尺寸）的情况下，其图形质量不会受受损失 SVG 是 W3C 的一个标准 SVG 有哪些优缺点 与其他图像格式相比，使用 SVG 的优势在于： SVG 是矢量格式，可呈现任何大小而不降低其质量 SVG 支持静止或动态图像 SVG 支持透明度 SVG 可被非常多的工具读取和修改（比如：代码或文本编辑器） SVG 可以从 Adobe Illustrator 或 Sketch 等设计软件中导出 SVG 是由于基于文本的格式，是可搜索的（很适合制作地图） SVG 是开放的标准。现代浏览器支持 SVG 格式，并且面向未来 SVG 文件是纯粹的 XML SVG 格式具有高度可压缩性和轻量级 SVG 也有一些缺点： 设计 SVG 可能会变得复杂 在某些版本过低的浏览器上无法呈现 电子邮件客户端支持有限 SVG 的效率可能会不如 PNG 好。因为它需要运行时的计算和对应平台的渲染绘制。 渲染效果不一致。不同的浏览器乃至不同的平台的抗锯齿处理千差万别，尤其是用户关掉抗锯齿的情况下，多边形（边数较多）图标会惨不忍睹。 浏览器中如何使用SVG元素 注意：在外部文件引入的 SVG 必须与原始文件同源 要在浏览器中显示（前提是浏览器支持），可以通过几种方法来实现： HTML 元素引入 SVG 文件 使用 iframe 元素来嵌入SVG图像 使用 img 元素来嵌入SVG图像 引入DEMO 在 CSS 样式中使用 SVG 来对HTML内容应用图像效果 将 SVG 图像作为背景图像嵌入 div { background: url(img/snowman.svg) no-repeat center; background-size : 300px 200px; } 现代浏览器支持在 CSS 样式中使用 SVG 来对 HTML 内容应用图像效果。 你可以在同一文件中使用 SVG 样式，也可以通过外部样式表引入。有三个属性可以使用： mask、clip-path、filter。 ... ... ... .target { mask: url(#mask-1); clip-path: url(#clipping-path-1); filter:url(#f1); } .target2 { /*使用外部引用*/ clip-path: url(resources.svg#c1); } 将 SVG 直接嵌套在 HTML 中 直接使用 svg 元素，通过代码将SVG图像嵌入到HTML代码中。 ... 直接嵌套DEMO 使用 embed、object 元素来嵌入SVG图像。(不推荐使用) SVG 文档基本结构 一个独立的SVG文件，也就是平时看到的以扩展名 .svg 结尾的文件。一个简单的SVG图形例子： XML声明：和HTML文档的DTD声明是类似的。 --> version=\"1.0\" 和 encoding=\"utf-8\" 无论如何都是默认值。 standalone 属性 规定此 SVG 文件是否是\"独立的\"，或含有对外部文件的引用。standalone=\"no\" 意味着 SVG 文档会引用一个外部文件。 svg 根元素包括一个用来描述 SVG 的 XML 声明空间。 --> 嵌入 HTML5 文档中的 SVG 不应具有独立的 XML 声明。在格式良好的XML中只允许使用一个XML声明，并且如果有，它必须位于顶部。而通过 html5 img 或 css background-images 引用的 SVG 必须有自己的 XML 声明。 几个重要的 SVG 概念 1.viewport 视口，表示 SVG 可见区域的大小，或者可以想象成画布大小（与 canvas 的画布概念相似）。SVG 中超出视窗边界的区域会被裁切并且隐藏。 2.viewBox 属性 viewBox 是 “视区盒子” 的意思，即，创建一个可伸展的盒子，用以承载一组图形。当 viewBox 的大小与 viewport 不一致时，盒子会自动伸缩（与 preserveAspectRatio 属性有关）。 viewBox=\"min-x, min-y, width and height\" viewBox 大小，默认是与 viewport 相同。不允许宽度和高度为负值，0则禁用元素的呈现。 viewBox属性DEMO 如上所示，viewBox 的大小是 40 * 30，viewport 的大小是 400 * 300。实现渲染时，会将 viewBox 放大 10 倍。 有 marker、pattern、svg、symbol、view 等五个 svg 元素可以有这个属性。 3.preserveAspectRatio属性 有时候，通常我们使用 viewBox 属性时，希望图形拉伸占据整个视口。 在其他情况下，为了保持图形的长宽比，必须使用统一的缩放比例。preserveAspectRatio 属性表示是否强制进行统一缩放。 对于支持该属性的所有元素，除了 image 元素之外，preserveAspectRatio 只适用于元素上 viewBox 值的元素，如果元素没有提供属性 viewBox ，则忽略了preserveAspectRatio。 preserveAspectRatio=\" \" align：表示是否强制统一缩放。当 SVG 的 viewbox 属性与视图属性宽高比不一致时使用。默认值 xMidYMid ，即，居中。 align 属性的值一定是下列的值之一： none：不会进行强制统一缩放。注意： 如果 align 的值是 none ，则 meetOrSlice 属性的值将会被忽略。 xMinYMin： 强制统一缩放。viewbox 与 viewport X方向左对齐、Y 方向上对齐。 xMidYMin：强制统一缩放。viewbox 与 viewport X方向居中、Y 方向上对齐。 xMaxYMin：强制统一缩放。viewbox 与 viewport X方向居右、Y 方向上对齐。 xMinYMid： 强制统一缩放。viewbox 与 viewport X方向左对齐、Y 方向居中。 xMidYMid (默认值) ：强制统一缩放。viewbox 与 viewport X方向、Y 方向都居中。 xMaxYMid：强制统一缩放。viewbox 与 viewport X方向右对齐、Y 方向居中。 xMinYMax：强制统一缩放。viewbox 与 viewport X方向左对齐、Y 方向下对齐。 xMidYMax：强制统一缩放。viewbox 与 viewport X方向居中、Y 方向下对齐。 xMaxYMax：强制统一缩放。viewbox 与 viewport X方向右对齐、Y 方向下对齐。 meetOrSlice：可选。默认值 meet，即图形将缩放到。 meet：默认值。这种情况下，宽高比将会被保留，尽可能的放大 SVG 的 viewbox，但要确保整个 viewbox 在视图窗口内是可见的。 slice： 这种情况下，宽高比将会被保留，尽可能的放大 SVG 的 viewbox，并且要确保宽、高都覆盖整个视图窗口。 none：扭曲纵横比以充分适应viewport SVG 中的坐标系统 SVG 的坐标系统分为三种类型： 初始坐标系统 转换坐标系统 嵌套坐标系统 初始坐标系统 初始视窗坐标系是一个建立在视窗（viewport）上的坐标系。原点(0,0)在视窗的左上角，X轴正向指向右，Y轴正向指向下，初始坐标系中的一个单位等于视窗中的一个”像素”（更确切的说是一个单位）。 初始用户坐标系 是通过 VIEWBOX 建立在 SVG 画布上的坐标系。这个坐标系一开始和初始视窗坐标系完全一样-它自己的原点位于视窗左上角，x 轴正向指向右，y 轴正向指向下。 转换坐标系统 可以使用 transform 属性来对元素的坐标系统进行变换。transform 属性的作用对象是元素所在的坐标系统，而不是元素本身。 在 SVG 规范中，transform 属性的作用是 在被添加的元素上建立新用户空间坐标系（当前坐标系） (效果与 viewBox 类似)。 它和 CSS 中 transform 属性的变换函数，都是基于坐标系变换的。它们的区别在于：HTML 元素的坐标系建立在元素自身上，而 SVG中，元素坐标系是基于是 初始坐标系 或 当前用户空间坐标系 创建的 。 svg 元素有多个变换时，下一个变换的坐标系是基于上一个变换完成后的坐标系创建的，并且其子元素变换的坐标系，也是基于父元素变换后的坐标系创建的。 嵌套坐标系统 在 svg 元素中可以嵌套 svg 元素。外面的 svg 创建一个 Viewport 和坐标系统，而且嵌套在里面的 svg 也可以创建一个 Viewport 和坐标系统。 如果你不声明子 SVG 的 x 和 y 属性，它们默认是 0。如果你不声明 height 和 width 属性，svg 会是父 SVG 宽度和高度的 100%。 除了可以通过嵌套 svg 外，也可以使用例如 use、symbol 的元素来建立新的 viewport 和用户坐标系。 SVG 的基本组成元素 一个简单的 SVG 文档由 svg 根元素和基本的形状元素构成。另外还有一个 g 元素，它用来把若干个基本形状编成一个组。 从这些开始，SVG 可以变得更加复杂。SVG 支持渐变、旋转、动画、滤镜效果、与 JavaScript 交互等等功能，但是所有这些额外的语言特性，都需要在一个定义好的图形区域内实现。 1.line元素（直线） line 元素是一个 SVG 基本形状，用来创建一条连接两个点的线。 x1：起点x坐标 y1：起点y坐标 x2：终点x坐标 y2：终点y坐标 line元素DEMO 2.rect元素（矩形） rect 元素是 SVG 的一个基本形状，用来创建矩形，基于一个角位置以及它的宽和高。它还可以用来创建圆角矩形。 x：左上角x坐标 y：左上角y坐标 width：宽度 height：高度 rx：x方向的圆角半径 ry：y方向的圆角半径 rect元素DEMO 3.circle元素 (圆) circle 元素是一个 SVG 的基本形状，用来创建圆,基于一个圆心和一个半径。 cx：圆心x坐标 xy：圆心y坐标 r：半径 circle元素DEMO 4.ellipse元素（椭圆） ellipse 元素是一个 SVG 基本形状，用来创建一个椭圆，基于一个中心坐标以及它们的 x 半径和 y 半径。 cx：圆心x坐标 cy：圆心y坐标c rx：x方向半径 ry：y方向半径 ellipse元素DEMO 5.polygon元素 (闭合多边形) polygon 元素是由连接一组点集的直线构成。polygon 的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形。 potins：定义了用来画一个 polygon 元素或 polyline 元素的点的数列。每个点用用户坐标系统中的一个 X 坐标和 Y 坐标定义。用逗号分开每个点。 polygon元素DEMO 6.polyline元素 (折线) polyline 元素是 SVG 的一个基本形状，用来创建一系列直线连接多个点。典型的一个 polyline 是用来创建一个开放的形状，最后一点不与第一点相连。 polyline元素DEMO 7.image元素（图片） 允许在一个 SVG 对象内部呈现光栅图像。它表现为图像文件或者其他 SVG 文件。SVG 图像格式转换软件支持 JPEG、PNG 格式，是否支持动图 GIF 不明确。 x：图像水平方向上到原点的距离 y：图像竖直方向上到原点的距离 width：图像宽度。和 HTML 的 img 不同，该属性是必须的 height：图像高度。和 HTML 的 img 不同，该属性是必须的 xlink:href：图像的 URL 指向 preserveAspectRatio：控制图像比例 image元素DEMO 如果你没有设置 x 属性或 y 属性，它们自动被设置为 0 如果你没有设置 height 属性或 width 属性，它们自动被设置为 0 如果 width 属性或 height 等于0，将不会呈现这个图像 8.textPath（文本） text 元素定义了一个由文字组成的图形。 注意：我们可以将渐变、图案、剪切路径、遮罩或者滤镜应用到 text 上。 x、y：在用户坐标系统中标识了一个 x 轴、y 轴坐标。 dx、dy：一个元素或其内容在 x 轴、y 轴方向上的偏移，偏移量取决于设置该属性的元素。 text-anchor：用来描述该文本与所给点的对齐方式 (开头、中间、末尾对齐) 。取值：start | middle | end。 rotate：指定动画元素沿 animateMotion 元素中指定的路径行进时如何旋转。取值： auto| auto-reverse| number。 textLength：指定文本将绘制到的空间的宽度。 lengthAdjust：控制文本如何拉伸到该 textLength 属性定义的长度。取值：spacing | spacingAndGlyphs。 9.textPath元素（文本路径） 除了笔直地绘制一行文字以外， SVG 也可以根据 path 元素的形状来放置文字。 只要在 textPath 元素内部放置文本，并通过其 xlink:href 属性值引用 path 元素，我们就可以让文字块呈现在 path 元素给定的路径上了。 startOffset：将路径转换为 textPath 元素的坐标系后，该属性定义了沿路径的初始当前文本位置相对于路径起点的偏移量。 method：指示应沿着 textPath 元素路径呈现文本的方法。取值：align|stretch。 spacing：指示用户代理应如何确定要沿路径呈现的印刷字符之间的间距。 xlink:href：将对资源的引用定义为引用IRI。该链接的确切含义取决于使用它的每个元素的上下文。 君子之交淡如水，茶人之交醇如茶。 君子之交淡如水，茶人之交醇如茶。 君子之交淡如水，茶人之交醇如茶。 君子之交淡如水，茶人之交醇如茶。 textPath元素DEMO 10.pattern元素（图案） 使用预定义的图形对一个对象进行填充或描边，就要用到 pattern 元素。pattern 元素让预定义图形能够以固定间隔在 x 轴和 y 轴上重复（或平铺）从而覆盖要涂色的区域。先使用 pattern 元素定义图案，然后在给定的图形元素上用属性 fill 或属性 stroke 引用用来填充或描边的图案。 patternUnits：指示将哪个坐标系用于 pattern 元素的几何属性。 patternContentUnits：指示要用于 pattern 元素内容的坐标系。 patternTransform：定义应用于图案的变换定义列表。 x、y：在用户坐标系统中标识了一个x 轴、y 轴坐标。 width、height：在用户坐标系统中标识了一个水平长度、垂直长度。 xlink:href：将对资源的引用定义为引用IRI。该链接的确切含义取决于使用它的每个元素的上下文。 preserveAspectRatio：表示是否强制进行统一缩放。 pattern元素DEMO SVG 中的路径 path 可能是SVG中最常见的形状。你可以用 path 元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线。 路径可以被填充、描边或者用于剪裁其他元素。 d：一个字符串，包含了一系列路径描述。可以使用不同的指令，移动到一个新的点，然后绘制不同的直线和曲线。 注意：指令字母大写表示坐标位置是绝对坐标，指令字母小写表示坐标位置是相对坐标。x、y坐标之间可以用空格或逗号隔开。 以下用 path 元素，绘制上个 polyline 元素 示例： path元素DEMO 1.直线指令 这里有五种不同的直线指令，你可以使用它们来创建路径。 moveto(M 或 m)：移动到新的位置 lineto(L 或 l)：从当前坐标画一条直线到一个新坐标 horizontal lineto(H 或 h)：画一条水平线到新坐标。只带一个参数，标明在 x 轴移动到的位置 vertical lineto(V 或 v)：画一条垂直线到新坐标。只带一个参数，标明在 y 轴移动到的位置 closepath(Z 或 z)：关闭当前路径。它是最简单的命令，而且不带有任何参数。Z 或 z，两种写法作用都一样 注意：指令的参数用空格或逗号隔开，多个指令之间不需要隔开。 d=\"M10 10L50 50L75 175L175 150L175 50L225 75L225 150L300 150\" d=\"M10,10 L50,50 L75,175 L175,150 L175,50 L225,75 L225,150 L300,150\" 注意：实际应用中使用指令字母即可。指令字母大写表示坐标位置是绝对位置，指令字母小写表示坐标位置时相对位置。 直线指令DEMO 2.曲线指令 绘制平滑曲线的命令有三个，其中两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说是圆的一部分： Curveto: 三次贝塞尔曲线指令 (C, c, S, s)，需要一个初始点的控制点和一个结束点的控制点，还有一个结束点。 C (or c) x1,y1 x2,y2 x,y S (or c) x2,y2 x,y x1、y1 是曲线起点的控制点坐标 x2、y2 是曲线终点的控制点坐标 x、y 是曲线的终点坐标。（曲线的起点是上一条指令的终点） Curveto：二次贝塞尔曲线指令 (Q, q, T, t)，只需要一个控制点，同时作为起点控制点和终点控制点。 Q (or q) x1,y1 x,y T (or t) x1,y1 x,y x1、y1 是曲线起点和终点的控制点坐标 x、y 是曲线的终点坐标 曲线指令DEMO 为了连缀平滑的贝塞尔曲线，还可以使用 T 和 S 命令。它们的语法比别的 Curveto 命令简单。因为它假定第一个控制点是前一个控制点关于前一个点的反射（即，关于前一个点对称），或者说如果没有前一个控制点的话它实际上就是前一个点。 Arcto：椭圆弧线 (A, a)，用于绘制一段椭圆片段。若 rx 和 ry 的值相同，则绘制出圆。 A (or a) rx ry xAxisRotate large-arc-flag sweep-flag x y rx、ry：弧线在 x 轴、y 轴方向的半径 xAxisRotate：与 x 轴夹角的度数 large-arc-flag：0 或 1，用来确定是要画小弧（0）还是画大弧（1） sweep-flag：0 或 1，用来确定弧是顺时针方向（1）还是逆时针方向（0） x、y：弧线的终点 椭圆弧线指令DEMO SVG 中的其他元素 SVG 中的标记（Marker） marker 元素定义了在特定的 path、line、polyline、polygon 元素上绘制的箭头或者多边标记图形。 markerUnits： refX、refY：定义元素参考点的x、y坐标 markerWidth、markerHeight：定义 marker元素的宽度、高度。 orient：指示将标记放置在形状上的位置时如何旋转标记。 marker-start、marker-mid、marker-end 这三个 CSS 属性会将标记分别放置在路径的开始、中间和结束位置。 可以设置markerUnits=”strokeWidth” 使得标记进行缩放来适应路径描边的大小 标记DEMO SVG 中的clipPath SVG 剪裁路径是指根据指定的路径或形状来剪裁 SVG 图形。应用了剪裁路径的图形，在剪裁路径内部的图形可以被显示出来，在剪裁路径之外的图形会被隐藏。 你可以使用任何图形来作为剪裁路径或者被剪裁的对象。可以是文字、圆形、椭圆、多边形或自定义路径。 clipPath DEMO SVG DEFS元素、SYMBOL元素和USE元素 defs 元素：用于预定义一个元素使其能够在 SVG 图像中重复使用。在 defs 元素中定义的图形元素不会直接呈现。 symbol 元素：用于定义可重复使用的符号。 symbol 能够创建自己的视窗，所以能够应用 viewBox 和 preserveAspectRatio 属性。 use 元素：可以在SVG图像中多次重用一个预定义的SVG图形，包括 元素和元素。use 元素可以引入在 defs 元素中定义的图形。 出于安全原因，一些浏览器可能在use元素上应用同源策略，还有可能拒绝载入xlink:href属性内的跨源URI。 defs-symbol-use DEMO SVG元素的样式属性 SVG 元素不同于普通的 HTML 元素，具有特殊的一些样式属性。这些属性的声明可以通过SVG元素属性的方式直接声明，也可以通过 CSS样式表中进行声明。 语法和在 html 里使用 CSS 一样，只不过你要把 background-color、border 改成 fill 和 stroke。 注意，不是所有的属性都能用 CSS 来设置。上色和填充的部分一般是可以用 CSS 来设置的，比如fill，stroke，stroke-dasharray等，但是不包括下面会提到的渐变和图案等功能。另外，width、height，以及路径的命令等等，都不能用css设置。判断它们能不能用CSS设置还是比较容易的。 SVG 规范将属性区分成 properties 和其他 attributes，前者是可以用CSS设置的，后者不能。 以下是一些 CSS2 规范之中未定义的，SVG 独有的部分样式属性： fill：元素的填充颜色 fill-opacity：元素的填充颜色透明度 stroke：元素的笔画颜色 stroke-width：元素的笔画宽度 stroke-linecap：定义元素顶点样式 stroke-dasharray：虚线样式虚线长度 stroke-dashoffset：虚线样式的偏移长度 stroke-linejoin：定义元素之间的连接点的形状 stroke-opacity：元素的笔画颜色透明度 我们可以通过以下方法引用样式属性： 使用属性来添加CSS样式。 使用 STYLE 属性。 使用内联样式表。 这种使用内联样式表的工作方式和在HTML元素上使用内联样式表是完全相同的。样式可以定义在 svg 元素外，也可以定义在 svg 元素内。 .class_name2 { stroke: #0aa; fill: #a0a; } 使用外部样式表来添加CSS样式。 SVG 中的渐变效果 SVG 可以创建和并在填充和描边上应用渐变色。 有两种类型的渐变：线性渐变和径向渐变。你必须给渐变内容指定一个id属性，否则文档内的其他元素就不能引用它。为了让渐变能被重复使用，渐变内容需要定义在 defs 标签内部，而不是定义在形状上面。 线性渐变 线性渐变沿着直线改变颜色，要插入一个线性渐变，你需要在 SVG 文件的 defs 元素内部，创建一个 linearGradient 元素。 gradientUnits：定义用于在渐变元素上指定的属性的坐标系。取值：userSpaceOnUse 、objectBoundingBox，默认值为objectBoundingBox。objectBoundingBox 用百分比表示相对于当前SVG视口的值。userSpaceOnUse 使用绝对单元。 gradientTransform：定义从渐变坐标系到目标坐标系的转换。 x1、y1、x2、y2：起点的和结束点的坐标。用于定义渐变的方向和范围。 spreadMethod：确定如何填充超出定义的渐变边的形状。 pad（默认值）：该值表示渐变的最终颜色填充了超出渐变边缘的形状。 reflect：此值表示渐变超过其边缘反向重复。 repeat：此值指定渐变以原始顺序重复其边缘。 xlink:href：引入其他 linearGradient 元素 线性渐变DEMO 可以在 stop 元素中定义，stop-color 、stop-opacity 、fill 属性，也可以定义在 css 中： linearGradient 元素还需要一些其他的属性值，它们指定了渐变的大小和出现范围。渐变的方向可以通过两个点来控制，它们分别是属性x1、x2、y1和y2，这些属性定义了渐变路线走向。 可以在渐变上使用 xlink:href 属性，使一个渐变的属性和颜色中值（stop）可以被另一个渐变包含引用。 径向渐变 径向渐变与线性渐变相似，只是它是从一个点开始发散绘制渐变。创建径向渐变需要在文档的 defs 中添加一个 radialGradient 元素。 cx、cy：中心点的 x、y 轴坐标。 r：定义圆的半径 fx、fy：定义径向渐变的焦点的 x、y 轴坐标。如果该属性没有被定义，就假定它与中心点是同一位置。 fr：定义径向渐变的焦点的半径。若该属性没有被定义，默认值为 0%。 径向渐变DEMO SVG 中的SMIL动画 SMIL 是 Synchronized Multimedia Integration Language（同步多媒体集成语言）的首字母缩写简称。SMIL 开发组和 SVG 开发组合作开发了 SMIL 动画规范，在规范中制定了一个基本的 XML 动画特征集合。SVG 吸收了 SMIL 动画规范当中的动画优点，并提供了一些 SVG 继承实现。 SMIL允许你做下面这些事情： 动画元素的数值属性（X, Y, …） 动画属性变换（平移或旋转） 动画颜色属性 沿着运动路径运动 不论使用 4 个动画元素中的哪一个，你都需要为它指定一个动画目标。可以使用 xlink:href 属性来指定动画目标。这个属性指向将要执行动画的元素。这个元素必须在当前的 SVG 文档中。动画元素也可以嵌套在 SVG 元素中。如果没有为动画元素指定 xlink:href 属性，那么动画的目标元素就是当前动画元素的直接父元素。 SVG 五大动画元素 set元素 此元素没有动画效果。可以实现基本的延迟功能。即，可以在特定时间之后修改某个属性值（也可以是 CSS 属性值） SVG set元素DEMO animate元素 基础动画元素。实现单属性的动画过渡效果。类似于 CSS3 中的 transition 属性 SVG animate元素DEMO animateTransform 实现 transform 变换动画效果的。 SVG animateTransform元素DEMO animateMotion元素 可以让 SVG 图形沿着特定的 path 路径运动。 SVG animateMotion元素DEMO 与使用 CSS 动画的区别 SVG 元素可以像 HTML 元素一样，使用 CSS keyframes 和 animation 属性或者 CSS transitions 来制作各种动画效果。大多数情况下，一个复杂的动画效果需要组合多种变换效果：旋转、倾斜、缩放以及他们的转换和过渡效果。 多数情况下，SVG元素和HTML元素在使用 transform 和 transform-origin上是相同的。但它们之间也有不同之处: SVG 元素不能使用 box model 来管理，因此，它没有margin、padding、border或content boxes。 默认情况下，一个 HTML 元素的 transform 原点位于该元素的 (50%, 50%) 的地方，这里是元素的中心点。与之不同，SVG 元素的 transform 原点位于当前用户坐标系统的原点上，这个点是画布的左上角位置 SVG 动画的参数详解 attributeName属性 动画属性的名称 可以是元素直接暴露的属性，例如，对于本文反复出现的「马」对应的text元素上的 x, y或者 font-size; 可以是CSS属性。例如，透明度 opacity。 attributeType属性 动画属性的可选值：CSS | XML | auto。 attributeType 支持三个固定参数，CSS、XML、auto。用来表明 attributeName 属性值的列表。x、y 以及 transform 就属于 XML, opacity就属于 CSS。 auto 为默认值，自动判别的意思。 from, to, by, values 类似于CSS3中的关键帧定义。 from：动画的起始值,缺省默认值 to：指定动画的结束值 by：动画的相对变化值 values：用分号分隔的一个或多个值，可以看出是动画的多个关键值点 SVG begin, end 可选值包括： time-value：表示具体的时间值。常见单位有 h | min | s | ms，默认单位为 s 。时间值还支持 hh:mm:ss 这种写法，因此，90s 我们也可以使用 01:30 表示。 offset-value：表示偏移值，数值前面有 + 或 -。 应该指相对于 document 的 begin 值而言。 syncbase-value：基于同步确定的值。语法为：[元素的id].begin/end +/- 时间值。 就是说借用其他元素的 begin 值再加加减减，这个可以准确实现两个独立元素的动画级联效果。 event-value：这个表示与事件相关联的值。类似于 PowerPoint 动画的“点击执行该动画”。语法是： [元素的id].[事件类型] +/- 时间值。 repeat-value：指某动画重复多少次结束之后开始执行动画。语法为： [元素的id].repeat(整数) +/- 时间值。 accessKey-value：定义快捷键。即按下某个按键动画开始。语法为：accessKey(character)。 character 表示快捷键所在的字符。 wallclock-sync-value：指真实世界的时钟时间定义。时间语法是基于在 ISO8601 中定义的语法。 indefinite：表示“无限等待”。需要 beginElement() 方法触发或者指向该动画元素的超链接(SVG中的a元素)。 dur 该属性标识了动画的简单持续时间。常规时间值：clock-value | indefinite。 指定简单持续时间的时长。值必须大于0。可以用小时（h）、分钟（m）、秒（s）、毫秒（ms）表达这个值。可以组合这些时间表达式以提供一个复合的持续时间，比如这样：hh:mm:ss.iii 或者这样：mm:ss.iii。 如果一个动画元素不带有 dur 属性，简单持续时间就是无限期的。 calcMode、keyTimes、 keySplines calcMode 属性支持4个值：discrete | linear | paced | spline。 discrete: from 值直接跳到 to 值。类似于step(1, end)。 linear: animateMotion元素以外元素的calcMode默认值。动画从头到尾的速率都是一致的。 paced: 通过插值让动画的变化步调平稳均匀。仅支持线性数值区域内的属性，这样点之间“距离”的概念才能被计算（如 position, width, height等）。如果paced指定，任何 keyTimes 或 keySplines值将会失效。 spline: 插值定义贝塞尔曲线。spline点的定义在keyTimes属性中，每个时间间隔控制点由keySplines定义。 keyTimes： 是关键时间点的意思。一个以分号分隔的时间值列表，用于控制动画的执行步骤。列表中的每个值与 values 中的值一一对应，定义了 values 中的值在动画中何时执行，keyTimes 列表中的每一个值都是指定在[0-1]之间的浮点数，表示动画的完成时间。 前面提到过 values 也是多值，这里有一些约定的规则：首先，keyTimes 值的数目要和 values 一致，如果是 from/to/by 动画，keyTimes 就必须有两个值。然后对于 linear 和 spline 动画，第一个数字要是0, 最后一个是1。 最后，每个连续的时间值必须比它前面的值大或者相等。 repeatCount, repeatDur repeatCount 表示动画执行次数，可以是合法数值或者 indefinite （动画循环到电脑死机）。 repeatDur 定义重复动画的总时间。可以是普通时间值或者 indefinite（动画循环到电脑死机）。 fill 表示动画间隙的填充方式。支持参数有：freeze | remove。其中remove是默认值，表示动画结束直接回到开始的地方。freeze 表示动画结束后像是被冻住了，元素保持了动画结束之后的状态。 accumulate, additive accumulate 是累积的意思。支持参数有：none | sum。 默认值是 none 。如果值是 sum 表示动画结束时候的位置作为下次动画的起始位置。 additive 控制动画是否附加。支持参数有：replace | sum. 默认值是 replace 。如果值是 sum 表示动画的基础知识会附加到其他低优先级的动画上， restart restart控制重新开启动画的规则。支持的参数有：always | whenNotActive | never. always 是默认值，表示总是，也就是点一次圈圈，马儿跑一下。 whenNotActive 表示动画正在进行的时候，是不能重启动画的。 never 表示动画是一波流。 SVG 与 Javascript 当 SVG 嵌入到 HTML 页面的时候，你可以使用 Javascript 来操作 SVG 元素，就像操作其他 HTML 元素一样。 通过 ID 或 class 获取 SVG 元素 可以读取/修改 SVG 元素的属性值 可以读取/修改 SVG 元素的 css 属性值 可以给 SVG 元素及其子元素添加事件监听 动画的暂停与播放 // svg指当前svg DOM元素 svg.pauseAnimations(); // 暂停 svg.unpauseAnimations(); // 重启动 相关链接 SVG元素在移动H5页面动画的应用 SVG 动画精髓 MDN SVG MDN SVG教程 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:14:36 "},"js探索系列/_关于Javascript.html":{"url":"js探索系列/_关于Javascript.html","title":" 关于Javascript","keywords":"","body":"关于Javascript JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”，指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序的“脚本”。 JavaScript 是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。 JavaScript 是一种具有函数优先的轻量级、解释型或即时编译型的编程语言。它作为开发 Web 页面的脚本语言而出名的，但它也被用到了很多非浏览器环境中，例如 Node.js、 Apache CouchDB 和 Adobe Acrobat。 从语法角度看，JavaScript 语言是一种“对象模型”语言。各种宿主环境通过这个模型，描述自己的功能和操作接口，从而通过 JavaScript 控制这些功能。但是，JavaScript 并不是纯粹的“面向对象语言”，是一种基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 JavaScript 的标准是 ECMAScript 。截至 2012 年，所有的现代浏览器都完整的支持 ECMAScript 5.1，旧版本的浏览器至少支持 ECMAScript 3 标准。2015 年 6 月17日，ECMA 国际组织发布了 ECMAScript 的第六版，该版本正式名称为 ECMAScript 2015，但通常被称为 ECMAScript 6 或者 ES6。自此，ECMAScript 每年发布一次新标准。 Javascript的历史 JavaScript 因为互联网而生，紧随着浏览器的出现而问世。 1994年12月，Navigator 发布了1.0 版，市场份额一举超过90%。Netscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。 1995年，Netscape 公司雇佣 Brendan Eich 开发这种网页脚本语言。 Brendan Eich 只用了10天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源： 基本语法：借鉴 C 语言和 Java 语言。 数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。 函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。 原型继承模型：借鉴 Self 语言（Smalltalk的一种变种）。 正则表达式：借鉴Perl语言。 字符串和数组处理：借鉴Python语言。 随后在 1996 年初，JavaScript 首先被应用于 Netscape 2 浏览器上。最初的 JavaScript 名为 LiveScript，但是因为一个糟糕的营销策略而被重新命名，该策略企图利用 Sun Microsystem 的 Java 语言的流行性，将它的名字从最初的 LiveScript 更改为 JavaScript——尽管两者之间并没有什么共同点。这便是之后混淆产生的根源。 几个月后，Microsoft 随 IE 3 发布推出了一个与之基本兼容的语言 JScript。又过了几个月，Netscape 将 JavaScript 提交至 Ecma International（一个欧洲标准化组织）， ECMAScript 标准第一版便在 1997 年诞生了，随后在 1999 年以 ECMAScript 第三版的形式进行了更新，从那之后这个标准没有发生过大的改动。 由于委员会在语言特性的讨论上发生分歧，ECMAScript 第四版尚未推出便被废除，但随后于 2009 年 12 月发布的 ECMAScript 第五版引入了第四版草案加入的许多特性。 第六版标准已经于 2015 年 6 月发布。 Javascript的特性 与大多数编程语言不同，JavaScript 没有输入或输出的概念。它是一个在宿主环境下运行的脚本语言，任何与外界沟通的机制都是由宿主环境提供的。 浏览器是最常见的宿主环境，但在非常多的其他程序中也包含 JavaScript 解释器，如 Adobe Acrobat、Adobe Photoshop、SVG 图像、Yahoo! 的 Widget 引擎，Node.js 之类的服务器端环境，NoSQL 数据库（如开源的 Apache CouchDB）、嵌入式计算机，以及包括 GNOME （注：GNU/Linux 上最流行的 GUI 之一）在内的桌面环境等等。 Javascript概览 JavaScript 是一种多范式的动态语言，它包含类型、运算符、标准内置（ built-in）对象和方法。它的语法来源于 Java 和 C，所以这两种语言的许多语法特性同样适用于 JavaScript。 JavaScript 通过原型链而不是类来支持面向对象编程。JavaScript 同样支持函数式编程——因为它们也是对象，函数也可以被保存在变量中，并且像其他对象一样被传递。 JavaScript 中的类型包括： Number（数字） String（字符串） Boolean（布尔） Function（函数） Object（对象） null（空） undefined（未定义） Symbol（ES2015 新增） 此外还有 Array（数组）类型，以及分别用于表示日期和正则表达式的 Date（日期）和 RegExp（正则表达式），这三种类型都是特殊的 Object。严格意义上说，Function（函数）也是一种特殊的 Object。 JavaScript 还有一种内置的 Error（错误）类型。 JavaScript的版本 1997年7月，ECMAScript 1.0 发布。 1998年6月，ECMAScript 2.0 版发布。 1999年12月，ECMAScript 3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。 2007年10月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，预计次年 8 月发布正式版本。草案发布后，由于 4.0 版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。 2009年12月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。第六版发布以后，将指 ECMAScript 7。TC39预计，ECMAScript 5 会在2013年的年中成为JavaScript开发的主流标准，并在此后五年中一直保持这个位置。 2011年6月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1 版的全部功能。 2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。 2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。 2015年6月，ECMAScript 6 正式发布，并且更名为 “ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScirpt 的版本，下一个版本在 2016 年发布，称为“ECMAScript 2016”。 JavaScript 与 ECMAScript 的关系 1996年8月，微软模仿 JavaScript 开发了一种相近的语言，取名为 JScript（JavaScript 是 Netscape 的注册商标，微软不能用），首先内置于IE 3.0。Netscape公司面临丧失浏览器脚本语言的主导权的局面。 1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的 39 号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共25个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。 1997年7月，ECMA 组织发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。 ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如DOM 的标准就是由 W3C 组织（World Wide Web Consortium）制定的。 ECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。 JavaScript与Java的关系 JavaScript 和 Java 是两种不一样的语言，但是它们之间存在联系。 JavaScript 的基本语法和对象体系，是模仿 Java 而设计的。但是，JavaScript 没有采用 Java 的静态类型。正是因为 JavaScript 与 Java 有很大的相似性，所以这门语言才从一开始的 LiveScript 改名为 JavaScript。基本上，JavaScript 这个名字的原意是“很像 Java 的脚本语言”。 在 JavaScript 语言中，函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与Java 语法最大的两点区别。JavaScript 语法要比 Java 自由得多。 另外，Java 语言需要编译，而 JavaScript 语言则是运行时由解释器直接执行。 总之，JavaScript 的原始设计目标是一种小型的、简单的动态语言，与 Java 有足够的相似性，使得使用者（尤其是 Java 程序员）可以快速上手。 指南与教程 MDN JavaScript 阮一峰 JavaScript 标准参考教程（alpha） © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-07-23 11:31:00 "},"research/01-极细边框（1px边框）实现方式.html":{"url":"research/01-极细边框（1px边框）实现方式.html","title":"极细边框（1px边框）实现方式","keywords":"","body":"极细边框（1px边框）实现方式 移动端 web开发遇到的问题：UI稿上要求设置边框为1px，css设置border: 1px solid #eee;之后，UI又说边框太粗了。 这是因为devicePixelRatio特性导致。css设置的1px是css像素，而UI稿上指的是设备像素，它们之间存在一个比例关系，即，devicePixelRatio。iPhone的devicePixelRatio == 2，而border-width: 1px描述的是css像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。 像素基本概念（术语） device pixel / physical pixel （设置像素、物理像素、硬件像素）： 显示屏中最小的物理单元。 移动设备出厂时，不同设备自带的不同像素，每个像素点根据操作系统的指示设置自己的颜色和亮度。 density-independent pixel(DIP)（设备无关像素或密度无关像素）：可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统转换为物理像素。 CSS pixel （css 像素）：浏览器使用的抽象单元，用于精确地，一致地在网页上绘制内容。 通常，CSS 像素被称为与设备无关的像素（DIP）。 devicePixelRatio（设备像素比）：物理像素和逻辑像素的比例关系，通常可以通过js的 window.devicePixelRatio 来获取。 devicePixelRatio可以用来区分视网膜设备还是非视网膜设备。 devicePixelRatio 值为 1 的屏幕称之为标准屏（也称，非视网膜屏）；目前，大部分移动设备都是高清屏（也称，视网膜屏），即 devicePixelRatio 值大于 1 的屏幕，对于苹果设备来说，我们经常听到 Retina屏（视网膜屏），其中iPhone6/6s/7 的 devicePixelRatio 值为 2；而iPhone6 plus/6s plus/7 plus 的 devicePixelRatio 值为 3。 设置0.5px边框 优点：实现简单 缺点：retina屏的浏览器可能不认识0.5px的边框，将会把它解释成0px，没有边框。包括iOS 7 和之前版本，OS X Mavericks 及以前版本，还有 Android设备。 //判断手机是否支持0.5px if (window.devicePixelRatio && devicePixelRatio >= 2) { var divElem = document.createElement('div') divElem.style.border = '.5px solid transparent' document.body.appendChild(divElem) if (divElem.offsetHeight == 1) { document.querySelector('html').classList.add('hairlines'); } document.body.removeChild(divElem); } //在html中，加上此样式 .hairlines { *:not(table tr td), *:not(.noHairlines) { border-width: 0.5px!important; } } box-shadow（阴影） 优点：可以设置圆角 缺点：颜色不好控制 .border-1px { box-shadow:0 1px 1px -1px rgba(0, 0, 0, 0.5); } border-image（边框背景图片） 使用的图片是2px高，上部的1px颜色为透明，下部的1px使用视觉规定的border的颜色。 优点： 缺点：修改颜色麻烦，需要替换图片；圆角需要特殊处理，并且边缘会模糊。 .border-image-1px { border-width: 1px 0px; border-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAcSURBVHjaBMEBDQAADMMgckv1r20H1WxzoNoPAER9BjAKc4kUAAAAAElFTkSuQmCC\") 2 0 stretch; } background-image 渐变 缺点：不能实现圆角。 .border-1px { background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px; } transform: scale(0.5) （推荐，相当灵活） /*height：1px，然后根据媒体查询设置transform: scaleY(0.5)*/ .border-1px { height:1px; background:#000; transform: scaleY(0.5); transform-origin:0 0; overflow: hidden; } /*伪类::after和::befor,设置border-bottom：1px solid #000,然后在缩放transform: scaleY(0.5),可以实现两根边线的需求*/ .border-1px:after, .border-1px::after { content:''; width:100%; border-bottom:1px solid #000; transform: scaleY(0.5); } /*伪类::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scale(0.5); 优点可以实现圆角，缺点是按钮添加active比较麻烦。*/ .border-1px:after, .border-1px::after { content: ''; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid #bfbfbf; border-radius: 4px; transform: scale(0.5,0.5); transform-origin: top left; } viewport+rem 优点：可以自适应已知的各类手机屏幕,且不存在其它方法存在的变颜色困难、圆角阴影失效问题。 缺点：样式必须用rem为单位 var viewport = document.querySelector(\"meta[name=viewport]\"); //下面是根据设备像素设置viewport if (window.devicePixelRatio == 1) { viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no'); } if (window.devicePixelRatio == 2) { viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no'); } if (window.devicePixelRatio == 3) { viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no'); } var docEl = document.documentElement; var fontsize = 10 * (docEl.clientWidth / 320) + 'px'; docEl.style.fontSize = fontsize; 常见问题 细边框显示不全 原因： 未确定。可能与元素的高度、行高及像素的小点有关 解决方法： 上边框被遮住：如果样式中有position: absolute； top：50% ，可以尝试把改成 top: 51%。 尽量不要使用display: inline-block，改用display: block。 将0.5px改为0.7px。 指定高度、行高（如：line-height: normal）。 参考链接 移动web 1像素边框 瞧瞧大公司是怎么做的 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"research/02-如何监控前端异常？.html":{"url":"research/02-如何监控前端异常？.html","title":"如何监控前端异常？","keywords":"","body":"如何监控前端异常？ 一个完善的异常监控平台，是一个非常复杂的项目。它需要包括异常监控、信息收集、信息归类、信息的统计分析、异常场景的重现、异常在源码中的定位等等，同时，也要考虑异常日志的存放以及服务器压力等问题。 本文只涉及异常的捕获、上传方面的内容，大致围绕下面几点展开讨论： 前端需要处理的异常 前端异常的捕获方式 异常信息的上报方式 异常监控常见问题 为什么要处理异常？ 增强用户体验 远程定位问题 未雨绸缪，及早发现问题 无法复线问题，尤其是移动端，机型，系统都是问题 完善的前端方案，前端监控系统； 对于 JS 而言，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。 前端需要处理的异常 语法错误 运行时异常 EvalError eval错误 RangeError 范围错误 ReferenceError 引用错误 TypeError 类型错误 URIError URI错误 SyntaxError 语法错误 Error 通用错误 资源加载异常 img script link audio video iframe @font-face 外链资源的DOM元素。。。 Promise 异常 异步请求异常 XMLHttpRequest fetch 前端异常的捕获方式 try-catch-finally window.onerror = function () {} img script link window.addEventListener('error', function () {}, true) window.addEventListener(\"unhandledrejection\", function () {}) Promise.then().catch(function () {}) 封装 XMLHttpRequest、fetch，覆写请求接口对象 try-catch-finally try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误（如：中文分号）和异步错误(如：回调、promise、setTimeout ）就显得无能为力。 try { // 模拟一段可能有错误的代码 throw new Error(\"会有错误的代码块\") } catch(e){ // 捕获到try中代码块的错误得到一个错误对象e，进行处理分析 report(e) } finally { console.log(\"finally\") } window.onerror window.onerror 是一个全局变量，默认值为null。当 JS 运行时错误（包括语法错误）发生时，window会触发一个 ErrorEvent接口的事件，并执行 window.onerror();。onerror 可以接受多个参数。 window.onerror 无法捕获 静态资源异常、接口异常。 注意：语法错误会导致出现语法错误的那个脚本块执行失败，所以语法错误会导致当前代码块运行终止，从而导致整个程序运行中断，如果语法错误这个发生在我们的错误监控语句块中，那么我们就什么也监控不到了。 window.onerror = function (msg, url, row, col, error) { // msg：错误信息（字符串）。 // url：发生错误的脚本URL（字符串） // row：发生错误的行号（数字） // col：发生错误的列号（数字） // error：Error对象（对象） console.log('我知道异步错误了'); console.log({ msg, url, row, col, error }) return true; }; window.onerror = function () {} 要比其他脚本先执行（注意这个前提！），才可以捕捉到语法错误。 window.onerror函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。 window.addEventListener 监听 js 运行时错误事件，会比 window.onerror 先触发，与 onerror的功能大体类似，不过事件回调函数传参只有一个保存所有错误信息的参数，不能阻止默认事件处理函数的执行，但可以全局捕获资源加载异常的错误。 当资源（如img或script）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些error事件不会向上冒泡到window，但可以在捕获阶段被捕获。因此如果要全局监听资源加载错误，需要在捕获阶段捕获事件 网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。 需要注意： 不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。 需要注意避免 addEventListener 重复监听。 window.addEventListener('error', (msg, url, row, col, error) => { console.log('我知道 404 错误了') console.log( msg, url, row, col, error ); return true }, true) unhandledrejection 没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。 为了防止有漏掉的 Promise 异常，在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。 window.addEventListener(\"unhandledrejection\", function(e){ // Event新增属性 // @prop {Promise} promise - 状态为rejected的Promise实例 // @prop {String|Object} reason - 异常信息或rejected的内容 // 会阻止异常继续抛出，不让Uncaught(in promise) Error产生 e.preventDefault() }) Promise.then().catch(function () {}) new Promise(function(resolve, reject) { throw 'Uncaught Exception!'; }).catch(function(e) { console.log(e); // Uncaught Exception! }) 封装XMLHttpRequest、fetch /** * 函数：封装XMLHttpRequest和fetch对象，获取、上传异常信息。 */ function captureRequestError (reportLog) { // 覆写XMLHttpRequest API if(window.XMLHttpRequest) { var xmlhttp = window.XMLHttpRequest var _oldSend = xmlhttp.prototype.send var _handleEvent = function (event) { if (event && event.toString() === \"[object ProgressEvent]\" && event.currentTarget && event.currentTarget.status !== 200) { //处理错误信息 } } xmlhttp.prototype.send = function () { if (this['addEventListener']) { this['addEventListener']('error', _handleEvent) this['addEventListener']('load', _handleEvent) this['addEventListener']('abort', _handleEvent) this['addEventListener']('close', _handleEvent) } else { var _oldStateChange = this['onreadystatechange'] this['onreadystatechange'] = function (event) { if (this.readyState === 4) { _handleEvent(event) } _oldStateChange && _oldStateChange.apply(this, arguments) } } return _oldSend.apply(this, arguments) } } //覆写fetch API if (window.fetch) { var _oldFetch = window.fetch window.fetch = function() { return _oldFetch.apply(this, arguments).then(function(res){ // 处理信息 return res }).catch(function(error){ // 处理信息 }) } } } VUE errorHandler vue本身有监听异常机制，我们可以在它提供的监听函数中，上传异常信息。 Vue.config.errorHandler = (err, vm, info) => { console.error('通过vue errorHandler捕获的错误'); console.error(err); console.error(vm); console.error(info); } 崩溃和卡顿 卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？ 利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。 window.addEventListener('load', function () { sessionStorage.setItem('good_exit', 'pending'); setInterval(function () { sessionStorage.setItem('time_before_crash', new Date().toString()); }, 1000); }); window.addEventListener('beforeunload', function () { sessionStorage.setItem('good_exit', 'true'); }); if(sessionStorage.getItem('good_exit') && sessionStorage.getItem('good_exit') !== 'true') { /* insert crash logging code here */ alert('Hey, welcome back from your crash, looks like you crashed on: ' + sessionStorage.getItem('time_before_crash')); } 以使用 Service Worker 来实现网页崩溃的监控： Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃； Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态； 网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。 异常日记上报方式 异步请求上报, 后端提供接口，或者直接发到日志服务器 img请求上报，url参数带上错误信息 function report(error) { var reportUrl = 'http://xxxx/report'; new Image().src = reportUrl + 'error=' + error; } Sentry使用 sentry 中文翻译是哨兵。它是一个款错误跟踪、性能监控工具。 Sentry 是一个开源的实时错误报告工具，支持 web 前后端、移动应用以及游戏，支持多种语言（JavaScript、Java、Go、Nodejs、Php、Python 等）和框架（React、Vue、Angular、Next.js 等），还提供了 GitHub、Slack、Trello 等常见开发工具的集成。 使用 sentry 需要结合两个部分：客户端与服务端。客户端就是你需要去监听的项目。而服务端就是一个数据管理平台，它会展示已收集到的错误信息和项目信息，并支持项目管理，组员管理、邮件报警等功能。 可以直接使用 sentry 官方平台，也可以利用 Sentry 的开源库在自己的服务器上搭建服务，官方已经提供了完善的操作文档。 Sentry 的搭建方式主要有两种：Python 安装、通过 Docker 安装。由于 Docker 更加方便易控，官方推荐 Docker 部署。 这里，我们以官方平台为例，简单讲一下接入步骤： 注册账号： 登录入 sentry 官网，注册一个账号。（注意翻墙，shadowsocks PAC 自动模式可能无效，请添加 【PAC 用户自定义规则】或者启用全局模式）。 创建项目，获取DSN： 注册后，在官网创建一个项目，后台会自动生成一个 DSN。DSN 是一个重要的值，用来告诉客户端将事件发送到哪里。 客户端监听项目： 通过 CDN 或者 npm 引入 sentry。 以 npm 引入为例： import Vue from 'vue' import * as Sentry from \"@sentry/vue\" Sentry.init({ Vue, dsn: \"https://xxxxxxxxxxxxxxxxxxx@xxxxxxx.ingest.sentry.io/xxxxx\", integrations: [], // Set tracesSampleRate to 1.0 to capture 100% // of transactions for performance monitoring. // We recommend adjusting this value in production tracesSampleRate: 1.0, // defaultIntegrations: true }) 客户端集成：这是客户端的核心部分，它告诉 sentry 怎么收集、收集哪些错误。 Sentry 默认情况下启用系统集成以集成到标准库或解释器本身。 defaultIntegrations 用来表示是否使用默认添加的集成。 integrations 用来标识启用集成的名称列表。列表应该包含所有启用的集成，包括默认的集成。包含默认集成是因为不同的 SDK 版本可能包含不同的默认集成。 integrations 可用来删除、或添加集成： import { ReportingObserver } from \"@sentry/integrations\" Sentry.init({ dsn: \"https://xxxxxxxxxxxxxxxxxxx@xxxxxxx.ingest.sentry.io/xxxxx\", integrations: [new ReportingObserver()] }) 除引用 sentry 提供的集成，我们可以自定义一个集成，还可以主动捕获并上报错误。 主动上报的方式有两种： 一种是直接上报文本信息，参数为一个字符串；另一种是上报错误对象，参数为一个 error 对象或者类对象。 Sentry.captureMessage('error-message', 'fatal') try { console.log(a) } catch (error) { Sentry.captureException(error) } 以下只是简单的使用示例，详细使用可查看下面链接： https://docs.sentry.io/platforms/javascript/ Sentry For Vue 完整接入详解(2021 Sentry v21.8.x)前方高能预警！三万字，慎入！ 常见问题 跨域脚本异常报错信息 生产环境的 JS 做静态资源 CDN 化，导致访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。 Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。 在H5的规定中，只要满足下面两个条件，是允许获取跨源脚本的错误信息的。 客户端在 script 标签上增加 crossorigin 属性； 服务端设置 js 资源响应头 Access-Control-Origin: 指定域名 | *。 window.error 和 window.addEventListener区别 window.onerror 含有详细的 error信息（如：error.stack），而且兼容性更好，所以一般 JS 运行时错误使用 window.onerror 捕获处理。 window.addEventListener('error') ，可以捕获 JS 运行时的错误，也能捕获资源加载错误。为避免重复上报 js 运行时错误，此时应该只有event.srcElement inatanceof HTMLScriptElement、HTMLLinkElement、HTMLImageElement 时才上报 总结 使用场景分析 可疑区域增加 Try-Catch 全局监控 JS 异常 window.onerror 全局监控静态资源异常 window.addEventListener 捕获没有 Catch 的 Promise 异常：unhandledrejection vue框架： VUE errorHandler 、React 框架： React componentDidCatch 监控网页崩溃：window 对象的 load 和 beforeunload 业界已经有的监控平台 Sentry 开源 (推荐) 阿里的 ARMS fundebug FrontJS 另外还有一些轻量级的 BetterJS 参考资料 前端异常监控-看这篇就够了 如何优雅处理前端异常？ 前端代码异常监控实战 如何做前端异常监控？ © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-11-28 22:54:13 "},"research/03-H5页面跳转和刷新.html":{"url":"research/03-H5页面跳转和刷新.html","title":"H5页面跳转和刷新","keywords":"","body":"H5页面跳转和刷新 本文主要介绍前端 H5 页面的一些刷新、回退、替换、回退 + 刷新的方法。 页面跳转 a 标签 跳转 禁止 a 标签跳转的方法： href = \"#\"：# 是有特定意义的，# 后面紧接的是一个锚占名称，默认的锚点为 #top, 即页面顶部。 href=\"###\"：### 就是一个 # 和不存在的锚点 ## 的组合，页面中找不到命名为 ## 的锚点不会发生跳转，也就不会突然跳到页面顶部。### 只是一种使用者习惯，可以随便找一个跳转不到的标签作为命名。 ### 会带来一些副作用， 比如：会改变浏览器地址栏中的 URL；再如：如果 a 标签带了 target=\"_blank\" ，会开一个新页面。 href=\"javascript:;\"：javascript: 指定要执行的 JavaScript 语句，; 表示为空语句。 href=\"javascript: void(0);\"：void 是一个操作符，该操作符指定要计算一个表达式但是不返回值。 直接删掉 href 属性。 location.href 一个可读可写的字符串，可设置或返回当前显示的文档的完整 URL。设置值可以跳转新网页。 // 当前页面打开 URL 页面 location.href = '' window.location.href = '' this.location.href = '' self.location.href = '' // 在父页面打开新页面 parent.location.href = '' // 在顶层页面打开新页面 top.location.href = '' parent.location.href 和 top.location.href 在特定情况下有差异，如，当页面嵌套多个 iframe 时，parent 指向父窗口，top 指向最顶层的窗口。 Meta 标签 Meta 标签可以控制页面自动跳转，比如，5 秒后，自动跳转。 location.assign(url) 触发窗口加载并显示指定的 URL 的内容，效果与 location.href 相当。 location.replace(url) 以给定的URL来替换当前的资源。 需要注意是：调用 replace() 方法后，当前页面不会保存到会话历史中，这样，用户点击回退按钮时，将不会再跳转到该页面。 window.navigate(url) 非标准的方法，仅 IE 浏览器支持，其他浏览器不提供该方法。 页面刷新 Meta 标签 每 5 秒自动刷新： history.go(0) history.go(delta) 方法从会话历史记录中加载特定页面。 delta 是负值表示向后移动，正值表示向前移动。如果未向该函数传参或传 0，则该函数与调用 location.reload() 具有相同的效果。 注意： history.go(0) 直接读取缓存数据，不会从服务器端获取数据。 location.reload() location.reload() 方法用来刷新当前页面，就像刷新按钮一样。 该方法在跨域调用（执行该方法的脚本文件的域和 Location 对象所在页面的域不同）时，将会抛出 SECURITY_ERROR DOMException 异常。 location.reload() 没有参数： Firefox 对于该方法支持一个非标准的 forceGet boolean 参数 ，当值为 true 时，将强制 Firefox 从服务器加载页面资源。但是在其他浏览器中任何参数都是无效的。 boolean 参数不是标准规范，实际上，它从未成为 location.reload() 的规范。 document.execCommand('Refresh') 当一个HTML文档切换到设计模式时，document 暴露 execCommand 方法，该方法允许运行命令来操纵可编辑内容区域的元素。已废弃，尽量避免使用。 其他方法 location.replace(location) location.href = location.href location = location location.assign(location) window.navigate(location)：非标准的方法，仅 IE 浏览器支持，其他浏览器不提供该方法。 页面回退 H5 退回前一个页面，或者前几个页面。 history.go(-1)、history.back() history.go(-1)、history.back() 都是用于返回上一页，与用户点击浏览器左上角的返回按钮是一样效果。 回退到原页面，是从浏览器缓存读取，不需要重载页面资源。 document.referrer document.referrer 返回的是一个 URI，当前页面就是从这个 URI 所代表的页面跳转或打开的。 location.href = document.referrer 页面替换 H5 跳转到一个新页面，但不需要在 History 新增记录，即，跳转出去后，点击回退不需要再回该页面。 history.replaceState(null, null, url) location.replace(url) replaceState() 方法修改当前会话历史记录： history.replaceState(stateObj, title, url) stateObj：是一个 JavaScript 对象，它与传递给 replaceState 方法的历史记录实体相关联。 title：大部分浏览器忽略这个参数，将来可能有用。 url：可选。历史记录实体的URL。新的 URL 跟当前的 URL 必须是同源；否则抛出异常。 注意：如果不加 history.replaceState，部分机型，可能会导致页面无法返回上一页。 页面回退+刷新 H5 退回前一个页面，并且刷新页面。比如：A -> B 页面，B 修改了跟 A 页面相关的一些数据，回退到 A 页面时，A 必需刷新页面上的数据。 解决方案如下： document.referrer location.replace(document.referrer) pageshow 事件（推荐） // persisted：只读属性，代表一个页面是否从缓存中加载的 window.addEventListener('pageshow', function(e) { if (e.persisted) { location.reload() } }) let isPageHide = false window.addEventListener('pageshow', function () { if (isPageHide) { location.reload() } }) window.addEventListener('pagehide', function () { isPageHide = true }) 注意： 即使页面刷新了，请求接口也可能有缓存。解决方法是：在 API URL中加上时间戳。如：../path1/path2?v=${new Date().getTime()}。 History对象 使用 History 对象修改当前历史记录。A -> B页面时，先替换当前历史记录点，然后再打开 B 页面。 const json = { time: newDate().getTime() } history.replaceState(json, \"\", location.href + \" &t=\" + newDate().getTime()) location.href= url popstate事件 function(){ window.addEventListener(\"popstate\", function(e) { location.reload() }, false) const state = { title : \"\", url : \"#\" } history.replaceState(state, \"\", \"#\") } 相关问题 页面回退不刷新 A -> B 页面，再回退到 A 页面，A页面不刷新。其原因可能是： B 页面回退到 A 页面，移动端部分浏览器 (如iphoneX) 默认不执行更新操作。 B 页面回退到 A 页面，执行了更新操作。但 Ajax 请求从本地缓存中读取数据，导致页面数据不更新。 App 跳转 B 页面，新开了窗口（类似于浏览器中新开了标签页） window.location 和 document.location 有什么区别？ document 对象是 window 对象的一部分，是浏览器的 html 文档 。 window.document === document window 对象的 location 属性引用的是 location 对象，表示该窗口中当前显示文档的URL；document 对象的 location 属性也是引用了 location 对象。在没有内嵌 iframe 的情况下，两者是等同的： window.location === document.location //true location.href === window.location.href === document.location.href 在嵌入 iframe 的情况下，最外层是相同的，但在 iframe 里面的 document.location 和window.location 不同的。iframe 里面的document.location 只改变 iframe 部分。 如何禁止页面回退？ 消除所有后退动作，包括 键盘、鼠标手势等产生的后退动作： history.pushState(null, null, document.URL) window.addEventListener('popstate', function () { history.go(-1) history.pushState(null, null, document.URL) }) history.go、history.back 在 safari 无效？ history.go 加上 ?? return false 或者 event.preventDefault() ??： history.go(-1) return false history.go(0) 可改用 window.location.reload()。 参考资料 MDN Location javascript刷新页面的几种方法 window.location.href和window.open的几种用法和区别 © lizhao all right reserved，powered by Gitbook文件修订时间： 2022-06-02 00:20:23 "},"research/04-web主题切换和个性化定制方法总结.html":{"url":"research/04-web主题切换和个性化定制方法总结.html","title":"Web主题切换和个性化定制方法总结","keywords":"","body":"web主题切换和个性化定制方法总结 切换主题 切换主题：主题是由开发者定义，一般来说只有有限的主题可选。 方法一：class 命名空间 定制不同主题，存于不同的 class 命名空间下，通过 JS 修改 body 或其他需要换主题的标签上的 class 名来实现主题切换。 该方法的关键在于如何为不同主题，生成不同的 class。如果纯手动写多个主题的 class，成本太高，而且后期维护也比较困难。 以下是两种解决方案：postcss-themes 插件、less 混合。 postcss-themes 插件（推荐） 将主题相关的变量提取到一个主题变量文件中， postcss-themes 会为使用了主题文件中变量的选择器，新添加一份带有命名空间的选择器。 /* postcss.config.js */ module.exports = { plugins: { 'postcss-themes': { themes: { // themes 可以为数组，配置多个主题 filePath: 'red_theme.css' } }, 'postcss-css-variables': {}, } } 输入 css： /* index.css */ :root { --main-color: green; } .foo { font-size: 16px; color: var(--main-color); } /* red_theme */ :root { --main-color: red; } 输出 css： .foo { font-size: 16px; color: green; } .red_theme .foo { color: red; } Less 混合 less 混合是将一组属性从一个规则集包含（或混入）到另一个规则集的方法。规则集可以通过传参生成不同的新规则集。该方案需要将所有主题相关的样式集中在一个规则集中，实际执行起来比较困难。 /*variables.less*/ .base_theme(@background: #e2e9f9, @color: #337ab7){ .class_1 { background: @background; } .class_1 a:hover{ color: saturate(@color, 20%); } .class_2 { color: @color; } } @import 'variables.less'; .default_theme { /*默认主题，经典蓝*/ .base_theme(); } .coffee_theme { /*咖啡色主题*/ .base_theme(#f5e2c9, #9f754d); } .purple_theme { /*紫色主题*/ .base_theme(#e5d3ed, #b88bcb); } JS 切换主题 JS 修改 body 或其他需要换主题的元素的 class 名。 document.body.className = `${document.body.className} ${theme_class_name}` 方法二：多个 CSS 文件 定制不同主题，每个主题生成一份 CSS 文件，然后再通过 JS 切换主题样式文件来实现。 实现步骤上如下： 创建主题变量文件，包含主题相关的变量定义； 根据不同的主题变量文件，编译生成不同主题的 CSS 文件； 通过 JS 切换主题样式文件。 其中重点是，如何根据不同的主题变量文件，编译生成不同主题的 CSS 文件。 以下是两种用 webpack 的实现方式： 多次运行 webapck，生成多个 CSS 文件 一次打包同时生成多份主题 CSS 文件比较麻烦，因此通过打包多次，每次生成一个主题对应的 css 文件来实现，而 JS 文件在这个过程中是不会改变。 // webpack.prod.conf.js module.exports = theme => { return { plugins: [ new MiniCssExtractPlugin({ filename: `[name]_${theme}.css`, }), ], resolve: { alias: { themeVars: path.join(__dirname, `../src/style/themes/theme-${theme}.css`), } } } } /*variable/color.less*/ @import \"~themeVars\" const webpack = require('webpack') const webpackConfig = require('./webpack.prod.conf') ['default', 'broker'].forEach(theme => { webpack(webpackConfig(theme), (err, stats) => {}) }) 注意： 使用 less 预处理，@import 可以直接引用 webpack.prod.conf.js 中定义的 alias，而 postcss-loader 是无法使用该 alias 的。 postcss-loader 是通过 postcss-import 来处理 @import 语句。 postcss-import 是不支持 alias 配置的，需要用另一个插件 postcss-import-alias-resolver 来实现。 // postcss.config.js const path = require('path') const aliasResolver = require('postcss-import-alias-resolver'); module.exports = { plugins: { 'postcss-import': { resolve: aliasResolver({ alias: { themeVars: path.join(__dirname, `src/style/themes`), } }) } } } /*variable/color.less*/ @import '~themeVars/theme-broker.css'; 但是，postcss.config.js 中，只能静态指定 alias，想要动态指定，需要在 webpack.prod.conf.js 中配置。实际运行时，发现 postcss-import-alias-resolver 的指定的 alias 在 webpack.prod.conf.js 中无效（？？具体原因未找到）。 最后，改用自定义 postcss-import中的 resolve 方法来实现的： // webpack.prod.conf.js module.exports = theme => { return { plugins: [ new MiniCssExtractPlugin({ filename: `[name]_${theme}.css`, }), ], module: { rules: [ { test: /\\.(css|postcss)$/, use: [ 'style-loader', 'css-loader', { loader: 'postcss-loader', options: { ident: 'postcss', plugins: (loader) => [ require('postcss-import')({ resolve: (id, basedir, importOptions) => { // 这里会将 @import \"./color.css\" 的导入文件，指向`../themes/theme-${theme}.css`。所以 color.css 可以是一个并不存在的文件。 if (id === './color.css') { return path.join(basedir, `../themes/theme-${theme}.css`) } return path.join(basedir, id) } }), // 注意，webpack的配置会覆盖postcss.config.js。 // 所以，如有其他 postcss 插件，也要移到这里 ... ] } } ] } ] } } } 运行一次 webpack， 生成多个 css 文件 （不推荐） extract-text-webpack-plugin: 多次调用插件实例，生成多个 css 文件。不过，该插件适用于 webapck 3，目前已废弃。 webpack如何extract多个css mini-css-extract-plugin：有多主题的相关讨论，但还没有可行的解决方案。 Support multiple instances of MiniCssExtractPlugin to generate multiple CSS theme output from the single CSS input JS 切换主题样式文件 JS 改变 link 标签的 href 属性 实现： 腾讯首页个性化换肤demo页面 document.getElementById('#skincolor').href = 'skin-red.css'; 注意：该方法需重新加载样式表，会带来加载延迟。样式切换不流畅，体验不太好。 JS 修改 link 标签的 disabled 属性 实现： MDN Alternative style sheets link 标签的 disabled 属性用来启用或禁用样式表。通过 JS 设置 link 标签 disabled=\"false\"，可以让默认不渲染的 CSS 开始渲染。 以上样式表都可分为3类： 无 title 属性： ，无论如何都会加载并渲染。如：reset.css。 有 title 属性： ，默认样式，CSS 文件加载并渲染。如：default.css。 有 title 属性： ，作为备选样式，CSS 文件加载，默认不渲染。如：fancy.css。 alternate 意味备用，相当于是 css 预加载进来备用，所以不会有加载换延问题。 个性化定制主题 个性化定制主题：主题是由用户定义，一般具有无限种可能，用户可以为主题变量设置任意色值。 方法一：动态创建 style 标签 该方法实现原理就是通过 JS 创建一个 style 元素，填充新样式，append 到 head 元素中，覆盖 css 文件中定义的样式。 一个简单的DEMO 一个简单的示意 .text_color { color: red; } const styleDom = document.createElement('style') styleDom.innerHTML = '.text_color { color: cyan; }' document.head.appendChild(styleDom) 该方法可以说是最简单的，也可以说是最复杂的。说简单，是因为它的实现方式直接明了；说复杂，是因为它必需逐个找到需要修改的元素的 class 名，元素越多，实现起来就越复杂。 此外，使用了 css modules 的项目，我们无法锁定需要修改的元素的 class 名。 案例分析 Element-UI 换肤： Element-UI 换肤预览 Element-UI 换肤原理 换肤实现过程： 用 Ajax 将当前页面的 CSS 文件请求回来； 处理请求回来的 CSS 数据：将需要替换的色值全部替换成新颜色值。 Element-UI 换肤的处理过程分三步： 把默认主题文件中涉及到颜色的 CSS 值替换成关键词。源码 根据用户选择的色值，生成一系列对应的新颜色值。源码 把关键词换回刚刚生成的相应的新颜色值。源码 创建 style 标签，把处理好的数据填进去，再 append 到 head 元素。相关代码 简单源码示例 function changeTheme (url, colorMap = {}) { const request = new XMLHttpRequest() request.onreadystatechange = res => { const resTarget = res.target if (resTarget.readyState !== 4) { return } if (resTarget.status === 200) { let originalStyle = resTarget.response for (let k in colorMap) { originalStyle = originalStyle.replace(new RegExp(k, 'ig'), colorMap[k]) } const styleDom = document.createElement('style') styleDom.innerText = originalStyle document.head.appendChild(styleDom) } } request.open('GET', url) request.send() } changeTheme('https://xxx.xxx.com/css_file_path/index.css', { '#508cee': '#ff5521', '#D2DFFE': '#FFDDD2' }) 方法二：LESS 在线修改变量 基于 less 写样式，为主题相关的颜色定义变量。在 HTML 中直接引入 .less 文件，再引入 less.js ，less.js 会在线将 .less 文件编译成浏览器可识别的样式，然后填充在新创建的 style 标签中。我们通过调用 less.modifyVars 方法修改主题变量实现个性化定制主题。 一个简单的DEMO LESS 在线修改变量 /**theme.less**/ @major_color: red; .text_color { color: @major_color; } less.js 在线编译 .less 文件，创建一个 style 元素，填入编译后的样式： .text_color {color: red;} JS 修改变量： window.less.modifyVars({\"@major_color\": 'cyan'}) .text_color {color: cyan;} 方法分析 引入的 .less 文件，需要在浏览器中编译，这对浏览器性能有影响，不建议在生产环境使用。 此方法仅限于用 less 的项目才能使用。sass 没有类似 less.modifyVars 的方法。 引入 .less 文件的 标签：rel 属性值必需是 stylesheet/less。 less.js 一定要在所有的 .less 文件后引用。 最后一个关键问题：如何把项目中的 less 样式（.less文件、.vue 文件中的 等）提取到一个 .less 文件中。 目前还没有找到可实现的方案。 Ant Design Pro 在线更换主题 有正在试验的方案，但目前还有问题。它的实现步骤： 合并 less：通过 antd-pro-merge-less 插件扫描 src 中所有的 less，将其合并为一个 .less 文件。 转化 css-module。 抽取 less 变量：通过 antd-theme-webpack-plugin 来做到的。它通过遍历 less 的语法树，抽取配置中所有拥有 less 变量的选择器，并且将其组合成一个 color.less 的文件。antd-theme-generator 可以查看具体实现。 实例预览：Ant Design 在线更换主题预览 最优雅的切换/自定义主题方案 CSS 变量： CSS 预设主题相关变量， 通过 JS 动态修改 CSS 变量，进而修改主题。 css 变量的设置及使用： :root { --major-color: red; } .text_color { color: var(--major-color); } JS 操作 CSS 变量： document.documentElement.style.getPropertyValue('--major-color') document.documentElement.style.setProperty('--major-color', 'purple') document.documentElement.style.removeProperty('--major-color') /* 注意：js操作css变量是在标签的style对象上，所以，对于在css文件中定义的变量，如：`:root { --major-color: red; }`，调用 getPropertyValue 方法，返回的值是空字符。 可以改用下面方法获取： */ getComputedStyle(document.documentElement).getPropertyValue('--major-color') CSS 变量最大的问题是浏览器兼容性 目前来看（2021.07），大部分主流浏览器（chrome、safari、firefox、edge等）是支持的，但是，IE 浏览器不支持。 https://caniuse.com/css-variables 总结 class 命名空间：这是个值得推荐的方案。它的唯一问题是，css 文件将多个主题的样式打包进来，文件会增大。不过，使用 postcss-themes 生成多主题样式，只会新增引用了主题相关变量的选择器，文件不会增加太多，并且，它还有个优势：切换主题不会有延迟问题。 多个 CSS 文件：相比 class 命名空间，这个方案优势在于首次加载的 CSS 文件不需要包含其他主题相关的样式。它的缺点：切换主题可能会有加截延迟；webpack 类的打包工具生成的 CSS 文件，我们通常习惯给文件名指定 hash 值，这会导致 JS 动态加载 CSS 时，无法确定正确的文件名；如果有按需加载的模块，切换主题会变得不好处理。 动态创建 style 标签：这个方案是最灵活的，可以任意修改元素的样式。其他方案都有个前提，必需先确定主题相关的变量，主题切换只能修改引用了变量的样式。它的缺点也很明显：主题切换涉及的元素越多，实现成本就越高；不适合使用了 css module 的项目；如果是基于请求已有 css 文件的数据，替换色值来实现，则会有加截延迟问题，另外，按需加载的模块也不好处理。 LESS 在线修改变量：这是个不太实用的方案。因为，在浏览器中实时编译 .less 文件，非常影响性能，不适合用于生产环境，另外，将所有主题变量相关的样式提取到一个单独的 .less 文件也比较麻烦。 css 变量方法 (推荐)：这是最完美的方案，除了不支持 IE 浏览器（目前已确定的是 IE，也可能还有些其他非主流浏览器）。 参考链接 使用 css/less 动态更换主题色（换肤功能） 一文总结前端换肤换主题 实现三方库按需引入与多主题方案 阮一峰-CSS 变量教程 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-16 23:06:42 "},"research/05-Vue-SSR（服务端渲染）的简单实现.html":{"url":"research/05-Vue-SSR（服务端渲染）的简单实现.html","title":"Vue SSR（服务端渲染）的简单实现","keywords":"","body":"Vue SSR（服务端渲染）的简单实现 本文是在学习和运用服务端渲染时，记录实现的关键原理和主要流程，以及实际应用需要注意的一些问题。如果想快速的初步了解下服务端渲染，不妨一看；如需更深入了解，请查看 Vue SSR 指南。据我看来，官方文档中，除开发环境配置这块，其他大部分都讲得非常清晰了。 什么是服务器端渲染 (SSR)？ Vue.js 是构建客户端应用程序的框架。默认情况下，浏览器访问请求的 HTML 文件，只包含样式引入、Js 文件引入和一个 节点。HTML 的具体内容，是先加载对应的 Js 文件，再通过 Js 来创建 DOM 元素，然后挂载到 div 节点，最终渲染和绘制页面。因这些操作都是在浏览器完成的，称为客户端渲染（CSR）。 HTML文件源码结构大致如下： 标题 然而，我们也可以在服务端，先将一个 Vue 组件渲染为 HTML 字符串，然后，在浏览器访问时，直接返回包含具体内容的 HTML 字符串，浏览器只需将 HTML 字符串解析为 DOM 元素，再渲染和绘制成页面。这种称为服务端渲染（SSR）。 服务器渲染的应用程序也可以被认为是\"同构\"或\"通用\"，因为应用程序的大部分代码都可以在服务器和客户端上运行。 为什么使用服务器端渲染 (SSR)？ 与传统 SPA （Single-Page Application，单页应用程序）相比，服务器端渲染 (SSR) 的优势主要在于： 更好的 SEO：由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序需要通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。 更快的内容到达时间 (time-to-content)：无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记。你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验。 使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。 一个简单示例 // index.js const Vue = require('vue') const server = require('express')() const renderer = require('vue-server-renderer').createRenderer() server.get('*', (req, res) => { const app = new Vue({ data: { url: req.url }, template: `访问的 URL 是： {{ url }}` }) renderer.renderToString(app, (err, html) => { if (err) { res.status(500).end('Internal Server Error') return } res.end(` Hello ${html} `) }) }) server.listen(8088) 命令行运行 node index.js，在浏览器中访问 http://localhost:8088/ 即可。 其中，最关键的是如何将 Vue 组件转换为 HTML 字符串。vue-server-renderer 提供 createRenderer 和 createBundleRenderer 两个方法，分别支持将 Vue 实例和 Bundle 对象转换为 HTML 字符串。一般来说，通过 webpack 打包的 Vue 组件，输出的是 Bundle 对象。 SSR的关键步骤 改造源码结构 客户端渲染时，每个用户在自己的浏览器中使用新应用程序的实例类，创建新的上下文，用户之间互不影响。但是，服务端渲染时，Node.js 服务器运行的是一个长期进程。如果每个用户向服务器请求的是同一个实例，用户间共享上下文，就很容易导致交叉请求状态污染。因此，我们需要的是一个可以重复执行的工厂函数，再分别对客户端渲染、服务端渲染配置不同构建。 工厂函数：每个执行可以创建新的应用程序实例（包括 Vue 组件、router、store 实例） // main.js import Vue from 'vue' import AppVue from './App.vue' import { craeteRouter } from './router' import { createStore } from './store' Vue.config.productionTip = false export function createApp() { const router = craeteRouter(); const store = createStore(); const App = new Vue({ router, store, render: h => h(AppVue) }); return { App, router, store }; } 客户端渲染：只需创建应用程序，并且将其挂载到 DOM 中。 // entry-client.js import { createApp } from \"./main\"; const { App, router ,store } = createApp(); // 替换 store 中的状态 if (window.__INITIAL_STATE__) { store.replaceState(window.__INITIAL_STATE__) } router.onReady(() => { App.$mount('#app') }); 服务器渲染：使用 default export 导出函数，在每次渲染中重复调用此函数。 // entry-server.js import { createApp } from \"./main\"; const { App, router ,store } = createApp(); default export function () { return { App, router, store } } 改造构建配置（vue.config.js） vue-cli 默认创建的是纯客户端的项目配置。服务端渲染的配置大体上与纯客户端项目类似，我们可以在默认配置上，根据环境变量为服务端渲染的增加不同的配置。 客户端渲染（纯客户端）：只需指定入口文件即可。 // vue.config.js let baseConfig = { configureWebpack: { entry: './src/entry-client.js' } } module.exports = baseConfig 服务端渲染（服务器配置）：服务器配置，是用于生成传递给 createBundleRenderer 的 server bundle。 // vue.config.js ... const merge = require(\"lodash.merge\") const VueSSRServerPlugin = require('vue-server-renderer/server-plugin'); const nodeExternalsNode = require('webpack-node-externals'); baseConfig = merge(baseConfig, { outputDir: './dist/server', productionSourceMap: process.env.NODE_ENV === 'development', css: { extract: false }, configureWebpack: { entry: './src/entry-server.js', target: 'node', output: { libraryTarget: 'commonjs2' }, externals: nodeExternalsNode({ whitelist: [/\\.css$/, /\\?vue&type=style/] }), optimization: { splitChunks: false }, plugins: [ new VueSSRServerPlugin() ] }, chainWebpack: config => { const langs = [\"css\", \"postcss\", \"scss\", \"sass\", \"less\", \"stylus\"]; const types = [\"vue-modules\", \"vue\", \"normal-modules\", \"normal\"]; for (const lang of langs) { for (const type of types) { let rule = config.module.rule(lang).oneOf(type) rule.uses.clear(); rule.use().loader('null-loader'); } } } }); ... 服务端渲染（客户端配置）：客户端配置，是用于生成客户端构建清单。在 Node 中启动 Web 应用程序时，它可以自动推断和注入资源预加载 / 数据预取指令(preload / prefetch directive)，以及 css 链接 / script 标签到所渲染的 HTML。 // vue.config.js ... const merge = require(\"lodash.merge\") const VueSSRClientPlugin = require('vue-server-renderer/client-plugin'); baseConfig = merge(baseConfig, { outputDir: './dist/client', productionSourceMap: process.env.NODE_ENV === 'development', css: { sourceMap: process.env.NODE_ENV === 'development', }, configureWebpack: { entry: './src/entry-client.js', target: 'web', optimization: { runtimeChunk: { name: 'manifest' } }, plugins: [ new VueSSRClientPlugin() ] } }) ... Node.Js 启动 Web 服务 根据生成的服务端 bundle 和客户端构建清单，编译成 HTML 字符串，启动 Web 服务。 // server/index.js const path = require('path') const fs = require(\"fs\") const express = require('express') const Server = express() const serverBundle = require('../dist/server/vue-ssr-server-bundle.json') const clientManifest = require('../dist/client/vue-ssr-client-manifest.json') const template = fs.readFileSync(path.resolve(__dirname, '../src/template.html'), 'utf8') const { createBundleRenderer } = require(\"vue-server-renderer\") const renderer = createBundleRenderer(serverBundle, { runInNewContext: false, template, clientManifest }) Server.get('*', (request, response, next) => { const context = { url: request.url }; renderer.renderToString(context, (error, html) => { if (error) { next(); } else { response.end(html); } }); }, ); const rendererServerPort = 8080 Server.listen(rendererServerPort, () => { console.log(`server listening on ${rendererServerPort} port`); } ) SSR的开发环境配置 到目前为止，我们已经实现了服务端渲染的实现。可以发现，HTML字符串的生成，是基于编译后，dist 目录下的 server bundle 和客户端构建清单这两个静态文件转换的。也就是说，每次编辑过应用程序源代码之后，都必须重新编译并生成这两个文件，重启 Web 服务。这在开发过程中会影响开发效率。 在 develop 模式下，webpack 输出内容是在内存中的。为提升开发效率，我们可以启动观察模式，当源码有变化时，从内存中重新读取 server bundle 和客户端构建清单文件。 点击查看源码 vue-cli4-ssr-example。 生成客户端构建清单：在原有的【服务端渲染（客户端配置）】中加上 devServer 配置。 // vue.config.js ... baseConfig = merge(baseConfig, { ... devServer: { port: 3030, headers: { 'Access-Control-Allow-Origin': '*' } }, publicPath: 'http://localhost:' + 3030 }) ... 启动开发环境的 Web 服务： ```js // dev.js const path = require('path'); const webpack = require('webpack'); const express = require('express'); const { createBundleRenderer } = require(\"vue-server-renderer\"); const MemoryFs = require('memory-fs'); const http = require('http'); const fs = require(\"fs\") const webpackConfig = require('@vue/cli-service/webpack.config'); const rendererServerPort = 8080 const devServerPort = 3030 const MemoryFsForCompiler = new MemoryFs(); const serverBundleOutputPath = path.join(webpackConfig.output.path, 'vue-ssr-server-bundle.json'); let serverBundle; const serverCompiler = webpack(webpackConfig); serverCompiler.outputFileSystem = MemoryFsForCompiler; serverCompiler.watch({}, (error, status) => { if (error) throw error; status = status.toJson(); serverBundle = JSON.parse(MemoryFsForCompiler.readFileSync(serverBundleOutputPath, 'utf-8')); console.log('vue-ssr-server-bundle generated'); }); const htmlTempalte = fs.readFileSync(path.resolve(__dirname, '../src/template.html'), 'utf8'); const app = express(); app.get('*', async (request, response) => { if (serverBundle == undefined) { response.status(500); response.end('Server Not Ready Yet!'); } try { const renderer = createBundleRenderer(serverBundle, { runInNewContext: false, // 推荐 template: htmlTempalte, clientManifest: await getManifest(`http://localhost:${devServerPort}/vue-ssr-client-manifest.json`) }); renderer.renderToString({ url: request.url, }, (error, html) => { if (error) { response.status(404); response.end(`${request.url} Not found`); } else { response.type('html'); response.end(html); } }); } catch { response.status(500); response.end('Missing vue-ssr-client-manifest.json! Does devServer running ?') } }).listen(rendererServerPort, () => { console.log(`server listening on ${rendererServerPort} port`); } ); function getManifest(url) { return new Promise((resolve, reject) => { const client = http.get(url, (response) => { response.setEncoding('utf8'); let rawData = ''; response.on('data', (chunk) => { rawData += chunk; }); response.on('end', () => { try { resolve(JSON.parse(rawData)) } catch (e) { reject(e); } finally { client.destroy(); } }); }).on('error', reject); }); } ### 需要注意的问题 * **SSR 推荐使用：** 建议用于单页面项目，用 vue-router 管理路由、Vux 管理页面状态。多页面项目也可以用 SSR，但配置会更复杂。 * **生命周期：** SSR 中只有 `beforeCreate、created` 会被执行，而在 CSR 中所有周期都会再执行一遍。另外，在服务端代码中不要写有全局副作用的代码，如：`setInterval`，因为无法在 `beforeDestroy、destroyed `的生命周期销毁定时器。 * **尽量写通用代码：** 避免使用特定平台的 API，比如：浏览器的 `window、document、navigator` 等。特别注意第三方库的引入，有时候你并不知道引入的库能不能完全运行在 Node端/浏览器端。如果它只能运行在纯浏览器环境，可以在 `created` 阶段之后引入和执行。 * **数据预取问题：** 在 SSR 期间，如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析这些数据。 为了解决这个问题，我们采用 Vuex 管理页面状态。在服务器端，我们在渲染之前预取数据，并将数据填充到 store 中，然后，在 Vue 组件中引入这些数据。 ```js // index.vue SSR异步数据： export default { async asyncData({ store }) { return store.dispatch(\"setSsrPageData\") }, computed: { ssrPageData () { return this.$store.state.step.ssrPageData } } } // store.js export default { state: { ssrPageData: {}, }, mutations: { setSsrPageData(state, data){ state.ssrPageData = data } }, actions: { setSsrPageData: async function ({ commit }){ const res = await getAsyncData() commit('setSsrPageData', { title: res.data.title }) } }, } // entry-server.js import { createApp } from './main' const { App, store, router } = createApp() export default function createAppWithContext(context) { return new Promise((resolve, reject) => { router.push(context.url) router.onReady(async () => { const matchedComponents = router.getMatchedComponents() if (!matchedComponents.length) { return reject({ code: 404 }) } const componentWithAsyncDataTaskQueue = []; for (const matchedComponent of matchedComponents) { if (matchedComponent.asyncData !== undefined) { componentWithAsyncDataTaskQueue.push( matchedComponent.asyncData({ store }) ); } } for (const asyncTask of componentWithAsyncDataTaskQueue) { await asyncTask; } context.state = store.state; resolve(App); }, reject) }) } Cookie 问题： 当服务端数据预取跟用户信息相关时，我们通常是通过浏览器中的 Cookies 进行管理。浏览器在发送请求时，会自动把 Cookie 添加到请求中的 Header 中，而在 SSR 时，Node.Js 需要手动获取浏览器发来 Cookie，并在发送给服务端的请求 Header 中设置 Cookie。 SSR 共有3种解决 Cookies 问题的方案：一、把 Cookies 注入到 state；二、把 Cookies 注入到 global；三、将 Cookies 注入到组件的 asyncData 方法。 随着 Vue 的升级，第一种方案已经不再适用；第二种方案也有不少的限制。目前主要用到的是第三种方案： 获取浏览器 Cookie： // server/index.js Server.get('*', (request, response, next) => { const context = { url: request.url, cookie: request.headers.cookie } }) 将 Cookie 传给 asyncData 方法： // entry-server.js ... matchedComponent.asyncData({ store, cookie: context.cookie }) ... 将 Cookie 传给 actions： // index.vue export default { async asyncData({ store, cookie }) { return store.dispatch(\"setSsrPageData\", { cookie }) } } 将 Cookie 传给 api，再加到 axios 的 Headers。 // store.js export default { actions: { setSsrPageData: async function ({ commit }, { cookie } ){ const res = await getAsyncData({cookie}) commit('setSsrPageData', { title: res.data.title }) } } } Nuxt.js Nuxt.js 是一个基于 Vue.js 的通用应用框架，它预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 Nuxt.js 集成了以下组件/框架，用于开发完整而强大的 Web 应用： Vue 2 Vue-Router Vuex (当配置了 Vuex 状态树配置项 时才会引入) Vue 服务器端渲染 (排除使用 mode: 'spa') Vue-Meta 压缩并 gzip 后，总代码大小为：57kb （如果使用了 Vuex 特性的话为 60kb）。 另外，Nuxt.js 使用 Webpack 和 vue-loader 、 babel-loader 来处理代码的自动化构建工作（如打包、代码分层、压缩等等）。 参考资料 Vue SSR 指南（官方） vue-server-renderer API 参考 vue-cli4-ssr-example 再说 Vue SSR 的 Cookies 问题 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-15 00:10:56 "},"research/06-基于create-react-app打造代码规范化的react+ts项目.html":{"url":"research/06-基于create-react-app打造代码规范化的react+ts项目.html","title":"基于Create React App打造代码规范化的React+Ts项目","keywords":"","body":"基于create-react-app打造代码规范化的react+ts项目 Create React App 是一个官方支持的创建 React 单页应用程序的方法。它提供了一个零配置的现代构建设置。 而在实际的项目开发中，我们通常希望可以自行配置一些参数。如：webpack 的alias、typescript 的path、eslint 的rules等。本文记录了基于 create-react-app 打造 react+ts 的过程遇到的各种问题，以及对应的解决方法。 npm: 6.9.0 node: v12.2.0 react-scripts: 4.0.3 (发布新版本的 Create React App，更新 react-scripts 即可 ) 创建项目 创建 react + ts 项目： npx create-react-app my-app --typescript 安装 TypeScript 包: npm install --save typescript @types/node @types/react @types/react-dom @types/jest 将 .js、.jsx 文件重命名为 .ts、.tsx 文件（typeScript文件），运行 npm start 启动项目。 注：不需要手动创建 tsconfig.json 文件。当项目中的 src/ 路径下有TypeScript文件（.ts|tsx）时，运行 npm start 会自动创建tsconfig.json 文件。 自定义webpack CRA 项目中，webpack 的配置是封装在 react-scripts 包内。扩展 webpack 配置有以下方法： 1. npm run eject （不推荐） 它会将所有配置文件和传递依赖项（Webpack，Babel，ESLint等）复制到项目中，以便你可以完全控制它们。除 eject 之外的所有命令仍然有效，但它们将指向复制的脚本，以便你可以调整它们。 注意：这是单向操作。一旦你 eject ，你就不能回去了！ CRA 通过升级其中的 react-scripts 包来升级 CRA 的特性，而使用了 eject 命令，就再也享受不到 CRA 升级带来的好处了。因为 package 中的 scripts 的命令已经指向了项目中的配置文件，而不是指向 react-scripts 包。 2. react-app-rewired +customize-cra 安装：npm i react-app-rewired customize-cra -S 配置：在项目根目录添加 config-overrides.js 配置文件 该工具可以在不 npm run eject， 也不创建额外 react-scripts 的情况下修改 create-react-app 内置的 webpack 配置，然后你将拥有 create-react-app 的一切特性，且可以根据你的需要去配置 webpack的plugins, loaders 等。 查看更多配置 /* config-overrides.js */ module.exports = function override(config, env) { //do stuff with the webpack config... return config; } 默认情况下， config-overrides.js 文件导出单个函数，以便在开发或生产模式下自定义 webpack 配置。此外，该文件中也可以导出一个包含最多三个字段的对象，每个字段都是一个函数。如下： /* config-overrides.js */ module.exports = { // 该字段与 config-overrides.js 导出的单个函数的等效项。 // 它无法在测试模式下配置编译，也不能用于自定义开发模式下的 Webpack Dev Server。 webpack: function(config, env) { return config; }, // 该配置应用于 Jest 模式下。这意味着上述 webpack 配置在测试模式下都是无效的。 jest: function(config) { return config; }, // 在开发模式下运行时，用于生成 dev server 配置。 devServer: function(configFunction) { return function(proxy, allowedHost) { const config = configFunction(proxy, allowedHost); return config; }; }, // paths 字段用于为 create-react-app 传递到 webpack 和 jest 的路径提供覆盖。 paths: function(paths, env) { return paths; } } 使用 customize-cra。 customize-cra 用于改成 react-app-rewired 的 config-overrides.js文件。通过导入 customize-cra 功能和导出几个函数调用包裹在 override 函数中。这样，就可以很容易地修改组成create-react-app 的配置对象（webpack，webpack-dev-server，babel等）。 查看更多customize-cra api ```js / config-overrides.js / const { override, disableEsLint, addWebpackAlias, } = require(\"customize-cra\"); const path = require(\"path\"); module.exports = override( disableEsLint(), addWebpackAlias({ [\"ag-grid-react$\"]: path.resolve(__dirname, \"src/shared/agGridWrapper.js\") }) ); * 修改项目启动命令。 ```json /* package.json */ \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-scripts eject\" } 自定义 config-overrides.js 路径。 比如：您想要使用在 node_modules 中的第三方 config-overrides.js，您可以将以下内容添加到您的 package.json： \"config-overrides-path\": \"node_modules/some-preconfigured-rewire\" 3. @craco/craco craco 是另一款类似 react-app-rewired 的功能。 安装：npm i @craco/craco -S 配置：在项目根目录下添加 craco.config.js 配置文件。更看更多配置 /* craco.config.js */ const { when, whenDev, whenProd, whenTest, ESLINT_MODES, POSTCSS_MODES } = require(\"@craco/craco\"); module.exports = { reactScriptsVersion: \"react-scripts\" /* (default value) */, style: {}, eslint: {}, babel: {}, typescript: {}, webpack: { alias: { '@': path.resolve(__dirname, \"src\") }, plugins: { add: [], remove: [], }, configure: { }, // configure: (webpackConfig, { env, paths }) => { return webpackConfig; } }, jest: { }, devServer: { }, plugins: [ ] }; 修改项目启动命令 /* package.json */ \"scripts\": { \"start\": \"craco start\", \"build\": \"craco build\", \"test\": \"craco test\", \"eject\": \"react-scripts eject\" } 自定义Typescript 按上述安装方法创建项目后，运行 npm start，在 src/ 有 typescript 文件的情况下，会自动创建 tsconfig.json 文件。 你可以编辑该文件。 在建项过程中发现， 修改 tsconfig.json 文件中的 compilerOptions.paths 属性后，每次运行 npm start，该属性会被自动创建的文件覆盖。 解决方案如下： 安装： npm i @craco/craco -D 新建 tsconfig.paths.json 文件 // tsconfig.paths.json { \"compilerOptions\": { \"baseUrl\": \".\", \"paths\": { \"@/*\": [\"src/*\"] } } } 修改 tsconfig.json 文件。 // tsconfig.json { \"extends\": \"./tsconfig.paths.json\", ... } 环境变量 CRA 创建的项目可以使用环境中声明的变量，就像是在 JS 文件中本地声明的变量一样。默认情况下，项目将为你定义 NODE_ENV ，以及以 REACT_APP_ 开头的任何其他环境变量。 环境变量在构建期间嵌入。由于 Create React App 生成静态的 HTML / CSS / JS 包，因此无法在 runtime(运行时) 读取它们。项目中的环境变量，会在构建静态文件时，替换成对应的值。 console.log(process.env) // FAST_REFRESH: true // NODE_ENV: \"development\" // PUBLIC_URL: \"\" // WDS_SOCKET_HOST: undefined // WDS_SOCKET_PATH: undefined // WDS_SOCKET_PORT: undefined NODE_ENV 是一个特殊内置环境变量。当你运行 npm start 时，它总是等于 'development' ，当你运行 npm test 它总是等于 'test' ，当你运行 npm run build 来生成一个生产 bundle(包) 时，它总是等于 'production' 。你无法手动覆盖NODE_ENV。 注意：必须以 REACT_APP_ 开头创建自定义环境变量。除了 NODE_ENV 之外的任何其他变量都将被忽略。更改任何环境变量都需要重新启动正在运行的开发服务器。 自定义环境变量 有两种方式完成自定义环境变量：在 shell 中或在 .env 文件中。 在 Shell 中添加临时环境变量 定义环境变量可能因操作系统而异。 注意，这种方式对于 shell 会话是暂时的。 # Windows (cmd.exe) # 注意：变量赋值需要用引号包裹，以避免尾随空格。） set \"REACT_APP_SECRET_CODE=abcdef\" && npm start # Windows (Powershell) ($env:REACT_APP_SECRET_CODE = \"abcdef\") -and (npm start) # Linux, macOS (Bash) REACT_APP_SECRET_CODE=abcdef npm start 在 .env 中添加开发环境变量 要定义永久环境变量，请在项目的根目录中创建名为 .env 的文件： # .env REACT_APP_WEBSITE_NAME=REACT+TS项目 REACT_APP_AUTHOR=李兆 REACT_APP_SECRET_NUMBER=123456 环境变量间的引用： REACT_APP_VERSION=$REACT_APP_SECRET_NUMBER 如何使用环境变量 在 HTML 中引用环境变量 %REACT_APP_WEBSITE_NAME% 在 JS 中引用环境变量 // index.js console.log(process.env.REACT_APP_AUTHOR) 在 CSS 中引用环境变量 # .env.local REACT_APP_MAIN_COLOR=red 方法一：使用行内样式 方法二：使用 CSS in JS，即用 js 写 css，可用第三方库实现。如：Style Components、Emotion。 安装：npm i styled-components -D // index.js import styled from 'styled-components' const WrapperDiv = styled.div` color: ${process.env.REACT_APP_MAIN_COLOR} `; function App() { return css in js; } export default App; 方法三：使用 CSS 预处理器来管理全局变量。如：sass。 安装：npm install node-sass -S // craco.config.js module.exports = { style: { sass: { loaderOptions: { additionalData: \"$my-color: cyan;\" } } } } /* index.scss */ .env_variable { color: $my-color; } 其他 .env 文件 .env：默认。 .env.local：本地覆盖。除 test 之外的所有环境都加载此文件。 .env.development, .env.test, .env.production：设置特定环境。 .env.development.local, .env.test.local, .env.production.local：设置特定环境的本地覆盖。 左侧的文件比右侧的文件具有更高的优先级： npm start: .env.development.local, .env.development, .env.local, .env npm run build: .env.production.local, .env.production, .env.local, .env npm test: .env.test.local, .env.test, .env 。注意：没有 .env.local 代码规范化(Eslint\\Prettier) eslint配置 方法一：Create React App 官方给出的解决方案 添加境变量EXTEND_ESLINT为true。 修改 eslant 配置，可直接修改 package.json 配置，或者添加 eslint.js 文件。 // package.json { \"eslintConfig\": { \"extends\": [ \"react-app\", \"react-app/jest\" ], \"rules\": { 'no-console': process.env.NODE_ENV === 'production' ? 2 : 1, } }, } // eslintrc.js module.exports = { extends: [ \"react-app\", \"react-app/jest\" ], rules: { 'no-console': process.env.NODE_ENV === 'production' ? 2 : 1, }, } 方法二：修改 craco.config.js 配置。 module.exports = { eslint: { enable: true, mode: \"extends\", configure: { extends: [ \"react-app\", \"react-app/jest\" ], rules: { 'no-console': process.env.NODE_ENV === 'production' ? 2 : 1, }, }, pluginOptions: { }, }, } prettier配置 安装：npm i prettier eslint-plugin-prettier eslint-config-prettier -D 配置：在 package.json 里添加 prettier 字段，或者在项目的根目录下添加 .prettierrc 或 .prettierrc.js 或 .prettier.config.js 和 .prettierrc.toml 文件。 // package.json { ... \"prettier\": { \"printWidth\": 80, \"tabWidth\": 2, \"useTabs\": false, \"singleQuote\": true, \"semi\": false } } // .prettier.config.js module.exports = { printWidth: 80, tabWidth: 2, useTabs: false, singleQuote: false, semi: true, } 命令行： // package.json // 采用.prettier.config.js配置时，命行令中要加 --config .prettier.config.js { \"scripts\": { \"format\": \"prettier --write \\\"src/**/*.+(js|jsx|css)\\\"\", // \"format\": \"prettier --write --config .prettier.config.js \\\"src/**/*.+(js|jsx|css)\\\"\" }, } 然后，执行 npm run format即可。 整合：prettier 和 Git 整合。 安装：npm i lint-staged husky -D 配置： // package.json { ... \"lint-staged\": { \"src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\": [ \"prettier --write --config .prettier.config.js \\\"src/**/*.+(js|jsx|css)\\\"\", \"git add\" ] }, \"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\" } }, } 添加 Router(路由) CRA 并未规定特定的Router(路由)解决方案，但 React Router 是最受欢迎的 Router(路由) 解决方案。 import { BrowserRouter as Router, // HashRouter as Router, Switch, Route, Link } from \"react-router-dom\"; import Home from '../home' import About from '../about' import Dashboard from '../dashboard' function App () { return ( Home About Dashboard ) } export default App React Router中的组件主要分为三类： 路由器，例如 和 使用常规URL路径。这些通常是外观最好的网址，但它们要求您的服务器配置正确。 具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面。 请注意，在部署应用程序之前，你可能需要配置生产服务器以支持客户端路由。 将当前位置存储在URL的哈希部分中，因此URL看起来类似于http://example.com/#/your/page。 由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置。 路由匹配器，例如 和 渲染 时，它会搜索其子元素 ，以查找其路径与当前URL匹配的元素。当找到一个时，它将渲染该 并忽略所有其他路由。这意味着您应该将 包含更多特定路径（通常较长）的路径放在不那么特定路径之前。 导航，例如 ， 和 添加样式 如何引入样式 添加常规 CSS 文件。即通过 import 的方式导入 .css 文件。 /**index.css**/ .app_link { color: red } import './index.css' function App() { return Learn React } export default App 添加 CSS Modules 样式表。 CRA 项目使用 [name].module.css 文件命名约定支持 CSS Modules 和常规 CSS 。 CSS Modules 允许通过自动创建 [filename]\\_[classname]\\_\\_[hash] 格式的唯一 classname 来确定 CSS 的作用域。 /**index.module.css**/ .app_module_link { color: orange; } import styles from './index.module.css'; function App() { return Learn React } export default App 最终渲染结果： Learn React 添加 Sass 样式表。 首先，安装：npm install node-sass -S，然后，将文件扩展名改为 .scss 或 .sass （建议用 .scss，书写格式更接近常规css）。 /**index.scss**/ .app_scss_link { color: $my-color; } import './index.scss' function App() { return Learn React } export default App 使用css-in-js。 // index.js import styled from 'styled-components' const LinkP = styled.p` color: deeppink; `; function App() { return Learn React } export default App 最终渲染结果： Learn React Postcss预处理器 CRA 内嵌了压缩、自动添加浏览器前缀等插件，同时，你也可以按需要引入一些 Postcss 插件。如：postcss-apply、postcss-css-variables、postcss-px2rem-exclude 等。 安装：npm i postcss-px2rem-exclude -D 配置：修改 craco.config.js，添加 postcss 插件配置 // craco.config.js module.exports = { style: { sass: { loaderOptions: { additionalData: \"$my-color: cyan;\" } }, postcss: { plugins: [ require(\"postcss-import\")({ \"path\": \"src/assets/css\" }), require(\"postcss-preset-env\")({ features: { \"custom-properties\": { preserve: false, variables: {} }, \"nesting-rules\": true } }), require(\"postcss-apply\")({}), require(\"postcss-css-variables\")({}), require(\"postcss-px2rem-exclude\")({ remUnit: 16, exclude: /node_modules|folder_name/i }), ] }, }, } 结语 CRA 项目还可以结合 redux 管理页面状态。 除了 create-react-app 外，也可以选用 dva、umi等应用框架。 dva dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。 相比于 CAR 只是多了内置的 redux 和 redux-saga，帮我们处理了数据流这方面的需求而已。如果只是想要达到这个效果的话，直接在 CAR 中增加 dva 的依赖也是可以做到的。 umi umi 是蚂蚁金服的底层前端框架，中文可发音为乌米，是一个可插拔的企业级 react 应用框架。umi 以路由为基础的，支持类 next.js 的约定式路由，以及各种进阶的路由功能，并以此进行功能扩展，比如支持路由级的按需加载。然后配以完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求，目前内外部加起来已有 50+ 的插件。 参考链接 Create React App 中文文档 [译]基于create-react-app打造代码规范化的React项目 这些 CSS-in-JS 库，谁更适合你 TypeScript 中文手册 react-router-dom@5.x官方文档翻译 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/07-H5可视化编辑.html":{"url":"research/07-H5可视化编辑.html","title":"H5可视化编辑","keywords":"","body":"h5可视化编辑 市面上有很多优秀的可视化 h5 编辑器，如： Maka： https://www.maka.im/muban （查看DEMO） 码良：https://godspen.ymm56.com/ （查看DEMO） 易企秀： https://www.eqxiu.com/?type=home （查看DEMO） 百度H5： https://h5.bce.baidu.com/ （查看DEMO） （不好用？？不维护？？实名才能发布？？） 腾讯团队出的H5在线编辑器： http://aeditor.alloyteam.com/ 微页： https://www.weiye.me/ 初页： https://www.ichuye.cn/ 兔展：https://www.rabbitpre.com/template/ 搜狐快站： https://www.kuaizhan.com/ 秀制作： https://xiumi.us/#/ appcan： http://www.appcan.cn/ 实现原理与需求分析 从实现原理来说，h5 编辑其实需要解决的就是以下几个问题： 需要有哪些可以编辑的元素？ 文本、图片、形状、音频、链接等，二期以后会逐步增加更多的可编辑元素。 元素如何进行编辑？ 通过点击或者上传的形式新增，通过拖拽来调整大小尺寸及位置，通过编辑面板来修改样式。同时，不同的元素将拥有不同的编辑面板，如文字类型，可以修改字体、颜色、大小、对齐方式等，而图片类型，则可以进行缩放、裁剪、圆角、阴影等调整。 如何编辑和预览动画效果？ 动画效果将模仿其他产品，合并至编辑面板，并通过点击图标的形式，更换不同的入场动画，更换的同时，触发本动画的实际效果预览。另外也可以点击独立的预览按钮，可以对已经编辑完毕的页面进行预览。 如何实现与后台的数据交互？ 按页和页内元素组合成一个 Json 对象，附带音频信息传递至后台数据接口，读取时同样处理。 如何将数据转换成手机端网页？ 借助 vue 的 createElement 方法，将 Json 逐一解析成对应的组件，渲染即可。使用 slider 插件实现上下或者左右翻页。 手机端网页如何实现兼容？ 目前市面上，手动开发这类型网页，一般有两种兼容方式，即固定尺寸兼容及百分比兼容，我称之为主动兼容和被动兼容，区别主要是在与元素 css 的尺寸计算方式以及 viewport 的写法。 目前比较流行的页面可视化搭建方案可以有如下几种： 在线编辑代码实现； 在线编辑 Json 实现； 无代码化拖拽实现（底层基于 Json 配置文件）。 方案 定制化程度 缺点 在线编辑代码 最高 使用成本高，对非技术人员不友好，效率低。 在线编辑json 较高 需要熟悉json，有一定使用成本，对非技术人员不友好，效率一般。 无代码化拖拽实现 高 使用成本低，操作基本无门槛，效率较高。 目前市面上已有的产品也有很多，比如说易企秀、兔展、百度 H5 等等。实现原理其实还是基于 Json，通过可视化的手段将配置的页面转化为 Json 数据，最后在基于 Json 渲染器来动态生成 H5 站点。 H5-Dooring%E4%BB%8B%E7%BB%8D) H5-Dooring 是一款功能强大，开源免费的 H5 可视化页面配置解决方案，致力于提供一套简单方便、专业可靠、无限可能的 H5 落地页最佳实践。技术栈以 react 为主， 后台采用 nodejs 开发。 技术栈 React： 前端主流框架（react,vue,angular）之一,更适合开发灵活度高且复杂的应用； dva： 主流的 react 应用状态管理工具，基于 redux； less： css 预编译语言，轻松编写结构化分明的 css； umi： 基于 react 的前端集成解决方案； antd： 地球人都知道的 react 组件库； axios： 强大的前端请求库； react-dnd： 基于 react 的拖拽组件解决方案，具有优秀的设计哲学； qrcode.react： 基于 react 的二维码生成插件； zarm： 基于 react 的移动端 ui 库，轻松实现美观的 H5 应用； koa： 基于 nodejs 的上一代开发框架，轻松实现基于 nodejs 的后端开发； @koa/router： 基于 koa2 的服务端路由中间件； ramda： 优秀的函数式 js 工具库。 编辑器实现思路 实现原理其实还是基于 Json，通过可视化的手段将配置的页面转化为 Json 数据，最后在基于 Json 渲染器来动态生成 H5 站点。 已完成功能 组件库拖拽和显示 组件库动态编辑 H5 页面预览功能 保存 H5 页面配置文件 保存为模版 移动端跨端适配 媒体组件 正在完成功能 添加模版库模块 添加在线下载网站代码功能 丰富组件库组件，添加可视化组件 添加配置交互功能 组件细分和代码优化 添加typescript支持和单元测试 H5-Dooring DEMO h5ds H5DS（HTML5 Design software）这是一款基于 WEB 的 HTML5 制作工具的内核。让不会写代码的人也能轻松快速上手编写 HTML5 页面。H5DS 同时也是一款基于 react + mobx 的在线 HTML 制作工具，灵活的内核可快速改造成各种可视化制作工具（基于该内核，可以做BI工具，建站工具，图形设计工具，在线PPT工具等一系列工具），H5DS 提供了丰富的插件扩展接口，让插件可自由快速扩展和动态加载，同时也支持 API 接入。 注意： 目前 H5DS 只开源了编辑器（v5.x版本）页面的代码，如需获取最新版本的（v6.x）源码请购买商业授权授权协议。 产品的特点 高维护性： 采用 react+mobx 模块化开发，源码结构清晰，注释规范，高可维护，方便进行二次开发和迭代升级。 高扩展性： 编辑器内核独立存在，官方提供了插件开发教程以及 CLI 工具，可独立开发插件，动态加载插件。 高性能： 采用 mobx 统一管理数据，底层 proxy 数据监听，做了大量节流和防抖优化，插件按需加载，不占内存。 多终端支持： 支持手机页面、PC 页面独立制作，设计界面可自由切换，采用缩放模式兼容各种屏幕分辨率， PC/Mobile 一网打尽。 h5ds DEMO，审核中 QuarkH5 quark-h5 基于 vue2 + koa2 的 H5 可视化拖放编辑器，star高达 2.6K+。支持拖拽组件并配置属性，支持动画及效果预览，轻松快速上手制作h5页面。 技术栈 Vue2.x + Vuex + Vue-Router； Element-UI； Sass； Loadsh； Koa，基于 Node.js 的 web 开发框架； Mongodb，基于分布式存储数据库。 编辑器实现思路 编辑器生成页面 JSON 数据，服务端负责存取 JSON 数据，渲染时从服务端取数据 JSON 交给前端模板处理。 QuarkH5 DEMO 鲁班H5 鲁班 H5 是基于 Vue2.0 开发的，通过拖拽的形式，生成页面的工具，类似易企秀、百度 H5 等工具的可视化搭建系统。 主要功能 编辑器：参考线、吸附线、组件对齐、拖拽改变组件形状、元素:复制（画布）、元素:删除（画布）、元素:编辑（画布）、页面：新增、页面：复制、页面：删除、快速预览、撤销、重做。 组件系统：普通文字、普通按钮、普通图片、背景图、背景音乐、视频（Iframe形式）、表单按钮、表单输入框、表单单选框、表单多选框。 增强功能[已开放]：模板列表、基于模板制作H5、保存作品为模板、图片库、第三方无版权图片搜索、SSO登录、第三方登录。 增强功能[暂未开放]：上传 PSD，一键转换为 H5、自定义脚本。 后端 API：创建、保存、更新作品、表单数据收集、表单数据展示、在线预览、二维码预览。 鲁班H5 DEMO H5-Editor 可视化操作，拖拽生成页面，导出 html 文件。 针对开发人员具有编辑器插件系统，支持和现有项目继承，支持二次开发。 H5-Editor 是一个纯前端项目，基于 Vue2 开发、通过拖拽生成页面，类似于 易企秀、百度 H5等。 技术栈 Vue2 Element-ui（少部分使用） Vuex 主要功能 元素自由拖拽、放大、缩小、旋转； 可添加图片、文本、矩形、背景。多种编辑功能（字体、背景、大小、边距等）； 组件自动吸附，实时参考线； 标尺、参考线、可自定义参考线； 撤销、重做； 组件复制、粘贴、锁定、隐藏等； ctrl + 拖动组件可快速复制组件； 右键菜单、菜单可配置、可针对组件当前状态灵活生成（即不同的组件可产生不同的菜单）； 图层面板，可拖拽更改组件图层，可重命名，可在图层面板快速锁定、删除、隐藏组件； 同时选中多组件（按ctrl + 左键），可进行多组件对齐； 数据备份，通过 indexDB 数据库保存在本地（可自动备份，手动备份），并可从备份中恢复数据； 一键生成 h5 代码； 编辑画布大小； 多种快捷键； 设置中心，可设置撤销功能，备份功能等； 针对开发人员具有插件系统，可通过插件系统二次开发。 疑问 满屏页、长页面编辑？？ 自定义Js 交互？？ 数据来源？？ 组件扩展？？ css样式存储形式？？ 参考资料 可视化拖拽组件库一些技术要点原理分析 H5-Dooring%E4%BB%8B%E7%BB%8D) h5ds 阳春市一加工作室/quark-h5 鲁班H5 H5-Editor © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-12-12 11:40:10 "},"research/Javascript加密混淆.html":{"url":"research/Javascript加密混淆.html","title":"Javascript加密混淆","keywords":"","body":"Javascript加密混淆 为什么要对JS代码进行保护？ JS代码运行于客户端。 JS代码是公开透明的。 由于这两个原因，至使JS代码是不安全的，任何人都可以读、分析、复制、盗用，甚至篡改。因此出现了很多安全事件，典型的如：自己的原创程序代码被盗用、网站数据被篡改等等。 如果你不想让自己的代码被它人看到、不想它人了解你的代码功能，或者想降低被不怀好意的人甚至是黑客攻击。那么你应该尝试使用JS保护。 如何对Javascript代码进行保护？ 使JS代码不可读 让攻击者无法理解代码功能，也无法篡改任何功能。 使JS代码不可分析 让攻击者不能进行动态跟踪调试。 代码不可读之后，攻击者往往会进行动态跟踪调试，以期逆向还原出原始代码，或分析出程序功能。 怎么实现代码的不可读不可分析？ 代码加密：加密后的代码看似乎杂乱，但代码在执行前需要进行解密才能执行，只要找到解密函数即可还原出原始代码，所以此方式安全系数较低； 虚拟机技术：可以屏蔽JS原始关键字，但兼容性较差，无法保证在多端，多浏览器下运行； 代码混淆：使用字符串阵列化、平展控制流、多态变异、僵尸函数等手段，使代码变的不可读不可分析，达到最终保护的目的。且不影响代码原有功能。是理想、实用的JS保护方案。 JavaScript加密 密码学有一句话： 当你采用的加密模式，使得攻击者为了破解所付出的代价 远远超过其所获得的利益之时，你的加密方案就是安全的。 代码无法做到完全不可读，只能做到很难读。 只能增加逆向难度，从而提高山寨逆向成本。 造成这两点的原因是，你无法绕过浏览器的web inspector(下文简称WI)。有人会说在JS做黑盒，但其最终调用的还是浏览器提供的API。你是无法防止他人在你调用API时候拦截的。除非你的代码拥有比WI更高的API权限。否则都是没有用。 国内最知名的JS加密当属JShaman Node.js加密算法库Crypto JavaScript混淆 脱离混淆的Javascript加密是伪命题，无论怎么加密，如果不加以混淆手段保护，都没有意义。 如同传统软件的加壳保护，js混淆给底层的加密算法加了最基本的保障，在js层面来说，混淆和加密一定是相辅相成的。 由于js是动态指令码语言，在http中传输的就是原始码，逆向起来要比打包编译后的软体简单很多。暴露在外的程式码没有绝对的安全，但是在对抗中，精心设计的混淆程式码能够给破坏者带来不小的麻烦，也能够为防守者争取更多的时间，相对于破解来说，混淆器规则的更替成本要小得多，在高强度的攻防中，可以大大增加破解者的工作量，起到防御作用。从这个角度来讲，关键程式码进行混淆是必不可少的步骤。 JS混淆归结为三类： eval类型，hash类型，压缩类型 eval混淆 也是最早JS出现的混淆加密，据说第一天就被破解，修改一下代码，alert一下就可以破解了。 hash混淆 miniui 使用的JSA加密 fundebug使用的javascript-obfuscator JSA加密 和 javascript-obfuscator 的区别： 通过JSA加密混淆后生成的代码，beautifier一下，可以发现，其实没有做什么什么修改，只是做了一些变量替换。想还原也比较简单的。这里就不拿它来做代表，也没有什么人用。 通过javascript-obfuscator混淆后生成的代码，beautifier一下，分析一下可以发现，其实多了一个字典，所有方法变量，都有可能存在字典中，调用时先调用字典还原方法名变量再执行。其实入口都是变量的规则。 压缩混淆 是目前前端性能优化的常用工具，以uglify为代表。 js混淆器大致有两种 通过正则替换实现的混淆器 通过语法树替换实现的混淆器 第一种实现成本低，但是效果也一般，适合对混淆要求不高的场景。 第二种实现成本较高，但是更灵活，而且更安全，更适合对抗场景。基于语法层面的混淆器其实类似于编译器，基本原理和编译器类似，我们先对编译器做一些基本的介绍。 编译器工作流程 简单的说，当我们读入一段字串文字（source code），词法分析器会把它拆成一个一个小的单位（token），比如数字1 是一个token, 字串'abc'是一个token等等。接下来语法分析器会把这些单位组成一颗树状结构（AST），这个树状结构就代表了token们的组成关系。比如1 + 2 就会展示成一棵加法树，左右子节点分别是token - 1 和token - 2 ，中间token表示加法。编译器根据生成的AST转换到中间程式码，最终转换成机器程式码。 对编译器更多细节感兴趣的同学可以移步龙书：编译原理 混淆器工作流程 编译器需要把原始码编译成中间程式码或者机器码，而我们的混淆器输出其实还是js。所以我们从语法分析之后往下的步骤并不需要。想想我们的目标是什么，是修改原有的js程式码结构，在这里面这个结构对应的是什么呢？就是AST。任何一段正确的js程式码一定可以组成一颗AST，同样，因为AST表示了各个token的逻辑关系，我们也可以通过AST反过来生成一段js程式码。所以，你只需要构造出一颗AST，就能生成任何js程式码！ 规则设计 知道了大致的混淆流程，最重要的环节就是设计规则。我们上面说了，我们需要生成新的AST结构意味着会生成和原始码不一样的js程式码，但是我们的混淆是不能破坏原有程式码的执行结果的，所以混淆规则必须保证是在不破坏程式码执行结果的情况下，让程式码变得更难以阅读。 具体的混淆规则各位可以自行根据需求设计，比如拆分字串、拆分阵列，增加废程式码等等。 混淆器设计？ 参考：提供商业混淆服务的 jscramble的混淆规则 混淆插件 javascript-obfuscator 一个免费和高效的JavaScript混淆器(包括ES2017)。让你的代码更难复制，防止别人窃取你的成果。这个工具是一个优秀的Web UI(并且是开源的) 这个库很像在线JavaScript代码压缩网站，实际上也可以做一个在线压缩代码的网站。不过他吸引我的是他的cli工具。 ❗ 作者在Github上说了没有很多时间来维护这个项目了，使用请慎重考虑。 //源码 function aa () { console.log('aaa') } aa() //混淆后 var _cs=['\\x61\\x61\\x61']; function _f0() { console.log(_cs[0]) } _f0() uglify-js 是一款JS代码处理工具，提供了压缩，混淆和代码规范化等功能。通过以下传参数，可以对js做些混淆： mangle: { toplevel: true, // — 混淆在最高作用域中声明的变量名（默认false） eval: true, // - 混淆在eval 或 with作用域出现的变量名（默认false） properties: {} //**警告：**这能会搞崩你的代码。混淆属性名跟混淆变量名不一样，是相互独立的。会混淆对象所有可见的属性名，除了DOM属性名和JS内置的类名。 } uglify-js可以对变量名、属性、方法名进行混淆，无法对字符串进行混淆。 closure-webpack-plugin 与uglify-js类似。有对应webpack 4\\webpack 3的插件。 jscrambler jscrambler是一个商业级工具，看了很多社区的评论，这个目前是最好的，需要付费。 jsfuck（开源） jsfuck 是一个开源的js 混淆工具，原理比较简单，其实就是通过特定的字符串加上下标定位字符，再由这些字符替换源代码，从而实现混淆。而且文件体积会受很大影响。 //源码 alert('a') //转换后 [][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+........ 反调试 由于JavaScript自带debugger语法，我们可以利用死循环性的debugger，当页面打开调试面板的时候，无限进入调试状态。 把js代码转化为二进制字节码 代码可以放置其他位置（非js文件） 放到png文件中：利用HTML Canvas 2D Context获取二进制数据的特性，可以用图片存储脚本资源。 利用HTML Canvas 2D Context获取二进制数据的特性，可以用图片存储脚本资源。 放在css文件中：利用content样式能存放字符串的特性，同样可以用来存储脚本资源。 代码块预处理工具 在线加密混淆工具 https://www.jsjiami.com/ （在线） https://www.sojson.com/jsjiemi.html (在线) 参考链接： 加密基础知识四 前端JS加密传输 crypto-js js混淆加密，通过混淆Js程式码让别人(很难)无法还原 移动时代的前端加密 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/Vue如何导入TypeScript.html":{"url":"research/Vue如何导入TypeScript.html","title":"Vue如何导入TypeScript","keywords":"","body":"Vue如何导入TypeScript 什么是Typescript？ TypeScript 是微软开发一款开源的编程语言，它是 JavaScript 的一个超集，本质上是为 JavaScript 增加了静态类型声明。任何的 JavaScript 代码都可以在其中使用，不会有任何问题。TypeScript 最终也会被编译成 JavaScript，使其在浏览器、Node 中等环境中使用。由于最终运行的仍然是 JavaScript，所以 TypeScript 并不依赖于环境的支持，也并不会带来兼容性问题。 同时，TypeScript 也是 JavaScript ES6 的超集。 Vue3.0 将使用 TS 重写，重写后的 Vue3.0 将更好的支持 TS。 Google 的 Angular 2.0 也宣布采用 TypeScript 进行开发。 2019 年 TypeScript将会更加普及，能够熟练掌握 TS，并使用 TS 开发过项目，将更加成为前端开发者的优势。 为什么要用TypeScript？ TypeScript的类型注解是一种轻量级的为函数或变量添加约束的方式，它的优势在于静态类型检查。 概括来说主要包括以下几点： 静态类型检查 即你编写的代码即使没有被执行到，一旦你编写代码时发生类型不匹配，语言在编译阶段即可发现。 IDE 智能提示 在TypeScript这一类语言之前，JavaScript的智能提示基本完全依赖 IDE 提供的猜测，这种猜测可能并不正确，并且也缺乏更多的辅助信息。TypeScript不仅自己写的类库有丰富的类型信息，也可以对其他纯 JS 项目进行类型标注 (DefinitelyTyped)，便于使用者直接在 IDE 中浏览 API，效率大增。 代码重构 有时候需要修改一些变量/属性/方法名，牵涉到属性和方法的时候，很多改动是跨文件的，不像普通变量可以简单定位 scope，属性方法名的重命名对于 JS 来说异常痛苦，一方面是修改本身就不方便，另一方面是改了还不确定该改的是不是改了，不该改的是不是也改了。 而 TypeScript的静态类型系统就可以较为完美的解决这个问题。 可读性 类型就是最好的注释。对于阅读代码的人来讲，各种便利的类型一目了然，更容易明白作者的意图。 常见的变量类型定义： // 布尔值 let isDone: boolean = false; // 相当于 js 的 let isDone = false; // 变量定义之后不可以随便变更它的类型 isDone = true // 不报错 isDone = \"我要变为字符串\" // 报错 // 数字 let decLiteral: number = 6; // 相当于 js 的 let decLiteral = 6; // 字符串 let name: string = \"bob\"; // 相当于 js 的 let name = \"bob\"; // 数组 // 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组： let list: number[] = [1, 2, 3]; // 相当于 js 的let list = [1, 2, 3]; // 第二种方式是使用数组泛型，Array： let list: Array = [1, 2, 3]; // 相当于 js 的let list = [1, 2, 3]; // 在 TypeScript 中，我们使用接口（Interfaces）来定义 对象 的类型。 interface Person { name: string; age: number; } let tom: Person = { name: 'Tom', age: 25 }; // 以上 对象 的代码相当于 let tom = { name: 'Tom', age: 25 }; // Any 可以随便变更类型 (当这个值可能来自于动态的内容，比如来自用户输入或第三方代码库) let notSure: any = 4; notSure = \"我可以随便变更类型\" // 不报错 notSure = false; // 不报错 // Void 当一个函数没有返回值时，你通常会见到其返回值类型是 void function warnUser(): void { console.log(\"This is my warning message\"); } // 方法的参数也要定义类型，不知道就定义为 any function fetch(url: string, id : number, params: any): void { console.log(\"fetch\"); } 不要使用如下类型Number，String，Boolean或Object， 这些类型指的是非原始的装盒对象，它们几乎没在JavaScript代码里正确地使用过。应该使用类型number，string，and boolean。 使用非原始的object类型来代替Object 不确定的类型用Any，它是可以随便变更类型的 Vue 引入 TypeScript Vue CLI 提供了内建的 TypeScript 工具支持。如果你是新创建项目，可以查看TypeScript 支持 现有的项目，首先需要安装一些必要/以后需要的插件： # 安装vue的官方插件 npm i vue-class-component vue-property-decorator -S #ts-loader typescript 必须安装，其他的相信你以后也会装上的 npm i ts-loader typescript tslint tslint-loader tslint-config-standard -D vue-class-component：强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件。 vue-property-decorator：在 vue-class-component 上增强更多的结合 Vue 特性的装饰器 ts-loader：TypeScript为 Webpack提供了 ts-loader，其实就是为了让webpack识别.ts、 .tsx文件 tslint-loader跟tslint：我想你也会在.ts .tsx文件 约束代码格式（作用等同于eslint） tslint-config-standard：tslint 配置 standard风格的约束 配置 webpack 首先找到./build/webpack.base.conf.js。 将entry中的入口文件xx.js改成xx.ts，顺便把项目文件中的xx.js也改成xx.ts，里面内容保持不变。 找到resolve.extensions 里面加上.ts 后缀 （是为了之后引入.ts的时候不写后缀） 找到module.rules 添加webpack对.ts的解析 //webpack.base.conf.js module.exports = { entry: { 'bxs-docs': './docs/docs.ts', 'bxs-demo': './docs/demo.ts' }, ... resolve: { //默认解析扩展路径，设置完成后再引入文件后可以节约后缀名 extensions: ['.js', '.vue', '.css', '.ts', '.md'], }, module: { rules: [ { test: /\\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader' }, { test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: { appendTsSuffixTo: [/\\.vue$/], } }, ... ] }, ... } ts-loader 会检索当前目录下的 tsconfig.json 文件，根据里面定义的规则来解析.ts文件（就跟.babelrc的作用一样）。tslint-loader 作用等同于 eslint-loader 添加 tsconfig.json 接下来在根路径下创建tsconfig.json文件。这里有一份参考配置，完整的配置请点击 tsconfig.json： { // 编译选项 \"compilerOptions\": { // 输出目录 \"outDir\": \"./output\", // 是否包含可以用于 debug 的 sourceMap \"sourceMap\": true, // 以严格模式解析 \"strict\": true, // 采用的模块系统 \"module\": \"esnext\", // 如何处理模块 \"moduleResolution\": \"node\", // 编译输出目标 ES 版本 \"target\": \"es5\", // 允许从没有设置默认导出的模块中默认导入 \"allowSyntheticDefaultImports\": true, // 将每个文件作为单独的模块 \"isolatedModules\": false, // 启用装饰器 \"experimentalDecorators\": true, // 启用设计类型元数据（用于反射） \"emitDecoratorMetadata\": true, // 在表达式和声明上有隐含的any类型时报错 \"noImplicitAny\": false, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 \"importHelpers\": true, // 编译过程中打印文件名 \"listFiles\": true, // 移除注释 \"removeComments\": true, \"suppressImplicitAnyIndexErrors\": true, // 允许编译javascript文件 \"allowJs\": true, // 解析非相对模块名的基准目录 \"baseUrl\": \"./\", // 指定特殊模块的路径 \"paths\": {}, // 编译过程中需要引入的库文件的列表 \"lib\": [ \"dom\", \"es2015\", \"es2015.promise\" ] } } 添加 tslint.json 在根路径下创建tslint.json文件。这里就很简单了，就是 引入 ts 的 standard 规范 { \"extends\": \"tslint-config-standard\", \"globals\": { \"require\": true } } 让 ts 识别 .vue 由于 TypeScript 默认并不支持 *.vue 后缀的文件，所以在 vue 项目中引入的时候需要创建一个 vue-shim.d.ts 文件，放在项目对应使用目录下，例如 src/vue-shim.d.ts declare module \"*.vue\" { import Vue from \"vue\"; export default Vue; } //全局变量/方法声明 declare global { interface Window { SystemJS: any; // 如果不确定类型, 可定义为any } } 意思是告诉 TypeScript *.vue 后缀的文件可以交给 vue 模块来处理。 而在代码中导入 *.vue 文件的时候，需要写上 .vue 后缀。原因还是因为 TypeScript 默认只识别 *.ts 文件，不识别 *.vue 文件： import abcd from 'components/abcd.vue' 改造 .vue 文件 import .vue 的文件的时候，要补全 .vue 的后缀，否则会提示语法错误或找不到模块 在script 标签上加上 lang=\"ts\", 意思是让webpack将这段代码识别为typescript 而非javascript vue-class-component：对 Vue 组件进行了一层封装，让 Vue 组件语法在结合了 TypeScript 语法之后更加扁平化。主要是配置以下属性： components，注册子组件 filters，过滤器 directives，注册或获取全局指令。 ... vue-property-decorator ：在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器： @Emit @Inject @Model @Prop @Provide @Watch Vue常见选项的转换 template、style模块不需要改，只需对script进行转换。 import Abcd from './Abcd.vue' import { Vue, Component, Emit, Inject, Model, Prop, Provide, Ref, Watch, PropSync } from 'vue-property-decorator' //或者 //import Vue from 'vue' //import Component, { mixins } from 'vue-class-component' //import { Emit, Inject, Model, Prop, Provide, Watch, PropSync, Ref } from 'vue-property-decorator' // 一定要用Component修饰。详情查看下一章节 @Component({ components: { Abcd } }) //Demo相当于原来的name: 'Demo' export default class Demo extends Vue { //data,直接写 count: number = 0 desc: string = '123' private tx: string = '' //用 public, private 等修飾詞來決定能不能從外部 (別的 class) 存取 // @Prop(options: (PropOptions | Constructor[] | Constructor) = {}) // @Prop装饰器接收一个参数，这个参数可以有三种写法： // Constructor，例如String，Number，Boolean等，指定 prop 的类型； // Constructor[]，指定 prop 的可选类型； // PropOptions，可以使用以下选项：type，default，required，validator。 @Prop() propA: number = 1 // readonly是typeScriptr的属性，指定为只读 // 感叹号是非null和非undefined的类型断言。如果不加，TypeScripts可能会报错\"从未被初始化过\" @Prop({ type: [String, Number], //构造器 default: 'default value', //默认值 required: true, //必传 validator() {} //检验器 }) readonly propA!: string | number //类型为Object,设置为any @Prop({ default: () => {B return {} } }) propB: any // @PropSync(propName: string, options: (PropOptions | Constructor[] | Constructor) = {}) // @PropSync装饰器与@prop用法类似，二者的区别在于，@PropSync 装饰器接收两个参数： // propName: string 表示父组件传递过来的属性名； // options: Constructor | Constructor[] | PropOptions 与@Prop的第一个参数一致； // @PropSync 会生成一个新的计算属性。 // @PropSync需要配合父组件的.sync修饰符使用 @PropSync('name', { type: String }) syncedName!: string // methods 直接在此定义 private add() { this.number++ } // 生命周期直接定义为同名屬性 created () {} mounted () {} // 计算属性 get msg () { return 'computed ' + this.demo } // @Watch(path: string, options: WatchOptions = {}) @Watch('child', { immediate: true, deep: true }) onChildChanged (val: string, oldVal: string) { if (val !== oldVal) { console.log(val) } } } 以上代码等价与： export default { name: \"Demo\", components: { Abcd }, data () { return { count: 0, desc: '123', private tx: '' } }, props: { number: { type: Number, default: 1 }, propA: { type: [String, Number], //构造器 default: 'default value', //默认值 required: true, //必传 validator() {} //检验器 }, propB: { type: Object, default: () => {B return {} } }, // @PropSync中定义的 props: { name: { type: String } } }, created () {}, mounted () {}, computed: { // @PropSync生成的计算属性 syncedName: { get() { return this.name }, set(value) { this.$emit('update:name', value) } }, msg: { return 'computed ' + this.demo } }, watch: { child: { immediate: true, deep: true, handler: 'onChildChanged' } }, methods: { onChildChanged (val: string, oldVal: string) { if (val !== oldVal) { console.log(val) } } } } @Component .vue文件中一定要用Component修饰，参数可不传。 @Component配置 vue-property-decorator不支持的属性，如: components，filters，directives等 test import Abcd from './Abcd.vue' import Component from 'vue-class-component' @Component({ components: { Abcd }, filters: {}, directives: { demo: { bind(el:any, binding:any, vnode:any, oldVnode: any) { } } } }) export default class App extends Vue {} Mixins 在TypeScript中, 我们可以这么写： // 定义要混合的类 mixins/index.ts import {Vue, Component} from 'vue-property-decorator' // 一定要用Component修饰 @Component export default class myMixins extends Vue { mixinVal: string = 'Hello Mixin' } 然后, 在其他组件中使用它： import Vue from 'vue' import Component, { mixins } from 'vue-class-component' import mixinDemo from './mixin' @Component() export default class App extends mixins(mixinDemo) { mounted () { window.console.log('mixinVal => ', this.mixinVal) } } model model是vue中的一个选项（用得比较少），它允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。 import { Vue, Component, Model } from 'vue-property-decorator' @Component export default class YourComponent extends Vue { @Model('change', { type: Boolean }) readonly checked!: boolean } 等价于： export default { model: { prop: 'checked', event: 'change' }, props: { checked: { type: Boolean } } } $emit 由@Emit修饰的函数，会在它们的原始参数之后，返回一个值。如果返回值是Promise，则在Promise执行后，再执行$emit。 如果事件的名称没有通过事件参数提供，则使用函数名。在这种情况下，camelCase名称将转换为kebabo -case。 如果@emit 对应的方法，还有别的参数，比如点击事件的 event，会在返回值之后。 也就是第三个参数。 import { Vue, Component, Emit } from 'vue-property-decorator' @Component export default class YourComponent extends Vue { count = 0 @Emit() addToCount(n: number) { this.count += n } @Emit('reset') resetCount() { this.count = 0 } @Emit() returnValue() { return 10 } @Emit() onInputChange(e) { return e.target.value } @Emit() promise() { return new Promise(resolve => { setTimeout(() => { resolve(20) }, 0) }) } } 等价于： export default { data() { return { count: 0 } }, methods: { addToCount(n) { this.count += n this.$emit('add-to-count', n) }, resetCount() { this.count = 0 this.$emit('reset') }, returnValue() { this.$emit('return-value', 10) }, onInputChange(e) { this.$emit('on-input-change', e.target.value, e) }, promise() { const promise = new Promise(resolve => { setTimeout(() => { resolve(20) }, 0) }) promise.then(value => { this.$emit('promise', value) }) } } } ref ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。 @Ref(refKey?: string)。refKey值可以为String，如果省略传输参数，那么会自动将属性名作为参数。 @Ref与@Emit的区别：@Emit在不传参数的情况下会转为 dash-case，而 @Ref不会转，为原属性名。 import { Vue, Component, Ref } from 'vue-property-decorator' import AnotherComponent from '@/path/to/another-component.vue' @Component export default class YourComponent extends Vue { @Ref() readonly anotherComponent!: AnotherComponent @Ref('aButton') readonly button!: HTMLButtonElement } 等价于 export default { computed() { anotherComponent: { cache: false, get() { return this.$refs.anotherComponent as AnotherComponent } }, button: { cache: false, get() { return this.$refs.aButton as HTMLButtonElement } } } } 另外还有些：@Inject、@Provide，不常见，这里不例举了。。。 总结 vue+webpack导入typeScript，实践过程其实并不复杂： 首先要对typescript有个初步了解，这个其实很简单，无非是对变量、函数、对象属性加了类型控制，可以查看前文中【常见的变量类型定义】，更详情的查看TypeScript 中文手册； 然后是将typescript安装到项目，新增一些配置文件，在webpack中将其引入； 最后是vue中的一些选项：data、prop、created、methods、watch、computed等的写法转换。 参考链接 Vue 如何導入 TypeScript Vue & TypeScript 初体验 vue + typescript 项目起手式 TypeScript 中文手册 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/移动端PDF预览.html":{"url":"research/移动端PDF预览.html","title":"移动端PDF预览","keywords":"","body":"移动端PDF预览 微信内置浏览器预览pdf文件，不同操作系统的表现不同： IPhone：基本可以预览各式各样的文件格式。微信自带的预览功能（不能分享，页面是微信自己的，改不了），可以直接预览PDF文件。如果图文复杂的word，微信预览也会有点错乱。 Android：打开PDF文件，会跳转到浏览器下载页面。 解决方案 通过PDF.JS来实现PDF文件的在线预览（无需下载其他插件）。其原理是将PDF文件转换成canvas/svg，在html页面上展示。 即自己开发一个页面，调用PDF.JS提供的接口，以PDF文件的地址为参数，接收接口返回的canvas或svg数据。这种自己开发的页面，还可以自行增加微信转发功能。 word文件的预览：服务端将word转成PDF文件，当然，也可以直接转换成图片。 前端我暂时没找到好的将word转换成PDF办法。服务端用linux转的话，如果图文比较复杂，会出现图文错乱的问题。 可以通过购买Window系统的服务器来转换（坑），也可以在阿里云市场购买服务（👀不太推荐，还是有点小贵的） PDF.JS pdf.js是基于HTML5技术构建的，用于展示可移植文档格式的文件(PDF)，它可以在现代浏览器中使用且无需安装任何第三方插件。 有以下两种实现方法： script标签引入方式 PDFJS.getDocument('PDF文件路径').then(pdf => { this.renderPageAsync(pdf, pdf.numPages) }) async function renderPageAsync(pdf, numPages) { for (let i = 1; i 使用npm的方式 安装：npm install pdfjs-dist -S import PDFJS from 'pdfjs-dist'; PDFJS.GlobalWorkerOptions.workerSrc = 'pdfjs-dist/build/pdf.worker.js'; 这两个文件包含了获取、解析和展示PDF文档的方法，但是解析和渲染PDF需要较长的时间，可能会阻塞其它JS代码的运行。 为解决该问题，pdf.js依赖了HTML5引入的Web Workers——通过从主线程中移除大量CPU操作（如解析和渲染）来提升性能。 PDF.js的API都会返回一个Promise，使得我们可以优雅的处理异步操作。数据返回后的渲染方法，与上方renderPageAsync方法类似。 PDFh5 pdfh5.js 是基于pdf.js和jQuery，在移动端预览PDF的插件。 支持手势捏合缩放、支持canvas、svg两种渲染模式、支持ajax、fetch两种请求方式、支持懒加载。 web/h5/移动端PDF预览手势缩放插件。支持canvas、svg两种渲染模式，支持ajax、fetch两种请求方式。支持懒加载。 有以下两种实现方法： script标签引入方式 需下载pdfh5项目下所有文件，包css、js、bcmap等。 new window.Pdfh5('#pdf_viewer', { pdfurl: 'pdf文件路径', cMapUrl: '//res.winbaoxian.com/pdfjs/web/cmaps/', renderType: 'svg' }) 使用npm的方式 安装：npm install pdfh5 -S import Pdfh5 from \"pdfh5\"; export default { ... data: { return { pdfh5: null } }, mounted() { this.pdfh5 = new Pdfh5(\"#pdf_viewer\", { pdfurl: \"\" //pdf文件路径 }); this.pdfh5.on(\"complete\", function (status, msg, time) { //监听完成事件 }) } } @import \"pdfh5/css/pdfh5.css\"; 手机兼容性 机型 编号 系统版本 备注 lenovo（白色） 08-201600-021 4.3 异常。页面一直在加载状态 oppo(深蓝) 08-201600-034 4.4.4 正常 vivo X27 - 9 正常 iphone 8 - 12.4 正常 小米 note3 08-201703-191 5.1.1 正常 注意问题 跨域问题 本地开发：webpack中添加代理 devServer: { open: false, port: 8080, // 自定义修改8080端口 proxy: { // 代理跨域 '[/pdf文件存储目录]': { target: 'https://img.xxxxx.com', changeOrigin: true } } } 修改服务器(nginx)配置 后端提供api，将pdf文件转成byte[]，然后用pdf.js解析data 版本问题 引入1.8.**版本，采用svg模式，部分手机会(如：小米 note3)有bug。 引用最新pdf.js版本 乱码问题 pdf文件因字体、编码的问题，可能出会现乱码问题，需引入一些资源文件。 //缺少GBK-EUC-H.bcmap，加载错误 https://pbf.winbaoxian.com/planBook/planbookAccessories/pdf-viewer/index.html?file=https://img.winbaoxian.com/static/app-zx-rule-pdf/allrule/tempDir/%E5%85%89%E5%A4%A7%E6%B0%B8%E6%98%8E%E4%BA%BA%E5%AF%BF%E4%BF%9D%E9%99%A9%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8%E5%85%89%E5%A4%A7%E6%B0%B8%E6%98%8E%E5%85%89%E6%98%8E%E8%B4%A2%E5%AF%8C%E9%87%8D%E5%A4%A7%E7%96%BE%E7%97%85%E4%BF%9D%E9%99%A9%E6%9D%A1%E6%AC%BE_20170622064151.pdf //解决方法 new window.Pdfh5('#pdf_viewer', { pdfurl: 'pdf文件路径', cMapUrl: '资源文件夹', //默认是相对路径'./js/cmaps/' //为减少本地项目体积，已上传到cdn：'//res.winbaoxian.com/pdfjs/web/cmaps/' }) bcmap 一词代表 二进制cmap。 CMaps(字符映射)是PostScript和其他Adobe产品中使用的文本文件，用于将字符代码映射到CID字体中的字符字形。 请参阅Adobe的此文档了解哪些CID字体适合使用。它们主要用于处理东亚书写系统。(此技术是一项传统技术，因此不应在现代工具创建的pdf中使用)。pdfjs想要显示这样的CID字体时，它需要CMap文件。 CDN 跨域问题 跨域配置在某些节点没有启效 运维强制推送一遍，目前问题已解决。 由于CDN的特性会缓存源站的响应 阿里云已帮忙解决 建议：上传PDF文件后，先在链接中预览下 内容不满一页 svg模式下，字体大小的原因，在pc端，内容显示可能会不满一页。 改用canvas模式 参考链接 PDF.js实现个性化PDF渲染（文本复制） 移动端展示pdf(在线打开pdf)-pdfh5.js、pdf.js © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/纯CSS绘制箭头.html":{"url":"research/纯CSS绘制箭头.html","title":"纯CSS绘制箭头","keywords":"","body":"纯CSS绘制箭头 用CSS即可绘制出各种箭头，无需裁剪图片，甚至没有用到 CSS3 的东西。对浏览器支持良好。 边框箭头 原理非常简单，通过截取border的部分“拐角”实现 .box_01 { padding: 10px 0; text-align: center; } .box_01 .item_01 { display: inline-block; width: 80px; height: 80px; margin: 20px 0; background: rgba(255, 0, 0, 0.1); border-color: red; border-width: 0 0 1px 1px; border-style: solid; transform: rotateZ(-45deg); } 查看DEMO 实心箭头 当元素宽、高为零，且其他边为透明颜色时，可以形一个三角形。改变各个边的宽度，即通过调整“边框”厚度可以配置出任意角度 .box_01 .item_02 { display: inline-block; width: 0; height: 0; border: 50px solid transparent; border-top-color: #0dd; } 查看DEMO 90°之外的箭头 常见的箭头设计是大于90°的，在上面例子的基础上，“压扁”或“拉长”矩形不就可以了吗?而“压扁”或“拉长”需要用skew()就能实现，只不过需要做些角度的计算。 按照width: 100px;角度120°的需求来定义边长、角度两个变量。height = width * cos(30°) = width * sin(60°)。 .box_01 .item_03 { display: inline-block; width: 100px; height: 86px; transform: rotate(-30deg) skewX(30deg); background: #e4ffe7; border-bottom: 1px solid #00ff22; border-left: 1px solid #00ff22; } 查看DEMO .box_04 { padding: 0; position: relative; height: 80px; } .box_04 .item_04 { position: absolute; left: 40%; width: 10px; height: 40px; background: #f50; } .box_04 .item_04:nth-child(1) { top: 0; transform: skewX(30deg); } .box_04 .item_04:nth-child(2) { bottom: 0; transform: skewX(-30deg); } 查看DEMO 终极实现方法 transform: matrix实现任意大小，任意方向， 任意角度的箭头 。 先把div 旋转45度， 让它成为一个 菱形 然后再伸缩，达到任意的角度， 这样就可以得到一个 任意角度的箭头。由于用到了旋转和伸缩两种变换，所以需要使用 transform: matrix(a,b,c,d,e,f) 这个变换矩阵。 .box_01 .item_05 { display: inline-block; width: 40px; height: 40px; margin-top: 20px; border-top: 2px solid #f50; border-right: 2px solid #f50; transform: matrix(0.7071067811865475, 0.7071067811865476, -0.7071067811865476, 0.7071067811865475, 0, 0); } 查看DEMO (没看懂。感兴趣的可以点击下方链接查看。lizh) 参考链接 css箭头 使用css实现任意大小，任意方向， 任意角度的箭头 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"research/网站性能测量和优化方法.html":{"url":"research/网站性能测量和优化方法.html","title":"网站性能测量和优化方法","keywords":"","body":"网站性能测量和数据统计 以用户为中心的性能指标 网页的性能，以及网页应用的运行速度不能仅用加载时间来评估。加载时间会因为用户不同而有很大的变化，具体取决于用户的设备功能以及网络状况。 但事实是，随时都有可能发生性能不佳的情况，不只限于加载期间。 应用无法迅速响应点按或点击操作，以及无法平滑滚动或产生动画效果的问题与加载缓慢一样，都会导致糟糕的用户体验。 用户关心的是总体体验，我们开发者也应如此。 所有这些性能误解有一个共同的主题，即开发者都将注意力集中在对于用户体验帮助不大甚至全无帮助的事情上。 同样地，加载时间或 DOMContentLoaded 时间等传统性能指标极不可靠，因为加载发生的时间可能与用户认为的应用加载时间对应，也可能不对应。 当用户导航到网页时，通常会寻找视觉反馈，以确信一切符合预期。 是否发生？ 导航是否成功启动？服务器是否有响应？ 是否有用？ 是否已渲染可以与用户互动的足够内容？ 是否可用？ 用户可以与页面交互，还是页面仍在忙于加载？ 是否令人愉快？ 交互是否顺畅而自然，没有滞后和卡顿？ 为了解页面何时为用户提供这样的反馈，我们定义了多个新指标： 首次绘制与首次内容绘制。 Paint Timing API 定义两个指标：首次绘制 (FP) 和 首次内容绘制 (FCP)。 这些指标用于标记导航之后浏览器在屏幕上渲染像素的时间点。 这对于用户来说十分重要，因为它回答了以下问题： 是否发生？ 这两个指标之间的主要差别在于，FP 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点。 相比而言，FCP 标记的是浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 元素。 首次有效绘制和主角元素计时 首次有效绘制 (FMP) 指标能够回答“是否有用？”这一问题。 虽然“有用”这一概念很难以通用于所有网页的方式规范化（因此尚不存在任何规范），但是网页开发者自己很清楚其页面的哪些部分对用户最为有用。 网页的这些最重要部分通常称为主角元素。 耗时较长的任务 对于用户而言，任务耗时较长表现为滞后或卡顿，而这也是目前网页不良体验的主要根源。 可交互时间 可交互时间* (TTI) 指标用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点。 应用可能会因为多种原因而无法响应用户输入： 页面组件运行所需的 JavaScript 尚未加载。 耗时较长的任务阻塞主线程（如上一节所述）。 TTI 指标可识别页面初始 JavaScript 已加载且主线程处于空闲状态（没有耗时较长的任务）的时间点。 下表概述刚刚列出的各个指标如何对应到我们希望优化的体验： 体验 指标 是否发生？ 首次绘制 (FP)/首次内容绘制 (FCP) 是否有用？ 首次有效绘制 (FMP)/主角元素计时 是否可用？ 可交互时间 (TTI) 是否令人愉快？ 耗时较长的任务（在技术上不存在耗时较长的任务） 性能分析工具 PageSpeed Insights PageSpeed Insights 能够针对移动设备和桌面设备生成网页的实际性能报告，并能够提供关于如何改进相应网页的建议。 gtmetrix 查看您网站的效果，揭示网站运行缓慢的原因，并发现优化机会。 通过配置的监视来跟踪页面性能，并通过交互式图形将其可视化。 监控页面并每天，每周或每月进行测试以确保最佳性能 使用3个可用的图表可视化性能：页面加载时间，页面大小和请求计数以及PageSpeed和YSlow得分 缩放，平移和设置日期范围以查找特定的性能历史记录 在图形上注释感兴趣的区域并提供数据上下文 根据PageSpeed / YSlow得分，页面加载时间，总页面大小等，在多种情况下设置警报 用户注册后，可以设置cookie解决登录问题 数据统计工具 Google Analytics（分析）使用入门 Omniture 大前端神器安利之 Puppeteer 实现：在node中引用puppeteer，获取网页的performance.timing，将数据存入mysql。 设置cookie解决登录问题 const browser = await puppeteer.launch({ devtools: true, headless: false, defaultViewport: { width: 375, height: 667 } }) const browserPage = await browser.newPage() await browserPage.setCookie({ name: 'token', value: '', domain: '.abc.com', path: '/', expires: 1640995200000, httpOnly: false, secure: false, sameSite: \"Strict\" }); chrome 网速预设值 Preset download(kb/s) upload(kb/s) RTT(ms) GPRS 50 20 500 Regular 2G 250 50 300 Good 2G 450 150 150 Regular 3G 750 250 100 Good 3G 1000 750 40 Regular 4G 4000 3000 20 DSL 2000 1000 5 WiFi 30000 150000 2 Lighthouse 使用 Lighthouse 对网站进行测评后，我们会得到一份评分报告，它包含了性能（Performance），PWA（Progressive Web App），访问无障碍（Accessibility），最佳实践（Best Practice），搜索引擎优化（SEO）等几个部分。 影响评分的性能指标 性能测试指标分成了 Metrics，Diagnostic，Opportunities 三部分。通常情况下，只有 Metrics 部分的指标项会对分数产生直接影响，Lighthouse 会衡量以下性能指标项： 首次内容绘制（First Contentful Paint） 即浏览器首次将任意内容（如文字、图像、canvas 等）绘制到屏幕上的时间点。 算法-首次有效渲染时间(Time to First Meaningful Paint) 首次有效绘制（First Meaningful Paint） 衡量了用户感知页面的主要内容（primary content）可见的时间。对于不同的站点，首要内容是不同的，例如：对于博客文章，标题及首屏文字是首要内容，而对于购物网站来说，图片也会变得很重要。 首次 CPU 空闲（First CPU Idle） 即页面首次能够对输入做出反应的时间点，其出现时机往往在首次有效绘制完成之后。该指标目前仍处于实验阶段。 可交互时间（Time to Interactive） 指的是所有的页面内容都已经成功加载，且能够快速地对用户的操作做出反应的时间点。该指标目前仍处于实验阶段。 速度指标（Speed Index） 衡量了首屏可见内容绘制在屏幕上的速度。在首次加载页面的过程中尽量展现更多的内容，往往能给用户带来更好的体验，所以速度指标的值约小越好。 输入延迟估值（Estimated Input Latency） 这个指标衡量了页面对用户输入行为的反应速度，其基准值应低于 50ms。 性能优化方案 懒加载(动态加载) 懒加载或者按需加载，是一种很好的优化网页或应用的方式。尤其是内容较多的页面。减少页面初始化时，需要加载的JS文件体积 这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。 export default { ... components: { Abc: () => import('./abc.vue') }, ... } https://juejin.im/post/59bf501ff265da06602971b9 Vue路由和组件的懒加载 按需加载 使用babel-plugin-component实现按需引入、打包。过滤无用模块，减少JS文件体积 修改.babelrc配置： //.babelrc { ... \"plugins\": [ \"transform-runtime\", [ \"component\", [ { \"libraryName\": \"mint-ui\", \"style\": true }, { \"libraryName\": \"bxs-ui-vue\", \"libDir\": \"lib\", \"style\": \"index.css\" } ] ] ], ... } 外部扩展(externals) 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。 //html文件引入js //webpack.base.conf.js module.exports = { ... externals: { vue: 'Vue' }, ... } 静态方件上传到CDN //webpack.prod.conf.js const AliOSSPlugin = require('webpack-alioss-plugin') webpackConfig.plugins.push(new AliOSSPlugin({ project: '', // 项目名(用于存放文件的直接目录) })) 骨架屏 page-skeleton-webpack-plugin(饿了么) Page Skeleton 是一款 webpack 插件，该插件的目的是根据你项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。 有以下特点： 支持多种加载动画 针对移动端 web 页面 支持多路由 可定制化，可以通过配置项对骨架块形状颜色进行配置，同时也可以在预览页面直接修改骨架页面源码 几乎可以零配置使用 测试结果（lizh）： 骨架元素的结构跟实际的页面有差异 骨架页面元素的大小无法自适应 即无法参数配置html的fontSize值 只适用vue-router项目（单页面项目） 注入的js是根目录的，不是当前页面的；且生成文件路径的跟现有不一样(planbookInput项目) 不适用页面内容不固定的页面 比如：有些页面需要根据URL中的传参，展示不同内容。生成骨架屏时无法预知 vue-skeleton-webpack-plugin(百度) 基于 Vue 的 webpack 插件，为单页/多页应用生成骨架屏 skeleton，减少白屏时间，在页面完全渲染之前提升用户感知体验。 有以下不足： 需要手动去写骨架屏的样式 骨架屏样式在不同尺寸下的响应式问题 在界面改动之后也需要手动修改对应的骨架屏 骨架页面的组件无法热更新 (官方说法是已经支持了，没找到原因) draw-page-structure(京东) 提供两种方法来盛放生成的骨架屏节点： 配置 output.filepath，如果配置的是目录，会写入到该目录里的 index.html (没有的话我们会创建)文件里； 自定义写入的方式 writePageStructure: (outputHtml: string) => void;； 如果前面两种方式您都没有提供，那么将会在您当前目录下创建 index.html ，并将骨架屏节点写入； 有以下不足： 登录问题，解决方法不是很友好 (查看解决方法)。 生成的样式，不太美观 Vue SSR 服务端渲染 什么是服务器端渲染 (SSR)？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序。 服务器渲染的 Vue.js 应用程序也可以被认为是\"同构\"或\"通用\"，因为应用程序的大部分代码都可以在服务器和客户端上运行。 这里说的渲染，就是指生成 HTML 文档的过程。简单来说， 浏览器端渲染，指的是用 JS 去生成 HTML，例如 React, Vue 等前端框架做的路由。 服务器端渲染，指的是用后台语言通过一些模版引擎生成 HTML，例如 Java 配合 VM 模版引擎、NodeJS配合 Jade 等，将数据与视图整理输出为完整的 HTML 文档发送给浏览器。 为什么使用服务器端渲染 (SSR)？ 与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于： 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。 也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。 无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。 使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 是否真的需要使用服务器端渲染 (SSR)？ 在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。 这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。 如何看一个网页是否是服务器端渲染？ 简单的方式是在 Chrome 浏览器打开控制台/开发者工具，查看 Network 中加载的资源。浏览器端渲染，html文档的body节点中只有一个div节点和css/js文件引用。其他节点是在浏览器中，js生成的。 参考链接 蚂蚁金服如何把前端性能监控做到极致? 一种自动化生成骨架屏的方案 前端骨架屏方案小结 Vue SSR 指南 带你走近Vue服务器端渲染（VUE SSR） © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"tech/03-curl的用法指南.html":{"url":"tech/03-curl的用法指南.html","title":"Curl的用法指南","keywords":"","body":"curl的用法指南 curl 是一个开源的用于数据传输的命令行工具与库，它使用 URL 语法格式，支持众多传输协议，包括：HTTP、HTTPS、FTP、FTPS、GOPHER、TFTP、SCP、SFTP、SMB、TELNET、DICT、LDAP、LDAPS、FILE、IMAP、SMTP、POP3、RTSP和RTMP。curl 库提供了很多强大的功能，你可以利用它来进行 HTTP/HTTPS 请求、上传/下载文件等，且支持 Cookie、认证、代理、限速等。 curl使用实例 url访问：直接加上要访问的网址。curl 默认发出 GET 请求，服务器返回的内容会在命令行输出。 curl https://www.example.com 重定向跟踪：页面使用了301|303 等重定向，可以添加 -L 参数来跟踪 URL 重定向。 curl -L https://www.example.com 页面保存：将页面源码保存到本地。 -o/--output 必须输入保存文件名，-O/--remote-name 保留远程文件的文件名。 curl https://www.example.com >> example.html curl -o example.html https://www.example.com curl -O https://www.example.com/index.html 查看头信息：使用 -i参数，页面响应头会和页面源码（响应体）一块返回；使用-I或--head参数，只返回向应头。 curl -i https://www.example.com curl -I https://www.example.com curl --head https://www.example.com HTTP请求方法：curl 支持所有 HTTP 请求方法，默认使用 get 请求，可以通过 -X 参数指定。 # 获取ip地址 curl http://ip-api.com/json curl -X DELETE https://www.example.com/api/delete/xxx curl -X POST --data 'keyword=example' https://www.example.com/api/[delete_api] HTTPS支持：curl 可以直接访问 HTTPS 协议。如果使用的本地 ssl证书 认证的 HTTPS，可以通过-E或--cert参数指定本地证书。 curl -E my_cert.pem https://www.example.com 添加请求头：通过 -H 或 --header 参数来指定请求头。多次使用 -H 或 --header 参数可指定多个请求头。 $ curl -H 'Content-Type:application/json' -H 'Authorization: ndhielsi.ighhgeuwj' https://www.example.com Cookie支持：通过 --cookie 参数指定发送请求时的 Cookie 值，也可以通过 -b [文件名] 来指定一个存储了 Cookie 值的本地文件。 curl --cookie 'token=1234' https://www.example.com curl -b my_cookies.txt https://www.example.com Cookie 值可能会被服务器所返回的值所修改，并应用于下次 HTTP 请求。这时，可以能过 -c 参数指定存储服务器返回 Cookie 值的存储文件。 curl -b my_cookies.txt -c newcookies.txt https://www.example.com 文件上传：使用 -T 或 --upload-file 上传文件。 curl -T ./index.html https://www.example.com/api/[upload_api] 伪造来源地址：修改请求 Header 中的 referer 信息。 curl -e http://localhost https://www.example.com 请求代理：指定 HTTP 请求的代理。 curl -x 123.45.67.89:1080 https://www.example.com 循环下载： curl -O http://mydomain.net/~zzh/screen[1-10].JPG curl -O http://mydomain.net/~{zzh,nick}/[001-201].JPG curl -o #2_#1.jpg http://mydomain.net/~{zzh,nick}/[001-201].JPG 分块下载： curl -r 0 -10240 -o \"zhao.part1\" https://www.example.com/media/zhao1.mp3 &\\ curl -r 10241 -20480 -o \"zhao.part1\" https://www.example.com/media/zhao1.mp3 &\\ curl -r 20481 -40960 -o \"zhao.part1\" https://www.example.com/media/zhao1.mp3 &\\ curl -r 40961 - -o \"zhao.part1\" https://www.example.com/media/zhao1.mp3 限制网速：限制 HTTP 请求和回应的带宽，模拟慢网速的环境。 curl --limit-rate 200k https://www.example.com curl语法及选项 语法 curl [options...] 参数选项 # 调试类 -v, --verbose URL 输出请求中访问的路由信息 -q, --disable 在第一个参数位置设置后 .curlrc 的设置直接失效，这个参数会影响到 -K, --config -A, --user-agent -e, --referer -K, --config FILE 指定配置文件 -L, --location 跟踪重定向 (H) # CLI显示设置 -s, --silent Silent模式。不输出任务内容 -S, --show-error 显示错误. 在选项 -s 中，当 curl 出现错误时将显示 -f, --fail 不显示连接失败时HTTP错误信息 -i, --include 显示response的header (H/F) -I, --head 仅显示响应文档头 -l, --list-only 只列出FTP目录的名称 (F) -#, --progress-bar 以进度条 显示传输进度 # 数据传输类 -X, --request [GET|POST|PUT|DELETE|…] 使用指定的 http method 例如 -X POST -H, --header 设定 request里的header 例如 -H \"Content-Type: application/json\" -e, --referer 设定 referer (H) -d, --data 设定 http body 默认使用 content-type application/x-www-form-urlencoded (H) --data-raw ASCII 编码 HTTP POST 数据 (H) --data-binary binary 编码 HTTP POST 数据 (H) --data-urlencode url 编码 HTTP POST 数据 (H) -G, --get 使用 HTTP GET 方法发送 -d 数据 (H) -F, --form 模拟 HTTP 表单数据提交 multipart POST (H) --form-string 模拟 HTTP 表单数据提交 (H) -u, --user 服务器帐户，密码 例如 admin:password -b, --cookie cookie 文件 (H) -j, --junk-session-cookies 读取文件中但忽略 session cookie (H) -A, --user-agent user-agent设置 (H) # 传输设置 -C, --continue-at OFFSET 断点续转 -x, --proxy [PROTOCOL://]HOST[:PORT] 在指定的端口上使用代理 -U, --proxy-user USER[:PASSWORD] 代理用户名及密码 # 文件操作 -T, --upload-file 上传文件 -a, --append 添加要上传的文件 (F/SFTP) # 输出设置 -o, --output 将输出写入文件，而非 stdout -O, --remote-name 将输出写入远程文件 -D, --dump-header 将头信息写入指定的文件 -c, --cookie-jar 操作结束后，要写入 Cookies 的文件位置 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-15 00:07:16 "},"tech/04-sublime3插件篇.html":{"url":"tech/04-sublime3插件篇.html","title":"Sublime3插件篇","keywords":"","body":"sublime3 插件篇 插件管理工具 错误安装(不可用) 按Ctrl + `(此符号为tab按键上面的按键) 调出console，粘贴以下代码到命令行并回车： import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 遗憾的是：Sublime text 3已经不支持Package Control安装插件了！ 正确安装（可用） 手动下载一个package control的包：https://github.com/wbond/package_control。 下载解压后，将解压文件重新命名为：Package Control，拷贝到sublime 的packages目录下。可以直接菜单栏Perferences -->Browse Packages打开。 严格按照上面明明，首字母记住要大些！！！ 重启sublime，点击菜单栏Perferences，会发现多了Package Settings 和Package Control这两个菜单，这就说明 Package Control安装成功了。 尝试下安装一个插件，如Emmet。Ctrl +Shift+P 打开控制台，输入install，选择Install Package。此时要等待一会，因为Package Control 正在加载插件列表。 但是很不幸，又失败了！控制台提示无法访问https://packagecontrol.io/channel_v3.json。这个应该也是被墙了... 不过，别慌！这是可以解决的。 打开Package Settings-->Package Control --> Settings User，加入如下内容： \"channels\": [ \"http://cst.stu.126.net/u/json/cms/channel_v3.json\"] http://cst.stu.126.net/u/json/cms/channel_v3.json是个国内的战点 常用插件列表 官网插件库 用Package Control安装插件的方法：按下Ctrl+Shift+P调出命令面板，输入install调出Install Package选项，然后在列表中选中要安装的插件。 注意：安装插件时保持网络畅通，避免插件由于网络原因奔溃 Emmet（原名 Zen Coding） 一种快速编写html/css的方法。 安装Emmet的同时，也会自动安装其依赖PyV8 binary库，安装PyV8库会用较长时间，可以在Sublime左下角看到安装进程状态。 html5 支持hmtl5规范的插件包。 使用方法：新建html文档 -> ! -> 敲击Tab键 -> 自动补全html5规范文档。 javascript-API-Completions 支持Javascript、JQuery、Twitter Bootstrap框架、HTML5标签属性提示的插件，是少数支持sublime text 3的后缀提示的插件，HTML5标签提示sublime text 3自带，不过JQuery提示还是很有用处的，也可设置要提示的语言。 JSFormat JS代码格式化插件。 使用方法：使用快捷键ctrl+alt+f SublimeLinter 一个支持lint语法的插件，可以高亮linter认为有错误的代码行，也支持高亮一些特别的注释，比如“TODO”，这样就可以被快速定位。（IntelliJ IDEA的TODO功能很赞，这个插件虽然比不上，但是也够用了吧） BracketHighlighter 类似于代码匹配，可以匹配括号，引号等符号内的范围。 使用方法：系统默认为白色高亮，可以使用链接所述方法进行自定义配置 Alignment 代码对齐，如写几个变量，选中这几行，Ctrl+Alt+A，哇，齐了。 Ctags 函数跳转，我的电脑上是Alt+点击 函数名称，会跳转到相应的函数 DocBlockr 注释插件，生成幽美的注释。标准的注释，包括函数名、参数、返回值等，并以多行显示，省去手动编写。 SideBarEnhancements 侧栏右键功能增强，非常实用 DocBlockr 支持对函数、变量的快捷注释 FileHeader 新建文件时，增加文件头注释 常见问题 设置默认浏览器和快捷键 安装插件 SideBarEnhancements 选择浏览器打开 html：在左侧栏中，右键 html 文件，单击右键菜单栏中 Open In Browser，选择浏览器 设置默认浏览器和快捷键：preferences -> Package Settings -> Side Bar -> Setting User，添加设置： [ { \"keys\":[\"f10\"], \"command\":\"side_bar_files_open_with\", \"args\":{ \"paths\":[], \"application\":\"C:/Users/lizhao/AppData/Local/Google/Chrome/Application/chrome.exe\", \"extensions\":\".*\" } } ] © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-11 21:15:33 "},"tech/05-Charles安装及使用.html":{"url":"tech/05-Charles安装及使用.html","title":"Charles安装及使用","keywords":"","body":"Charles安装及使用 Charles 是一个 HTTP 代理 / HTTP监视器 / 反向代理，使开发人员能够查看计算机和网络之间的所有 HTTP 和 SSL / HTTPS 流量。 这包括请求、响应和 HTTP 报头（其中包含 cookie 和缓存信息）。 ——Charles Charles 是 MacOS 上的最常用的抓包工具。 抓包（packet capture） 就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 主要功能 截取 Http、Https、SSL 请求的网络数据。 支持请求重定向，即请求映射，包括本地映射和远程映射。使用场景：将线上资源映射到本地某个文件夹下，在本地文件（如，css、JavaScript 等文件）代码中调试一些线上才能重现的 bug（即，数据是线上的环境，前端代码在本地，方便在线调试）。 支持重发网络请求（用于服务端调试）。 支持修改网络请求参数。 支持网络请求的劫持并动态修改。 支持模拟慢速网络。如，模仿移动设备上的 2G/3G/4G 的访问。 支持反向代理。 支持 SOCKS 代理 。Socks 代理是基于 Socks 协议的一种代理，也叫全能代理。与其他类型的代理不同，它只是简单地传递数据包，而并不关心是何种应用协议，既支持 TCP 协议又支持 UDP 协议。所以 SOCKS 代理服务器比其他类型的代理服务器速度要快得多。 Charles的安装 安装 JDK：Charles 由 Java开发，需要先安装好 JDK。?? 安装Charles：下载安装包 -> 安装。 破解：Charles 是付费软件，网上也有破解版下载。也可以用网上热心网友提供的信息完成注册：Help -> registered Registered Name: https://zhile.io License Key: 48891cf209c6d32bf4 代理配置 设置系统代理 Charles 通过将自己设置成代理服务器来截取数据。所以使用 Charles 的第一步是将其设置成系统的代理服务器。 点击菜单栏 proxy -> macOS Proxy，打开配置面板： Proxy Settings：设置端口等参数，端口一般默认 8888。 Enable transparent HTTP proxying：允许代理 HTTP 请求。 SSL Proxying Settings：设置允许抓取 https 请求。 该选项需要勾选 Enable SSL Proxying，并添加一条 Location规则： 需要注意的是： Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成系统的代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。 以 Mac 下的 Chrome 为例：在 C'hrome 浏览器的地址栏右侧的三个。。。 -> 设置 -> 系统 -> 打开您计算机的代理设置，或者在 MAC 左上角的苹果ICON -> 系统偏好设置 -> 网络偏好设置 -> 高级 -> 代理 打开配置面板。将 【网页代理(HTTP)】 和 【安全网页代理(HTTPS)】 的网页代理服务器的 IP 设置为 Charles 服务的 IP，如：127.0.0.1 、8888。 以 Window（10） 下的 Chrome 为例：在 C'hrome 浏览器的地址栏右侧的三个。。。 -> 设置 -> 系统 -> 打开您计算机的代理设置，或者 windows开始 -> 设置 -> 网络和internet -> 代理 打开配置面板。将 【手动设置代理 】的代理服务器的 IP 设置为 Charles 服务的 IP，如：127.0.0.1 、8888。 设置移动端代理 移动端可以使用 PC 端启动的 Charles 代理服务。（注意：移动端和 PC 端设备必需使用同一 wifi） 移动端配置代理服务器（以 iPhone 为例）： 设置手动代理：设置 -> 无线局域网 -> 【当前连接的 wifi 名】 -> 配置代理，将代理切换为【手动】，写入启动 Charles 服务的 电脑的 IP 和 端口号： 主机名：查看 Charles 下，help -> Local IP Addresses。 端口：查看 Charles 下，Proxy -> Proxy Settings。 安装证书。具体可查看下文【移动端证书安装】 打开任意需要网络通讯的程序，可以看到 Charles 弹出请求连接的确认菜单。点击 “Allow” 即可完成设置。 证书安装 系统证书安装 安装证书：Charles 下，help -> SSL Proxying -> Install Charles Root Certificate。在安装过程中，需要指定证书的存放位置。 开启 SSL proxy：Charles 下，proxy -> SSL proxy。Charles 默认也并不截取 Https 网络通讯的信息。如果需要截取 Https 网络请求，需配置该选项。 注意： 如果 Charles 安装的证书，没有添加到受信任根证书列表中，Chrome 浏览器访问 https 地址时，会出现如下报错： 解决： 重新安装证书，并将证书添加到受信任根证书列表。 浏览器证书安装 安装证书：Charles 下，点击 Help -> SSL Proxying -> Install Charles Root Certificate on a Mobile Device or Remote Browser，出现如下提示信息： 根据提示，在浏览器地址栏输入 chls.pro/ssl 下载证书。 浏览器配置：以 Chrome 为例。在浏览器中输入 chrome://settings，找到 隐藏设置和安全性 -> 更多 -> 管理证书。 注意： 如果证书安装后，还是会出现 ，可能是浏览器没有信任某种请求方式。比如：methods: connect。 注意： 如果浏览器没有安装证书，则 Charles 抓取 Chrome 浏览器的 Https 请求，可能会出现 异常： 移动端证书安装 IOS 客户端 打开 Charles，选择 help→SSL Proxying→Install Charles Root Certificate on a Mobile Device or Remote Browser。 移动端设备代理配置好后，打开 Safari，访问 chls.pro/ssl 下载证书。如果无法访问 chls.pro/ssl，尝试用 http://chls.pro/ssl 或 https://chls.pro/ssl。 证书下载下来是一个 *.pem 的文件，重命名为 *.crt 文件，不然无法安装。有的浏览器直接下载下来就是 *.crt 文件，看运气。 点击文件，安装证书。手机提示「此网站正尝试打开“设置”已向您显示一个配置描述文件。您要允许吗？忽略|允许」，选择允许，安装描述文件，并信任。 iOS10.3 以上的手机需要在，设置 → 通用 → 关于本机 → 证书信任设置→ charles proxy CA 证书，添加信任。 Android 客户端 Android 机，可能无法自动安装，可以手动安装。安卓手机类型众多，所以有些不太一样。 以 oppo R11 为列：设置 -> 其他设置 -> 安全与隐私 -> 从存储设备安装证书，找到下载的证书文件。 方法一： 打开 Charles，选择 help→SSL Proxying→Install Charles Root Certificate on a Mobile Device or Remote Browser。 设置手机代理，打开浏览器，输入网址 chls.pro/ssl。 手机弹出提示『安装配置描述文件。您要允许吗？忽略|允许』，选择允许。 方法二： 打开 Charles，选择 help -> SSL Proxying -> Save Charles Certificate，将证书导入到手机中。 导入后直接点击安装证书即可。 如果提示无法打开，需要进入手机 设置 -> 更多设置 -> 系统安全 -> 从存储设备安装 -> 选择charles.pem，点击高级，安装证书。 Charles使用 过滤网络请求 对网络请求进行过滤，有以下几种办法： 方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。 方法二：在 Charles 的菜单栏选择 Proxy -> Recording Settings，然后选择 Include栏，选择添加一个项目，然后填入需要监控的协议、主机地址、端口号。适用经常性的封包过滤。 方法三：在想过滤的网络请求上右击，选择 Focus。 模拟慢速网络（Throttle Setting） 移动开发中，常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。 在 Charles 的菜单上，选择 Proxy -> Throttle Setting 项，在配置面板中，勾选 Enable Throttling ，修改 Throttle Preset 的选项。 如果只想模拟指定网站的慢速网络，可以勾选的 Only for selected hosts 项，添加指定的 hosts： 重发网络请求 有时为调试服务器的接口，需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 Edit，即可创建一个可编辑的网络请求。 可以修改请求的任何信息，包括 URL 地址、端口、参数等，之后点击 Execute 即可发送该修改后的网络请求。 服务器压力测试（Repeat） 使用 Charles 的 Tools -> Repeat 功能来简单地测试服务器的并发处理能力。 在需要测试的网络请求上右击，然后选择 「Repeat Advanced」菜单项，如下所示： 请求重定向（Map） Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。 Charles 的 Map 功能分 Map Remote 和Map Local两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。 Map Remote 在 Charles 的菜单中，选择 Tools -> Map Remote 进入配置面板，填写网络重定向的源地址和目的地址（不需要限制的条件可留空）。 比如，将所有 192.168.188.98:9600（本地服务器）的请求重定向到了 192.168.190.47（其他服务器）： 注： path 参数，前面必需加 '/'。 注意： Map remote 可解决跨域问题。但 localhost 域名不会被拦截，可改用192.168.xxx.xxx。如果是通过 cookie 中的 token 判断登录，需要手动在 cookie 中设置 token。 Map Local 在 Charles 的菜单中，选择 Tools -> Map Local 进入配置面板，填写的重定向的源地址和本地的目标文件。 对于有一些复杂的网络请求结果，可以先使用 Charles 提供的 Save Response… 功能，将请求结果保存到本地，然后稍加修改，成为本地环境下的目标映射文件。比如，将一个远程网络请求通过映射到一个本地文件中： 实用场景： 线上数据原因导致异常，测试环境或本地无法重现，而线上的 JavaScript 是压缩过的，debug 比较困难。这时候，可以访问线上出错的页面，然后将 JavaScript 资源的请求重定向到本地对应的未压缩的 JavaScript 文件。 注意： 使用中有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了 Http Response Header 中的部分内容，就会使得该功能失效。解决办法是，使用下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成希望的内容。 重写请求/响应数据（Rewrite） Rewrite 功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。 重写请求/响应数据（临时）（Breakpoints） Rewrite 功能适合做批量和长期的替换，Breakpoints 功能则适合做一些临时性的修改。 Breakpoints 功能类似在调试工具中设置断点，当指定的网络请求发生时，Charles 会截获该请求，然后在 Charles 中临时修改网络请求的返回内容。常用于只想临时修改一次网络请求结果，当然，使用 Rewrite 功能也可以达到目的，但是过于麻烦。 在 Charles 的菜单中，选择 proxy -> Breakpoint Settings 进入配置面板，完成配置后，接口调用时会进入暂停状态，此时，允许修改请求信息。修改后，点击 Execute 则可以让网络请求继续进行。 注意： 使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。 正向/反向代理 正向代理 客户端想从目标服务器请求资源数据，但是其本身不能直接请求目标服务器，只能通过 proxy 服务器才能拿到。也就是，客户端向目标服务器请求数据，实际上是向 proxy 服务器发起请求，再由 proxy 服务器向目标服务器发起请求，并将响应数据返回给客户端。这种情况，客户端是明确知道最终要访问的是谁。 正向代理典型的案例是翻墙。 反向代理 客户端发起请求时，并不知道最终是访问哪一台。它想访问的就是 Proxy 服务器，并且让 Proxy 服务器来决定请求的数据来源哪台服务器。实际上，proxy 服务器接收用户请求时，会转发到服务器中的随机（算法）某一台。这种情况，客户端不知道，也不关心最终访问的是谁。 反向代理典型的案例是负载均衡。 反向代理配置（reverse proxies） Charles 的反向代理功能允许将本地的端口映射到远程的另一个端口上，在 Charles 的菜单中，选择 proxy -> reverse proxies 进入配置面板： 解决与代理服务器的冲突（External Proxy Settings） shadowsocks 类的代理软件，会对 charles 造成影响。 Charles 的原理是把自己设置成系统的代理服务器，但是在国内，由于工作需要，常常需要使用 Google 搜索，所以大部分程序员都有自己的翻墙软件，而这些软件的基本原理，也是把自己设置成系统的代理服务器，来做到透明的翻墙。 为了解决两者冲突，在 Charles 的 External Proxy Settings 中，设置翻墙的代理端口以及相关信息。同时，也要其他代理服务器的自动设置，使其不主动修改系统代理，避免 Charles 失效。 常见问题 Https链接无法访问 没有开启 SSL Proxying Setting -> enable SSL Proxying，或者其中的 location 规则没加。 系统证书没有安装到根证书信任列表中。 解决： 参考上文【证书安装】。 抓包请求出现 证书没有安装，或者证书没有添加到信任列表中。 解决： 参考上文【证书安装】。 参考资料 Charles安装与使用 踩坑记：Charles 打不开 HTTPS ，显示您的连接不是私密连接 Charles问题之Windows10下抓取https包，出现unknown © lizhao all right reserved，powered by Gitbook文件修订时间： 2023-01-14 13:02:37 "},"tech/10-nginx基础使用.html":{"url":"tech/10-nginx基础使用.html","title":"Nginx基础使用","keywords":"","body":"Nginx基础使用 Nginx 是一款轻量级的 Web 服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。 安装及使用 brew 又叫 Homebrew，是 Mac 中的一款软件包管理工具，通过 brew 可以很方便的在 Mac 中安装软件或者是卸载软件。 一般 Mac 电脑会默认安装有 brew。 # 搜索 brew search nginx # 安装 brew install nginx # 卸载 brew uninstall nginx # 升级 sudo brew update # 查看安装信息 sudo brew info nginx # 查看已经安装的软件 brew list 安装： brew install nginx 。 安装扩展模块 以 echo-nginx-module 为例： 下载 并解压 echo-nginx-module。 添加 echo-nginx-module 模块： 解压后的目录可以放到任何位置，但需要告诉 nginx 该扩展模块的位置。在终端用 --add-module 指定模块位置。 cd /usr/local/Cellar/nginx/1.21.1 ./configure --add-module=/usr/local/Cellar/nginx/1.21.1/echo-nginx-module-0.62 编译并重新安装。 make 是用来编译的，它从 Makefile 中读取指令，然后编译。 make install 是用来安装的，它也从 Makefile 中读取指令，安装到指定的位置。 make make install # 这时侯切记不要make install, 因为 make install 就会把文件复制到安装目录 检验并启动。 sudo /usr/local/nginx/sbin/nginx -v sudo /usr/local/nginx/sbin/nginx 注意： 用 brew install nginx 安装，目录下没有 ./configure 程序。需要在官网下载安装包，解压，再执行如上步骤。 路径与配置 安装完以后，可以在终端输出的信息里看到一些配置路径： /usr/local/etc/nginx/nginx.conf： 配置文件路径； /usr/local/var/www： 服务器默认路径，即默认 HTML 文件存放路径； /usr/local/Cellar/nginx/1.21.1： nginx 的安装路径； /usr/local/bin/nginx： nginx 执行文件； /usr/local/var/log/nginx/error.log：报错日志。 怎么彻底卸载Nginx？ 关闭 nginx（如果已启动）：nginx -s stop； 卸载 nginx：brew uninstall nginx； 检查 nginx 是否在运行：ps -ef | grep nginx； 停止 nginx 进程：kill -9 [上一步查出来的nginx进程号]； 查找所有名字包含 nginx 的文件：find / -name nginx； 删除 nignx 安装的相关文件：rm -rf /usr/local/nginx； Nginx的一些命令 Nginx 自己的命令： # 打开终端运行命令 nginx # 启动Nginx。 # nginx 会在 /usr/local/var/run/ 路径下创建一个名为 nginx.pid 的文件 nginx -s reload # 重新加载配置 # 但前提是 /usr/local/var/run/ 路径下必须存在 nginx.pid 文件 nginx -s reopen # 重启 nginx -s stop # 停止 # nginx 会将 /usr/local/var/run/ 路径下名为nginx.pid 的文件删除掉。 # 但前提是/usr/local/var/run/ 路径下必须存在 nginx.pid 文件 nginx -s quit # 退出 nginx nginx -V # 查看版本，以及配置文件地址 nginx -v # 查看版本 nginx -c filename # 指定配置文件 nginx -h # 帮助 nginx -t # 测试配置是否有语法错误 brew services 命令： # brew services [-v|--verbose] [list | run | start | stop | restart | cleanup] [...] brew services start nginx # 启动Nginx服务 brew services stop nginx # 停止Nginx服务 brew services restart nginx # 重启Nginx服务 Nginx的配置文件 根据安装的提示，配置文件的路径：/usr/local/etc/nginx/nginx.conf。 Nginx 的主配置文件是 nginx.conf，这个配置文件一共由三部分组成，分别为全局块、events块和http块。在http 块中，又包含 http 全局块、多个 server 块。每个 server 块中，可以包含 server 全局块和多个 location 块。在同一配置块中嵌套的配置块，各个之间不存在次序关系。 配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一个块的。同一个指令放在不同层级的块中，其作用域也不同，一般情况下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。如果某个指令在两个不同层级的块中同时出现，则采用“就近原则”，即以较低层级块中的配置为准。比如，某指令同时出现在 http 全局块中和 server 块中，并且配置不同，则应该以 server 块中的配置为准。 打开文件编辑里面的内容： user nginx; worker_processes 1; #error_log /var/log/nginx/error.log warn; #pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; #access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; server { listen 9600; server_name localhost; location / { root /html; index index.html index.htm; } location /api { proxy_pass http://example.com; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 全局块 全局块是默认配置文件从开始到 events 块之间的一部分内容，主要设置一些影响 Nginx 服务器整体运行的配置指令，因此，这些指令的作用域是 Nginx 服务器全局。 通常包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数、Nginx 进程 PID 存放路径、日志的存放路径和类型以及配置文件引入等。 events块 events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接。常用到的设置包括是否开启对多 worker process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型处理连接请求，每个 worker process 可以同时支持的最大连接数等。 这一部分的指令对 Nginx 服务器的性能影响较大，在实际配置中应该根据实际情况灵活调整。 http块 http 块是 Nginx 服务器配置中的重要部分，代理、缓存和日志定义等绝大多数的功能和第三方模块的配置都可以放在这个模块中。 前面已经提到，http 块中可以包含自己的全局块，也可以包含 server 块，server 块中又可以进一步包含 location 块，使用 “http全局块” 来表示 http 中自己的全局块，即 http 块中不包含在 server 块中的部分。 可以在 http 全局块中配置的指令包括文件引入、MIME-Type 定义、日志自定义、是否使用 sendfile 传输文件、连接超时时间、单连接请求数上限等。 server块 server 块和“虚拟主机”的概念有密切联系。 虚拟主机，又称虚拟服务器、主机空间或是网页空间，它是一种技术。该技术是为了节省互联网服务器硬件成本而出现的。这里的“主机”或“空间”是由实体的服务器延伸而来，硬件系统可以基于服务器群，或者单个服务器等。虚拟主机技术主要应用于 HTTP、FTP 及 EMAIL 等多项服务，将一台服务器的某项或者全部服务内容逻辑划分为多个服务单位，对外表现为多个服务器，从而充分利用服务器硬件资源。从用户角度来看，一台虚拟主机和一台独立的硬件主机是完全一样的。 在使用 Nginx 服务器提供 Web 服务时，利用虚拟主机的技术就可以避免为每一个要运行的网站提供单独的 Nginx 服务器，也无需为每个网站对应运行一组 Nginx 进程。虚拟主机技术使得 Nginx 服务器可以在同一台服务器上只运行一组 Nginx 进程，就可以运行多个网站。 在前面提到过，每一个 http 块都可以包含多个 server 块，而每个 server 块就相当于一台虚拟主机，它内部可有多台主机联合提供服务，一起对外提供在逻辑上关系密切的一组服务（或网站）。 和 http 块相同，server 块也可以包含自己的全局块，同时可以包含多个 location 块。在 server 全局块中，最常见的两个配置项是本虚拟主机的监听配置和本虚拟主机的名称或IP配置。 listen指令 server块中最重要的指令就是 listen 指令，这个指令有三种配置语法。这个指令默认的配置值是：listen :80 | :8000；只能在 server 块种配置这个指令。 listen 127.0.0.1:8000; # 只监听来自127.0.0.1这个IP，请求8000端口的请求 listen 127.0.0.1; # 只监听来自127.0.0.1这个IP，请求80端口的请求（不指定端口，默认80） listen 8000; # 监听来自所有IP，请求8000端口的请求 listen *:8000; # 和上面效果一样 listen localhost:8000; # 和第一种效果一致 server_name指令 用于配置虚拟主机的名称。 对于name 来说，可以只有一个名称，也可以由多个名称并列，之间用空格隔开。每个名字就是一个域名，由两段或者三段组成，之间由点号 “.” 隔开。 server_name localhost myserver.com; Nginx 服务器规定，第一个名称作为此虚拟主机的主要名称。 在 name 中可以使用通配符 “*”，但通配符只能用在由三段字符串组成的名称的首段或尾段，或者由两段字符串组成的名称的尾段，如： server_name myserver.* *.myserver.com 由于 server_name 指令支持使用通配符和正则表达式两种配置名称的方式，因此在包含有多个虚拟主机的配置文件中，可能会出现一个名称被多个虚拟主机的 server_name 匹配成功。那么，来自这个名称的请求到底要交给哪个虚拟主机处理呢？Nginx 服务器做出如下规定： 对于匹配方式不同的，按照以下的优先级选择虚拟主机，排在前面的优先处理请求。 ① 准确匹配 server_name ② 通配符在开始时匹配 server_name 成功 ③ 通配符在结尾时匹配 server_name 成功 ④ 正则表达式匹配 server_name 成功 在以上四种匹配方式中，如果 server_name 被处于同一优先级的匹配方式多次匹配成功，则首次匹配成功的虚拟主机处理请求。 location块 每个 server 块中可以包含多个 location 块。在整个 Nginx 配置文档中起着重要的作用，而且 Nginx 服务器在许多功能上的灵活性往往在 location 指令的配置中体现出来。 location 块的主要作用是，基于 Nginx 服务器接收到的请求字符串（例如， server_name/uri-string），对除虚拟主机名称（也可以是IP别名，后文有详细阐述）之外的字符串（前例中“/uri-string”部分）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能都是在这部分实现。许多第三方模块的配置也是在 location 块中提供功能。 在Nginx的官方文档中定义的location的语法结构为： location [ = | ~ | ~* | ^~ ] uri { ... } 其中，uri 变量是待匹配的请求字符串，可以是不含正则表达的字符串，如 /myserver.php 等；也可以是包含有正则表达的字符串，如 .php$（表示以 .php 结尾的URL）等。 其中方括号里的部分，是可选项，用来改变请求字符串与 uri 的匹配方式。 在不添加此选项时，Nginx 服务器首先在 server 块的多个 location 块中搜索是否有标准 uri 和请求字符串匹配，如果有多个可以匹配，就记录匹配度最高的一个。然后，服务器再用 location 块中的正则 uri 和请求字符串匹配，当第一个正则uri匹配成功，结束搜索，并使用这个 location 块处理此请求；如果正则匹配全部失败，就使用刚才记录的匹配度最高的 location 块处理此请求。 了解了上面的内容，就可以解释可选项中各个标识的含义了： “=”：用于标准uri前，要求请求字符串与 uri 严格匹配。如果已经匹配成功，就停止继续向下搜索并立即处理此请求。 “^～”：用于标准uri前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 “～”： 用于表示 uri 包含正则表达式，并且区分大小写。 “～*”：用于表示 uri 包含正则表达式，并且不区分大小写。注意如果 uri 包含正则表达式，就必须要使用“～”或者“～*”标识。 我们知道，在浏览器传送URI时对一部分字符进行URL编码，比如空格被编码为“%20”，问号被编码为“%3f”等。“～”有一个特点是，它对uri中的这些符号将会进行编码处理。比如，如果location块收到的URI为“/html/%20/data”，则当Nginx服务器搜索到配置为“～ /html/ /data”的location时，可以匹配成功。 root指令 这个指令用于设置请求寻找资源的根目录，此指令可以在 http 块、server 块或者 location 块中配置。由于使用 Nginx 服务器多数情况下要配置多个 location 块对不同的请求分别做出处理，因此该指令通常在 location 块中进行设置。 index指令 指定用来做默认文档的文件名，即定义首页索引文件的名称，可以在文件名处使用变量。 如果您指定了多个文件，那么将按照您指定的顺序逐个查找。 可以在列表末尾加上一个绝对路径名的文件。 index index.$geo.html index.0.html /index.html; 注意： 保存配置文件后，重新加载配置文件： nginx -s reload。 其他相关指令 指令 语法 使用环境 作用 break - server、location、if 完成当前的规则集，不再处理 rewrite 指令。 if - server、location 检查一个条件是否符合，如果条件符合，则执行大括号内的语句。 if 指令不支持嵌套，不支持多个条件 && 和 &brvbar;&brvbar; 处理。 return return code; server、location、if 结束规则的执行并返回状态码给客户端。 rewrite rewriteregex replacement flag; server、location、if 根据表达式来重定向URI，或者修改字符串。 set set variable value; server、location、if 用于定义一个变量，并给变量赋值。变量的值可以为文本、变量以及文本变量的联合。 Uninitialized_variable_warn uninitialized_variable_warn on\\off; http、server、location、if 开启和关闭未初始化变量的警告信息，默认值为开启。 If指令详解 正则表达式匹配： ==： 等值比较； ~： 与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写； ~*： 与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写； !~： 与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写； !~*： 与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写； 文件及目录匹配判断： -f, !-f： 判断指定的路径是否为存在且为文件； -d, !-d： 判断指定的路径是否为存在且为目录； -e, !-e： 判断指定的路径是否存在，文件或目录均可； -x, !-x： 判断指定路径的文件是否存在且可执行； # 如果文件不存在则返回 400 if (!-f $request_filename) { return 400; } # 如果 host 不是 example.com，则 301 到 example.com 中 if ( $host != 'example.com' ){ rewrite ^/(.*)$ https://example.com/$1 permanent; } # 如果请求类型不是 POST 则返回 405 if ($request_method = POST) { return 405; } # 如果参数中有 a=1，则 301 到指定域名 if ($args ~ a=1) { rewrite ^ http://example.com/ permanent; } 几个常见配置项 $host： HTTP请求行的主机名； $hostname： 主机名； $uri： 请求中的当前URI； $remote_addr： 客户端地址； $remote_port： 客户端端口； $remote_user： 用于HTTP基础认证服务的用户名； $request： 代表客户端的请求地址； $request_uri： 一些客户端请求参数的原始 URI； $scheme： 请求使用的 web 协议，http | https； $server_addr： 服务器端地址； $server_name： 服务器名； $server_port： 服务器端口； $http_host： 请求地址，即浏览器中你输入的地址（IP或域名）； 什么是正向代理和反向代理？ 正向代理 正向代理是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。 这种代理其实在生活中是比较常见的，比如访问外国网站技术，其用到的就是代理技术。 有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。 所以，正向代理，其实是\"代理服务器\"代理了\"客户端\"，去和\"目标服务器\"进行交互。 反向代理 反向代理是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 对于常用的场景，就是我们在 Web 开发中用到的负载均衡服务器，客户端发送请求到负载均衡服务器上，负载均衡服务器再把请求转发给一台真正的服务器来执行，再把执行结果返回给客户端。 所以，反向代理，其实是\"代理服务器\"代理了\"目标服务器\"，去和\"客户端\"进行交互。 正向代理和反向代理的区别 虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。 正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。 正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。 正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。 正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。 正向代理和反向代理配置示例 正向代理配置演示 以下演示中，我们以 A 主机浏览器作为客户端、A 主机也作为提供 Web 服务的服务器、B 主机作为代理服务器。我们禁止 A 主机浏览器直接访问自己提供的 Web 服务，然后通过 B 主机代理获取，来模拟正向代理的场景。 A 主机（IP：192.168.188.98）启动一个 Web 服务，如 192.168.188.98:9700/index.html。这时，客户端是能正常访问该 Web 服务。 修改 A 主机的 Nginx 配置文件，加入一个判断语句：如果访问该服务的客户端主机是 A（IP：192.168.188.98），则禁止访问，返回403； server { listen 9700; server_name localhost; location / { if ($remote_addr ~* \"^192\\.168\\.188\\.98\") { return 403; } proxy_pass http://localhost:9600; } } nginx -s reload一下，然后在客户端打开 192.168.188.98:9700/index.html，可以发现已经无法访问了，页面返回 403。 修改 B 主机（IP：192.168.188.99） 的 Nginx 配置文件，添加如下配置： # http协议的代理 server { resolver 8.8.8.8; listen 8088; server_name localhost; location / { proxy_pass $scheme://$http_host$request_uri; } } # https协议的代理 server { resolver 8.8.8.8; listen 443; server_name localhost; location / { proxy_pass $scheme://$http_host$request_uri; } } resolver：DNS 解析服务器的 IP； $scheme 是请求的协议，$http_host 是请求的主机名， $request_uri 是请求后面所加的参数。 这个配置是，所有访问 B 主机下 8088|443 端口的 HTTP|HTTPS 请求，全部代理到 $scheme://$http_host$request_uri; ，即原访问地址。 将 B 主机设置为 A 主机的代理器。也就是说，A 主机的所有请求都是发向 B 主机的，B 主机再用 A 主机的发起的请求地址，去请求真正要访问的主机。 Mac 设置代理器的方法：在 A 主机打开 系统偏好设置 -> 网络 -> 高级 -> 代理 -> 网页代理(HTTP) | 安全网页代理(HTTPS) 的 【网页代理服务器】填入 B 主机的 IP，以及 8088|443 端口号。 以上配置就是正向代理的一个场景演示。客户端是想要 A 的资源，但是 A 的资源只有 B 能拿到，便让 B 代理去帮助我们访问 A 的资源。整个过程 A 只知道 B 拿了它的资源，并不知道最终是客户端拿到的。 现在，我们又能在客户端访问 192.168.188.98:9700/index.html 了，绕过了 A 主机设定的限制。 反向代理配置 # 将 localhost:9700/api 请求代理到 https://example.com/api # 注意！！proxy_pass https://example.com；中 https://example.com 后面不能有 \"/\" # 否则！！会将 localhost:9700/api 代理到 https://example.com/ server { listen 9700; server_name localhost; location / { proxy_pass https://www.baidu.com/; } } 一些常见错误 重启 nginx 报错 执行命令：nginx -s reload 时，报错： nginx: [error] invalid PID number \"\" in \"/usr/local/var/run/nginx.pid\" 或者 nginx: [error] open() \"/usr/local/var/run/nginx.pid\" failed (2: No such file or directory) 原因： 没有 nginx.pid 文件。可以是没有启动 nginx，或者是 nginx.pid 误删了。 解决： 重启一下 Nginx 就好了。 启动 nginx 报错 nginx nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use) nginx: [emerg] still could not bind() 原因： 可能是系统中其他进程占用了端口，也可能是 nginx 已经启动了。 解决： lsof -i:8080 找出占用端口的进程。如果是其他进程占用了，可以用 kill -9 [进程id] 关闭该进程，或者为 nginx 指定其他端口。如果是 nginx 已经在用了，重启 nginx nginx -s reload，而不是启动 nginx。 nginx 代理失败 安装及配置完成后，nginx 代理无效。控制台没有报错，只是默默失败。 其原因可能是： 代理软件冲突。比如：开启了 ShadowSocks。 listen 所指定的端口，是其他程序（如：webpack 开发环境、http-server）启动的。访问该端口的请求，没有进入 Nginx。 ./configure: No such file or directory 定位到 /usr/local/Cellar/nginx/1.21.1 目录，执行如下命令时： ./configure --add-module=/usr/local/Cellar/nginx/1.21.1/echo-nginx-module-0.62 报错： no such file or directory: ./configure。 原因： 该目录下没有 ./configure 文件。这可能是使用 brew install nginx 安装，有部分文件没有。 解决： 下载并解压 nginx 安装包，找到解压后的目录，依次执行 ./configure --add-module=/usr/local/Cellar/nginx/1.21.1/echo-nginx-module-0.62 -> make -> make install。 相关链接： ./configure: No such file or directory - build nginx-rtmp-module on Mac OS X nginx: [alert] kill(61700, 1) failed (3: No such process) 在执行 nginx -s reload、nginx -s stop，报错： nginx: [alert] kill(61700, 3) failed (3: No such process) 原因： nginx 启动的进程不存在。可能没有启动，或者被意外关闭了。 解决： # 指定配置檔案地址 /usr/local/nginx/nginx -c /usr/local/nginx/nginx.conf 参考资料 Mac下 Nginx 的安装运行 Nginx配置文件详解 Nginx中文文档 Nginx 正向代理与反向代理实战 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-12-05 18:45:01 "},"tools/Git/":{"url":"tools/Git/","title":"Git","keywords":"","body":"README Git 是目前世界上最先进的分布式版本控制系统（没有之一）。 Git 是用 C 语言开发的。 CVS 及 SVN 都是集中式的版本控制系统，而 Git 是分布式版本控制系统。 为什么使用版本控制？ 在开发过程中，大部分情况下是团队开发，即使是个人开发，我们也想对整个项目进行代码管理与备份等等。最原始的版本控制方法是：每次备份一份代码，标记版本号，压缩，存储到计算机硬盘。显然，这不是一个合理的解决办法，随着版本的增多，硬盘空间会越来越小，而且，这不利于我们查看不同版本间的差异、版本的回退，以及多人协同开发。 在团队开发过程中，对代码进行合并管理的时候，总需要一些工具可以自动合并，版本控制系统应运而生。运用版本控制系统，我们可以对代码进行版本管理，可以随时查看之前版本的内容，随时回溯到之前版本中。团队合作的时候也可以自动合并代码，而不需要用一个共享文件，或者是进行定期的备份。 CVS 是最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于 CVS 自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的 SVN 修正了 CVS 的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 Git诞生 很多人都知道，Linus 在1991年创建了开源的 Linux，从此，Linux 系统不断发展，已经成为最大的服务器系统软件了。 Linus 虽然创建了 Linux，但 Linux 的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为 Linux 编写代码，那 Linux 的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！ 你也许会想，为什么 Linus 不把 Linux 代码放到版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，和 Linux 的开源精神不符。 不过，到了2002年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。 Linus 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。 Git 迅速成为最流行的分布式版本控制系统，尤其是 2008年，GitHub 网站上线了，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub，包括 jQuery，PHP，Ruby 等等。 历史就是这么偶然，如果不是当年 BitMover 公司威胁 Linux 社区，可能现在我们就没有免费而超级好用的 Git 了。 集中式vs分布式 集中式版本控制系统，版本库是集中存放在中央服务器的。 每个开发者都在他自己的计算机上又一个包含所有项目文件的工作目录（工作区），当该开发者在本地做了更改之后，他就会定期把修改提交给中央服务器。然后，开发者在执行更新操作的同时也会从该服务器上拾取出其他开发者所做的修改，中央服务器上存储着这些文件的当前版本和历史版本。 而分布式版本控制系统根本没有 “中央服务器”。 每一个开发者都同时拥有一个用于当前文件操作的工作区与一个用于存储该项目所有版本、分支以及标签的本地版本库。每个开发者的修改都会被载入成一次次的新版本提交，首先提交到本地版本库中。然后，其他开发者就会立即看到新的版本。通过 pull 和 push 命令，我们可以将这些修改从一个版本库传送到另一个版本库中。 多人协作中，我们可以指定一个人的电脑作为总仓库，所有人从他的电脑上提交更新，拉取别人的提交。这个人其实就充当了集中式中的中央服务器的角色。这样做是为了避免你的提交需要推到多个人的电脑，避免你需要从多个人电脑抓取新提交。 集中式版本控制系统人最大缺点：联网才能使用，上传速度慢。工作前要先从中央服务器获取最终新版本，工作完成后，要将文件传到中央服务器。如果提交一个大的文件，上传速度会很慢。 分布式版本的特点：可有可无的中央服务器。虽然在分布式版本控制中也有中央服务器的概念，但它只是为了利于交换版本，在开发中不是必要的。它的优点体现在：一、不需要联网也能工作 — 版本管理不依赖于中央服务器，可以在本地版本库进行开发工作；二、安全性高 — 即使不小心把中央服务器的版本库删了，也可以从任意一个开发者电脑中复制一份回去，两者的版本库是一样的。 Git与SVN区别 Git 是分布式版本控制系统，SVN是集中式版本控制系统。 Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。 分支不同：SVN 中的分支是版本库中的另外一个目录； 全局的版本号： Git 没有全局版本号，而 SVN 有。目前为止，这是跟 SVN 相比，Git 缺少的最大的一个特征。 Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-11-14 14:08:25 "},"tools/Gitbook/":{"url":"tools/Gitbook/","title":"Gitbook","keywords":"","body":"README Gitbook © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-16 00:44:23 "},"tools/Gitbook/01-gitbook入门篇.html":{"url":"tools/Gitbook/01-gitbook入门篇.html","title":"Gitbook入门篇","keywords":"","body":"Gitbook入门篇 什么是GitBook？ GitBook 是一个使用 Git 和 Markdown 来构建书籍的工具。它可以将你的书输出很多格式：PDF，ePub，mobi，或者输出为静态网页。 GitBook 是开源并且完全免费的，它的源码可以在 GitHub 上获取。与格式和工具链相关的问题被发表在 github.com/GitbookIO/gitbook/issues。 gitBook 是一个基于node.js的命令行工具，使用 github/git 和 markdown/asciiDoc 构建精美的电子书。它支持输出静态网页和电子书等多种格式,其中默认输出静态网页格式。 gitbook 不仅支持本地构建电子书,而且可以托管在 gitbook 官网上,并享受在线发布和托管图书的便利,完整的文档请参考 gitbook 新版文档(需FQ) 打开gitbook.com网站需要使用代理。如果还是打不开，请确定你的shadowSocks的PAC是最新的，因为老的PAC可能不包括这个网站。（被坑过） 开始之前，你需要的准备 知识准备 markdown 快速入门 git - 简明指南（入门推荐） 环境检测 检查 git：git --version 检查 node.js：node --version Markdown编辑器：方便本地开发，推荐Typora或gitbook自己的编辑器gitbook editor 最新注册的gitbook账号是无法使用 gitbook-editor 编辑器。 安装 安装：npm i -g gitbook-cli 检查 gitbook ：gitbook --version gitbook-cli 是 GitBook 的一个命令行工具。它将自动安装所需版本的 GitBook 来构建一本书。 注：不要运行npm i -g gitbook安装，如已安装，运行npm uni -g gitbook卸载，重装。 Gitbook命令 初始化 Gitbook 项目 gitbook init gitbook init会在空项目中创建README.md和SUMMARY.md两个文件：README.md文件是项目的介绍文件。 SUMMARY.md是gitbook书籍的目录。 初始化相应的文件目录结构，所以主要是用于开发初始阶段. 启动 Gitbook 项目 gitbook serve [--port 4000] 默认情况下服务器启动后会占用两个端口，一个是对外暴露的 4000 端口，用于浏览器访问项目。另外一个是 35729 端口，用于监听本地文件变化，重启服务器进而实现热加载功能。 本地服务器启动后我们就可以访问 http://localhost:4000 预览静态网站效果。由于能够实时预览电子书效果,并且大多数开发环境搭建在本地而不是远程服务器中，所以主要用于开发调试阶段。 构建 Gitbook 静态网页 gitbook build [entry] [--output] ## gitbook build ./ ./docs -o, --output 输出文件件, 默认为 ./_book -f, --format 产生的书籍的类型, 默认为静态站点, 可用的格式为: site, page, ebook, json --config 配置文件, 默认为 book.js 或 book.json 构建静态网页而不启动本地服务器，默认生成文件存放在 _book/ 目录。在_book文件夹里有一个index.html文件，这个文件就是文档网站的HTM入口，主要用于发布准备阶段。 输出静态网页后可打包上传到服务器，也可以上传到 github 等网站进行托管。 当然输出目录是可配置的,暂不涉及,见高级部分. 其他命令 #切换版本 gitbook [version] #列出当前已安装的版本 gitbook ls #则是列出远程服务器版本 gitbook ls-remote #更新版本 gitbook fetch [versiion] #更新到gitbook的最新版本 gitbook update #生成电子书 gitbook pdf ./ ./aaaa.pdf gitbook epub ./ ./aaaa.epub gitbook mobi ./ ./aaaa.mobi Gitbook配置文件 如果你想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。配置文件写完后，需要重启服务或者重新打包才能应用配置。 gitbook的配置文件名是book.json，首先在项目的根目录中创建book.json文件。book.json主要内容： { \"root\": \"/\", //指定存放 gitbook 文件(除了book.json文件本身)的根目录 \"gitbook\" : \"3.2.3\", //gitbook 版本 //\"title\": \"我的一本书\", //标题 \"page\": { \"title\": \"前端知识库(lizh)\" }, \"author\" : \"lizhao\", //作者 \"description\" : \"\", //描述 \"language\" : \"zh-hans\", //使用的语言，zh-hans是简体中文，会对应到页面的 \"variables\": { \"authorName\": \"lizhao\" }, //指定 Readme、Summary、Glossary 和 Languages 对应的文件名 \"structure\": { //readme: 'README.md', //Readme file name //summary: 'SUMMARY.md', //Summary file name //glossary: 'GLOSSARY.md', //词汇表文件[可选] //languages: 'LANGS.md' //语言文件[可选] }, //使用的插件列表，所有的插件都在这里写出来，然后使用gitbook install来安装 \"plugins\": [ //gitbook 默认自带5个插件 //\"highlight\", //语法高亮插件 //\"search\", //搜索插件 //\"sharing\", //分享插件 //\"font-settings\", //字体设置插件 //livereload\", //热加载插件 \"anchors\", \"expandable-chapters-small\", \"search-plus\", \"toggle-chapters\", \"summary\", \"splitter\", \"theme-comscore\", \"fontsettings\" //\"search-pro\", //高级搜索（支持中文） //\"back-to-top-button\", //chapter-fold, //支持多层目录，点击导航栏的标题名就可以实现折叠扩展。 //page-treeview, 在页面顶部显示目录 //-符号代表去除默认自带的插件 \"-lunr\", \"-search\" ], //插件的配置信息，如果插件需要配置参数，那么在这里填写 \"pluginsConfig\": { \"expandable-chapters-small\":{}, \"fontsettings\": { \"theme\": \"white\", \"family\": \"sans\", \"size\": 2 } }, //目前可以给侧导航栏添加链接信息 \"links\" : { \"sidebar\" : { } }, //自定义页面样式，各种格式对应各自的css文件 \"styles\": { //\"website\": \"styles/website.css\", //\"ebook\": \"styles/ebook.css\", //\"pdf\": \"styles/pdf.css\", //\"mobi\": \"styles/mobi.css\", //\"epub\": \"styles/epub.css\" } } gitbook.com 官网操作 gitbook 官网是官方提供的图书托管的在线平台，分为新版官网(需要FQ) https://www.gitbook.com/ 和旧版官网(无需FQ) https://legacy.gitbook.com 两个网站。 目前均正常提供服务，但令人遗憾的是，两个网站的信息相互独立，而且现在注册的账号默认只能在新版官网中使用，而新版官网的访问速度简直比 github 还要慢，所以国内用户在线访问你的电子书真的需要点技术手段了! 将 github 个人网站项目同步到 gitbook 电子书项目。这样的好处是本地只需要推送到 github ，自动更新 github.io 网站(利用的是github 静态网站托管服务)，然后再自动同步到 gitbook.io 网站。 操作流程如下： 注册并登陆 gitbook.com（需要使用代理） 新建命名空间(电子书) 域名&路径 默认域名是 https://[username].gitbook.io/，如果需要自定义域名，请保证 dns 能够正确解析到该网站。路径是spacename。比如：https://lizh.gitbook.io/knowledge/ 整合Github gitbook 默认提供4种整合方式：GitHub、Slack、Google Analytics、Intercom。 以为以 github 为例，其余三种没接触过，暂不涉及。 选择 github 进行整合 选择目标仓库 登录 github 并授权 -> 选择目标仓库 -> 选择同步分支 -> 选择同步内容。 导入成功 由于 gitbook 电子书内容来自于 github 项目，因此我们只要更新 github 仓库，我们的 gitbook 电子书网站自然也就相应更新了! 美中不足的是,国内无法正常访问 gitbook.com 。现在国内也有类似的产品,有一种产品叫做 看云，还不错! Gitbook插件 插件是 gitbook 的扩展功能，很多炫酷有用的功能都是通过插件完成的。其中插件有官方插件和第三方插件npm之分。根据 gitbook 插件规范, gitbook-plugin- 是功能插件,gitbook-theme- 是主体插件。 基本使用： 先安装到本地： npm install gitbook-plugin-（可略） 插件配置：在 book.json 中 plugins 节点 安装： gitbook install { \"plugins\": [ \"myPlugin\" ], \"pluginsConfig\": { \"myPlugin\": {} } } 常见问题 gitbook build 或 gitbook serve报错 gitbook: 3.2.3 node：v12.2.0 npm：6.9.0 Error: ENOENT: no such file or directory, stat 'xxxx\\_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js' 方法一：将C:\\Users\\[whoami]\\.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js第112行confirm: true注释，或改成confirm: false 方法二：关闭杀毒软件 windows系统无法热加载，总是报错 Stopping server events.js:173 throw er; // Unhandled 'error' event ^ Error: EPERM: operation not permitted, lstat 'D:\\MyCode\\gitBook\\_book' Emitted 'error' event at: at FSWatcher._handleError (C:\\Users\\[whoami]\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\index.js:236:10) at ReaddirpReadable.emit (events.js:196:13) at Immediate. (C:\\Users\\[whoami]\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\node_modules\\readdirp\\stream-api.js:82:32) at processImmediate (internal/timers.js:439:21) 控制台信息说是操作权限的问题。打开项目，当前项目已经没有 _book 目录，证明发生报错时确实已经删除了 _book 目录，但是某种原因无权再次创建该文件夹而重启失败。结论是 gitbook 是删除 _book 文件夹再新建 _book 文件夹时发生了意外。 解决方法：在启动本地服务器后立即删除 _book 目录，当本地文件发生修改时重启服务就能成功了。 这个官方已知的一个bug，且没有想修复的意思。~只能期待gitbook升级了~ 内容无法在gitbook.com显示 文件夹名称有大写字母或者文件名中有空格会导致 gitbook.com 网站中对应的链接无法访问。 ~题外话~ 搭建文档类站的工具，除了gitbook外，还有以下两种： Docsify docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。 这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件“污染” commit 记录，只需要创建一个 index.html 就可以开始写文档而且直接部署在 GitHub Pages。 插件方面，docsify插件不如Gitbook的丰富，但麻雀虽小五脏俱全，该有的基本也都有，足够使用。 对 SEO 不够友好，因为它是完全的运行时驱动的。 特性： 无需构建，写完文档直接发布 容易使用并且轻量 (压缩后 ~21kB) 智能的全文搜索 提供多套主题 丰富的 API 支持 Emoji 兼容 IE11 支持服务端渲染 SSR (示例) VuePress VuePress 由两部分组成：第一部分是一个极简静态网站生成器，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。 特性：) 内置的 Markdown 拓展 在 Markdown 中 使用 Vue Vue驱动的自定义主题系统 默认主题 ... 除此外，还有Docute、Hexo... 参数链接 雪之梦技术驿站 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-16 09:52:07 "},"tools/Gitbook/02-gitbook插件篇.html":{"url":"tools/Gitbook/02-gitbook插件篇.html","title":"Gitbook插件篇","keywords":"","body":"Gitbook插件篇 插件是 gitbook 的扩展功能，很多炫酷有用的功能都是通过插件完成的。其中插件有官方插件和第三方插件npm之分。根据 gitbook 插件规范, gitbook-plugin- 是功能插件,gitbook-theme- 是主体插件. 安装插件 先安装到本地 npm install gitbook-plugin-（可略） 配置：在 book.json 中 plugins 配置插件名称，pluginsConfig配置插件参数。 安装： gitbook install。 { \"plugins\": [ \"myPlugin\" ], \"pluginsConfig\": { \"myPlugin\": {} } } 一些有趣的插件 donate 打赏插件 文章最下面的按钮，点击可弹出图片 { \"plugins\": [ \"donate\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"微信收款的二维码URL\", \"alipay\": \"支付宝收款的二维码URL\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" } } } disqus 评论插件（需注册账号） discus 是一款集成评论的插件，可以为静态网站添加动态评论，让你的网站动起来! 遗憾的是，discus 插件只有 FQ 才能正常使用，暂时没找到其他较好的替代方案。 gitbook 集成 disqus 插件中最重要的配置项就是注册 disqus.com 网站唯一标识。 { \"plugins\": [\"disqus\"], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"snowdreams1006\" } } } gitalk 评论插件 上述 disqus 评论插件虽然比较好用，但是注册是在 disqus.com 官网，需要特殊手段才能访问，即便成功配置了国内一般也是访问不到的，因此功能相当鸡肋。 gitalk 评论插件解决了这一痛点，利用 github 的开发者接口授权，将讨论区的 issue 变成评论区，和 github 结合的如此紧密，适合用源码托管到 github 这类情况。 实出操作如下： 申请 GitHub Application 授权 登录 github 账号，点击 在线申请 授权应用。 新建应用，首页 url 和授权回调 url 填写相同的首页链接即可，其他情况自定义填写。 应用登记成功后会生成 token 令牌，clientId 和 clientSecret 需要重点保存下来，待会需要用到。 安装并集成到网站 在需要添加评论的页面，添加下述内容引入 gitalk 插件，其中参数来自我们上一步获取的 clientId 和 clientSecret 。 默认应该添加到 .html 页面，当然也可以添加到 .md 页面，毕竟 markdown 语法也支持 html 标签。 var gitalk = new Gitalk({ \"clientID\": \"clientId\", \"clientSecret\": \"clientSecret\", \"repo\": \"GitHub repo\", \"owner\": \"GitHub repo owner\", \"admin\": [\"GitHub repo admin\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); \"clientID\" : [必选] GitHub Application Client ID \"clientSecret\" : [必选] GitHub Application Client Secret \"repo\" : [必选] GitHub repository \"owner\" : [必选] GitHub repository 所有者，可以是个人或者组织 \"admin\" : [必选] GitHub repository 的所有者和合作者 (对这个 repository有写权限的用户) \"id\" : [可选] 页面的唯一标识,默认值: location.href, 长度必须小于50,否则会报错! \"distractionFreeMode\": [可选] 类似 Facebook 评论框的全屏遮罩效果,默认值: false 注意：必须推送到服务器。因为申请应用时填写的域名是线上地址，因而本地测试是不会成功的，会报错。 注意：需要管理员对 Issue 进行初始化创建。 遗憾的是：我们目前仅仅在首页(README.md) 集成了 gitalk 插件，也就是说使用 gitbook build 输出的 index.html 首页才支持评论区，其他页面没有插入上述代码，自然是没有评论区功能的啊！目前并没有找到优雅的解决方案。 解决思路：无非就是在js里面加一段Gitalk的调用代码，这样使用gitbook build命令的时候，所有的页面都会有Gitalk的评论调用。 mygitalk 评论插件 gitbook-plugin-mygitalk 是全网最早发布的基于 gitalk 实现评论插件,用于给 Gitbook 博客网站集成评论功能。 { \"plugins\" : [\"mygitalk\"], \"pluginsConfig\": { \"mygitalk\": { \"clientID\": \"GitHub Application Client ID\", \"clientSecret\": \"GitHub Application Client Secret\", \"repo\": \"GitHub repo\", \"owner\": \"GitHub repo owner\", \"admin\": [\"GitHub repo owner and collaborators, only these guys can initialize github issues\"], \"distractionFreeMode\": false } } } change_girls 可自动切换的背景 添加背景图片，并且可以自动切换 { \"plugins\":[\"change_girls\"], \"pluginsConfig\": { \"change_girls\" : { \"time\" : 10, \"urls\" : [ \"girlUrl1\", \"girlUrl2\",...\"\" ] } } } copyright 版权保护插件 如果你的博客不希望被别人随意转载或者文章希望保留首发网站信息，那么推荐使用copyright插件帮助你进行版权保护。 gitbook-plugin-copyright 版权保护插件实现复制文章时自动追加版权保护信息，并在文章结尾处追加来源信息。 { \"plugins\": [\"copyright\"], \"pluginsConfig\": { \"copyright\": { \"site\": \"\", \"author\": \"\", \"website\": \"\", \"image\": \"\" } } } readmore 阅读更多插件 如果 Gitbook 个人博客流量不错的话，可以考虑转化成公众号流量，readmore 插件是集成OpenWrite提供引流工具，通过关注公众号解锁博客文章，实现粉丝转换!、 { \"plugins\": [\"readmore\"], \"pluginsConfig\": { \"readmore\":{ \"blogId\": \"\", \"name\": \"\", \"qrcode\": \"\", \"keyword\": \"\" } } } advanced-emoji - 支持emoji表情 { \"plugins\": [ \"advanced-emoji\" ] } 一些实用插件 search-plus 中文搜索插件 默认的 search 搜索插件是不支持中文搜索的，而 search-plus 则功能更强大些，两者不能共存，需要禁用或移除 search 插件。 { \"plugins\": [ \"-lunr\", \"-search\", \"search-plus\" ] } expandable-chapters-small 可扩展导航章节 expandable-chapters效果相同，唯一不同的是这个插件的箭头粗。 支持多层目录。点击箭头才能实现收放目录。不如chapter-fold好用。 { \"plugins\": [ \"expandable-chapters-small\" ] } gitbook-plugin-summary 自动生成SUMMARY.md文件 { \"plugins\": [ \"summary\" ] } page-treeview 生成页内目录 生成目录，放在页面顶部 { \"plugins\": [ \"page-treeview\" ], \"pluginsConfig\": { \"page-treeview\": { \"copyright\": \"Copyright &#169; aleen42\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" } } } tbfed-pagefooter 页脚插件 { \"plugins\": [\"tbfed-pagefooter\"], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"&copy username\", \"modify_label\": \"文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } pageview-count 阅读量计数 { \"plugins\": [ \"pageview-count\"] } accordion 折叠模块 这个插件名叫手风琴，可以实现将内容隐藏起来，外部显示模块标题和显示箭头，点击箭头可显示里面的内容。 { \"plugins\": [\"accordion\"] } 用法：编辑内容，用下面的标签括起来 %accordion%模块标题%accordion% 内容部分 %/accordion% hide-element 隐藏元素 可以隐藏不想看到的元素，比如导航栏中Published by GitBook { \"plugins\": [ \"hide-element\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] } } } splitter 侧边栏宽度可调节 { \"plugins\": [ \"splitter\" ] } sharing-plus 分享当前页面，比默认的 sharing 插件多了一些分享方式。 { \"plugins\": [\"-sharing\", \"sharing-plus\"], \"pluginsConfig\": { \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": true, \"pocket\": false, \"qq\": false, \"qzone\": true, \"twitter\": false, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\",\"twitter\", \"weibo\", \"messenger\",\"qq\", \"qzone\",\"viber\",\"whatsapp\" ] } } } klipse 嵌入类似IDE的功能 嵌入一块功能，可在代码段中实时交互，即（输入代码 > 执行结果 { \"plugins\": [\"klipse\"] } klipse 目前支持下面的语言： javascript: evaluation is done with the javascript function eval and pretty printing of the result is done with pretty-format clojure[script]: evaluation is done with Self-Hosted Clojurescript ruby: evaluation is done with Opal C++: evaluation is done with JSCPP python: evaluation is done with Skulpt scheme: evaluation is done with BiwasScheme PHP: evaluation is done with Uniter BrainFuck JSX EcmaScript2017 Google Charts: See Interactive Business Report with Google Charts. github 插件 添加 github 图标链接，方便直接跳转到 github 指定仓库。 { \"plugins\": [\"github\"], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/snowdreams1006/snowdreams1006.github.io\" } } } edit-link 编辑链接插件 如果希望将网页源码暴露出去并接受公众的监督校准的话，使用edit-link插件可以直接链接到源码文件。 { \"plugins\": [\"edit-link\"], \"pluginsConfig\": { \"edit-link\": { \"base\": \"\", \"label\": \"\" } } } back-to-top-button 回到顶部 { \"plugins\": [ \"back-to-top-button\" ] } chapter-fold 导航目录折叠 支持多层目录，点击导航栏的标题名就可以实现折叠扩展。 { \"plugins\": [\"chapter-fold\"] } code 代码添加行号&复制按钮（可选） { \"plugins\" : [ \"code\" ], \"pluginsConfig\": { \"code\": { \"copyButtons\": false } } } insert-logo 插入logo 将logo插入到导航栏上方中 { \"plugins\": [ \"insert-logo\" ] \"pluginsConfig\": { \"insert-logo\": { \"url\": \"images/logo.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" } } } 主题插件 theme-default 主题 theme-default 是 3.0.0 引入的默认主题，大多数插件针对的都是默认主题，如果切换到其他主题或者自定义主题，可能会造成某些情况下不兼容,甚至报错。 默认情况下，左侧菜单不显示层级属性，如果将 showLevel 属性设置为 true 可以显示层级数字。 { \"plugins\": [ \"theme-default\" ] \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true } } } theme-comscore 主题 default 默认主题是黑白的，而 comscore 主题是彩色，即标题和正文颜色有所区分。 \"plugins\": [ \"theme-comscore\" ] flexible-alerts 警报 这个GitBook插件将块引用转换为漂亮的警报。此外，您还可以提供自己的警报类型（比如最后的comment）。 { \"plugins\": [ \"flexible-alerts\" ], \"pluginsConfig\": { \"flexible-alerts\": { \"style\": \"callout\", \"comment\": { \"label\": \"Comment\", \"icon\": \"fa fa-comments\", \"className\": \"info\" } } } } arkdown文件中编辑 > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 上面的[!NOTE]是行匹配模式，默认情况下支持类型NOTE，TIP，WARNING和DANGER。 > [!type|style:xx|label:xx|icon:xx|className:xx|labelVisibility:xx|iconVisibility:xx] > 内容部分 theme-api 插件 如果文档本身是普普通文档模式，切换成 api 文档模式后并不会有太大变化，除非一开始就是接口文档，那样使用 theme-api 插件才能看出效果。 { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"theme\": \"dark\" } } } theme-faq 插件 theme-faq 可以帮助我们构建问答中心，预设好常见问题以及相应答案模式，同时为了方便搜索到问题或答案，一般需要搜索插件的配合。 帮助中心没有工具栏，因此涉及到工具类的插件一律失效或主动移除，同时默认搜索插件也会失效。 { \"plugins\": [ \"theme-faq\", \"-fontsettings\", \"-sharing\", \"-search\", \"search-plus\" ] } 插件开发 GitBook 插件是在 npm 上发布的遵循传统定义的 node 包，除了标准的 node 规范外还有一些 Gitbook 自身定义的相关规范。 目录结构 Gitbook 插件最基本的项目结构至少包括配置文件 package.json 和入口文件 index.js ，其他目录文件根据插件用途自行增减。 实际插件项目略有不同，可能还会有 _layouts 布局目录， asset 资源目录以及自定义 example 示例目录和 docs 文档目录等等。 package.json package.json 是nodejs的配置文件，Gitbook 插件同样遵循该规范，配置文件声明了插件的版本描述性信息，除此之外还有 Gitbook 相关字段，遵循schema准则，基本示例如下： { \"name\": \"gitbook-plugin-mytest\", \"version\": \"0.0.1\", \"description\": \"This is my first GitBook plugin\", \"engines\": { \"gitbook\": \">1.x.x\" }, \"gitbook\": { \"properties\": { \"myConfigKey\": { \"type\": \"string\", \"default\": \"it's the default value\", \"description\": \"It defines my awesome config!\" } } } } 值得注意的是，包名称必须以 gitbook-plugin-开头，包引擎应该包含gitbook。 index.js index.js 是插件运行时的入口，基本示例如下： module.exports = { // 钩子函数 hooks: {}, // 代码块 blocks: {}, // 过滤器 filters: {} }; 专用插件 专用插件可以托管在 GitHub 上，并使用 git urls： { \"plugins\": [ \"myplugin@git+https://github.com/MyCompany/mygitbookplugin.git#1.0.0\" ] } 发布&测试插件 与其他npm插件一样。GitBook 插件可以在npmjs官网上发布。如需发布插件，首先需要在npmjs官网上注册帐户，然后通过命令行发布。 npm publish #在插件的文件夹中，运行 npm link #然后在您的书或者文档的文件夹中执行 npm link gitbook-plugin- 参数链接 雪之梦技术驿站 GitBook插件整理 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:16:58 "},"tools/Gitbook/03-gitbook进阶篇.html":{"url":"tools/Gitbook/03-gitbook进阶篇.html","title":"Gitbook进阶篇","keywords":"","body":"Gitbook进阶篇 集成 github 网站 为什么选择集成到github? 使用零成本: github pages 集成在 github 中, 直接和代码管理绑定在一起, 随着代码更新自动重新部署, 使用非常方便. 免费: 免费提供 http://username.github.io 的域名, 免费的静态网站服务器. 无数量限制: github pages 没有使用的数量限制, 每一个 github repository 都可以部署为一个静态网站. 什么是 GitHub Pages ? Github Pages 是 github 网站推出的一种免费的静态网页托管服务，适合搭建静态的项目主页或个人官网。 其中，网站项目的源码直接托管在 github 仓库中，当仓库文件更新后，该仓库所关联的网站自动更新，从而实现了源码与官网的联动更新。 每个账号有且只有一个主页站点，但允许无限制多的项目站点。 主页站点：https://.github.io/ 项目站点：https://.github.io/repository/ 如何集成 gitbook ? 我们已经知道 Github Pages 是提供静态网站的免费托管，而 gitbook 默认生成的内容就是静态网站。gitbook 默认输出目录 _book/ 包括了静态网站所需的全部资源，其中就包括 index.html 首页文件。我们需要做的就是，这_book下的所有文件复制一份到根目录或./docs（取决于你github中的设置）。以为复制到./docs为例： 每次生成后将 _book/ 整个目录复制到项目根目录或者定的docs gitbook build cp -r _book/* . gitbook build，可以指定输入文件 gitbook build ./ ./docs book.json中设置output参数。（无效，不知道是什么原因。如果你知道，欢迎在下方给我留言） # book.json { \"output\": \"./docs\" } Openwrite OpenWrite（官网：https://www.openwrite.cn）一文多发平台。只需要你使用 markdown 完成内容写作，通过文章扩散工具，就能轻松将文章内容到科技人汇聚的内容平台。从而让各个平台的读者都能看到你的内容，从而了解你，并提升你的综合影响力！ 一文多发 OpenWrite 提供的众多功能中最吸引我的地方莫过于一文多发功能了：我在用的平台它都有，我没用的平台它也有！ 平台整体上使用体验非常不错，大致步骤是先提前登陆各大目标平台，然后通过 OpenWrite 提供的插件自动进行渠道认证，配置各大渠道后就可以愉快发文啦！ 公众号引流 如果你有自己独立博客，也在运营者微信公众号，但是苦于没有很好的手段引导读者关注公众号，那么Openwrite 推出的 ReadMore 工具绝对可以解决燃眉之急。 静态博客网站集成 ReadMore 工具后，全站博客文章内容自动隐藏一半，同时浮现出阅读全文的按钮引导读者点击解锁。 一旦读者想要阅读全文就会主动点击按钮，此时就会自动弹出引导用户关注公众号的弹窗。 接下来读者应该是关注公众号回复关键字获取验证码进而解锁文章。 读者关注公众号后，发送关键字获取文字链接并点击该链接，此时就会获取验证码,离成功只差一步! 再次回到博客平台的受限文章，输入刚刚获取到的验证码，不仅解锁了当前文章，博客内的其他文章也全部自动解锁，并不会造成不好体验,完美！ gitbook集成openwrite 安装 openwrite 插件。即在 book.json 配置，然然gitbook install { \"plugins\" : [\"openwrite\"], \"pluginsConfig\":{ \"openwrite\":{ \"blogId\": \"\", \"name\": \"\", \"qrcode\": \"\", \"keyword\": \"\" } } } 参数链接 雪之梦技术驿站 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:16:58 "}}