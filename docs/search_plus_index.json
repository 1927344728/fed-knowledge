{"./":{"url":"./","title":"Introduction","keywords":"","body":" 本文档主要用于： 整理前端开发中遇到的各种bug 对一些浏览过、探索过、实践过的前端技术做一些笔记 项目运行 安装项目: gitbook install 本地启动：sh serve 根目录下有个名serve的shell文件，是为了解决gitbook serve热加载出现中断的问题和指定输出路径。 本地启动项目的核心命令是：gitbook serve [--input] [--output] [--port 4000] 。 --input是需要编译的项目地址。可不传，默认当前根目录下。 --output是编译后的输出路径。可不传，默认_book。指定输出目录为./docs，是因为GitHub Pages的静态网站指定的目录是master 分支下的./docs文件夹。 --port是端口号。可不传，默认4000 生成文件：sh build 项目git push之前，需要sh build更新SUMMARY.md文件。 根目录下有个名build的shell文件。是为了解决自动生成SUMMARY.md时不编译docs目录下的文件和指定输出路径。 生成文件的核心命令是：gitbook build[--input] [--output] --input是需要编译的项目地址。可不传，默认当前根目录下。 --output是编译后的输出路径。可不传，默认_book。指定输出目录为./docs，是因为GitHub Pages的静态网站指定的目录是master 分支下的./docs文件夹。 本文有两个访问地址 Gitbook.io Github Page 已知问题 Gitbook不支持原生的html、css语法 GitBook doesn't render plane HTML or CSS so the workaround would be to wrap them into a code block by adding '```' We don't plan on supporting plain HTML or CSS I'm afraid Gitbook.com中引入了gitalk做评论插件。目前遇到问题，无法正常显示 项目引入是基于gitalk的mygitalk插件。已向作者提issue，暂未回复。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-01 23:13:46 "},"bugs/00-前端调试随笔.html":{"url":"bugs/00-前端调试随笔.html","title":"前端调试随笔","keywords":"","body":"前端调试随笔 问题定位方向 缓存问题： 浏览器缓存、CDN缓存、路由器的缓存。 实例一：CDN 中缓存的 JQuery 文件不完整，导致部分用户打开页面出错。(因为是部分CDN缓存出错，前端非常难定位问题。) 实例二：本地的 localStorage 缓存，在某些情况下不能再用时，没有定义有效的清除机制。 网络问题：第三方插件链接出错、部分地区网络出错 网络协议：是否正确使用 http 和 https es6语法支持：是否使用了 canvas\\promise 或者使用了 es6 中的一些语法，但是没有用 babel 转换或者没有引入 polifyfill。 实例一：JS 中用了 findIndex 方法，由于某些原因，该 JS 文件没有经过 babel 转换，导致在一些低端手机执行 JS 出错，而控制台没有详细的报错信息，问题定位固难。 Babel 默认只转换新的 JavaScript 语法（syntax），而不转换新的 API，如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法，如 Array.findIndex、Object.assign 等都不会转码。 Cookie：浏览器是否标禁用了cookie、网站跨域导致cookie无法发送成功、前端是否设置了允许域名。 实例一：由于开启了 Mock.JS，导出接口请求报跨域错误。 调试工具 PC 端调试工具：浏览器（推荐：Chrome）。 移动端调试工具： Eruda ：一个专为手机网页前端设计的调试面板，类似 DevTools的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获 XHR 请求、显示本地存储和 Cookie 信息等等。 微信调试工具：微信 web 开发者工具。 移动端真机调试 IOS真机调试 IOS 设备可以通过 safari 调试，但必须满足如下条件： safari 打开开发者模式； IOS 设置的 safari，允许调试； 原生打开允许 app 的调试的限制，即，安装的应用是可调试版本的； 需要原生将该设备加入白名单。 使用数据线连接设备和电脑，Safari 点开开发者调试。 Andriod真机调试 Andriod 设备可以通过 Chrome 调试，但必须满足如下条件： Android 设备系统版本为 4.4 以上； 开启开发者模式：设置 -> 关于手机 -> 连续点击系统版本。（不同机型开启模式有异差） 系统安全 -> 未知来源 -> 允许； 选择开发者选项：允许 USB 调试； 使用数据线连接设备和电脑，Chrome打开：chrome://inspect/#devices © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-22 22:08:32 "},"bugs/01-浏览器常见问题概览.html":{"url":"bugs/01-浏览器常见问题概览.html","title":"浏览器常见问题概览","keywords":"","body":"浏览器常见问题概览 Uncaught SyntaxError: Unexpected token 通常是 HTML中的引用路径有误 undefined is not a function 出现 undefined is not a funcation 错误，通常是调用的某个方法不存在。 可能一：某个方法没有正确引入。如：this 的指向改变、异步引入问题； 可能二：浏览器兼容问题。如：IE 的 DOM 对某些 API 不支持； 可能三：ES6 没有转换。如：使用了 findIndex 等一些新 API，部分安卓机不支持。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-15 23:47:58 "},"bugs/02-浏览器兼容问题概览.html":{"url":"bugs/02-浏览器兼容问题概览.html","title":"浏览器兼容问题概览","keywords":"","body":"浏览器兼容问题 IE浏览器 1.Symbol 未定义 解决：添加 babel-polyfill 或者直接引入 https://cdn.bootcdn.net/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js。 备注：polyfill 文件需要在其他 .js 文件（尤其是报错的js文件）之前引入。 2. SCRIPT5022 SecurityError。WebSocket on IE10 giving a SecurityError 原因：打开一个本地(内部网)域的 websocket，IE抛出一个安全性错误（SecurityError） 解决：禁用IE识别本地站点的自动算法：Tools > Internet Options > Security > Local Intranet > Sites. 取消选中的 include all local (intranet) sites not listed in other zones ，或者取消所有选中的复选框。 备注：修改后，重启IE浏览器。 3. SCRIPT1006: Expected ')'、SCRIPT1002: Syntax error 原因：IE浏览器不支持es6的一些新语法。 一般项目编译，会将项目根目录下 src 等文件夹下的所有.js|jsx 文件中的 ES6 语法转换成 ES5，且会将node_modules文件夹下所有文件忽略，而部分node_modules 下的包会包含了ES6语法。 SCRIPT1006: Expected ')': 不支持函数的默认参数。如： function correlation (xMatrix, xMatrix = xMatrix, options = {} ) { } SCRIPT1002: Syntax error: 不支持 class。如 class Base { constructor() {} } 解决： 用转换器，将ES6转成ES5。比如 babel。 采用不同工具创建的项目，修改 babel配置的方法不一样。 webpack 配置文件：在 module -> rules 的 babel-loader 的 include 属性中追加 resolve('node_modules')。 module.exports = { module: { rules: [ { test: /\\.js$/, loader: 'babel-loader', include: [ resolve('src'), resolve('test'), resolve('node_modules') ], } ] } } umi@3.1.x：配置 nodeModulesTransform 设置 node_modules 目录下依赖文件的编译方式。nodeModulesTransform umi@2.x.x：的修改就比较麻烦了。 extraBabelIncludes 属性：定义额外需要做 babel 转换的文件匹配列表，格式为数组，数组项是 webpack#Condition。（尝试修改，但是没有成功） chainWebpack 属性：修改 webpack 配置。（推荐） // config.js export default { chainWebpack: config => { config.module .rule('js-in-node_modules') .before('js') .test(/\\.(js|jsx|ts|tsx)$/) .include.add(/node_modules/) .end() .use('babel') .loader('babel-loader') .options({ presets: [ ['@babel/preset-env', { targets: 'defaults', modules: false }], ['@babel/preset-react'], ['@babel/preset-typescript'], ], }); } } https://github.com/umijs/umi/issues/2025 4. IE浏览器会缓存GET请求 在 get 请求的 url 中增加随机标识。如：时间戳。 请求头 headers 添加两个键值参数。服务端需要在 Access-Control-Allow-Header 里面添加 cache-control、Pragma 字段。 ['Cache-Control'] = 'no-cache'; ['Pragma'] = 'no-cache'; 修改浏览器配置。Internet选项 >> 浏览历史记录 >> 设置 >> Internet 临时文件的选项改为‘每次访问网页时’ 在服务端设置 header(“Cache-Control: no-cache, must-revalidate”) 改为 post 接口 5. This browser lacks typed array (Uint8Array) support which is required by buffer v5.x. Use buffer v4.x if you require old browser support。（未解决） 备注：将 buffer 版本回退到4.3.0，还是有报错。 npm list buffer ├── buffer@4.3.0 └─┬ umi-plugin-react@1.15.8 └─┬ webpack@4.41.1 └─┬ node-libs-browser@2.2.1 └── buffer@4.3.0 deduped 6. cannot call a class as a function。（未解决） 注：react-dom.production@17.min.js 报错。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-16 01:30:51 "},"bugs/03-HTML常见问题概览.html":{"url":"bugs/03-HTML常见问题概览.html","title":"HTML常见问题概览","keywords":"","body":"HTML常见问题概览 1. 页面锚点偏移 在进行锚点定位时，页面往往定位到页面的最顶部，无论是上部有导航条，还是出于美观考虑，都希望定位后该内容与页面顶部有一些间距。而锚点自动定位是无法达到的。 方法一： 用Element.scrollIntoView() 滚动页面 ：该方法将当前的元素滚动到浏览器窗口的可视区域内。 方法二： 利用 padding-top 将锚点上移 100px，再用 margin-top 将内容上移 100px，修复锚点区域和内容区域 padding-top 产生的 100px的偏移。 .anchor{ padding-top: 100px; margin-top: -100px; } 类似的，也可以在元素前面新添加一个元素，设置高度，本元素设置margin-top负值. 方法三： 利用 css3 的 :target 选择器。:target 声明只支持现代浏览器，IE浏览器支持 IE9+。 .anchor:target{ padding-top:100px; } 方法四： 绑定 window.onhashchange 事件，控制页面滑动。 window.addEventListener('hashchange', function(e) { window.scrollBy(0, -100) }, false); © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-16 00:14:56 "},"bugs/04-CSS常见问题概览.html":{"url":"bugs/04-CSS常见问题概览.html","title":"CSS常见问题概览","keywords":"","body":"CSS常见问题概览 CSS样式错乱 样式在 PC 端 Chrome 浏览器中显示正常，在部分手机上错乱。 原因： 样式缺少前缀。webpack 项目中通过 autoprefixer 自动给样式加前缀（即，加 `-webkit, -ms, -moz-, -o- 等前缀），而具体需要对哪些浏览器哪些版本加前缀，是通过配置决定的。 \"browserslist\": [ \"> 1%\", \"last 2 versions\" ] 其中 last 2 versions 是指定对最新的两个版本加前缀，这个指定是不固定。随着浏览器的更新，所指向的版本也变化，导致autoprefixed 不对之前的一些旧版本加前缀。 解决方法： 在 package.json 文指定需要加前缀的浏览器及对应版本，当然，也可以用其他文档形式配置。 \"browserslist\": [ \"> 1%\", \"last 2 versions\", \"Android >= 3.2\", \"Firefox >= 20\", \"iOS >= 7\", \"chrome > 20\" ] transform: scale引起的元素模糊问题 CSS 中使用 transform: scale(1.18) 放大元素，元素中的文字图片变模糊。 原因：大概原理就是 scale 的时候导致了 font-size 算出了小数，所以 Chrome 就模糊了处理，而且只会发生在复杂的 DOM 结构里，很简单的 DOM 结构，是不会发生模糊的。因为 Chrome 在处理这种复杂 Dom 结构的缩放的时候，把 Dom 结构渲染成了一张图，然后对图片进行缩放。 解决：对原有的 Dom 结构，先进行 zoom，慢慢调试到 scale 之后文字不模糊的程度就 ok了。目前采用调整 scale 倍数的方法，即scale(1.18) 改成 scale(1.2)。 其他尝试： 加 translateZ(0)、translate3d(0,0,0) 的解决方案，亲测无效。 a标签伪类问题 问题一： :active 在移动端无效。 解决： 在元素或 body/html 上绑定一个 touchstart 事件能激活 :active 状态。 //...空函数即可 document.body.addEventListener('touchstart',function () { }); 元素使用 :active，点击字体颜色会默认到 :visited 的默认颜色，需同时设置 :active、:visited 的颜色。 伪类的优先有： /*按L-V-H-A的顺序设置超链接样式即可，可速记为LoVe（喜欢）HAte（讨厌）*/ a { &:link{} &:visited{} &:hover{} &:active{} } 表单元素的placeholder文本不居中 PC端：line-height: [和表单元素的高度一样]； 移动端：line-height：normal 。 CSS动画页面闪动，动画卡顿 尽可能地使用合成属性 transform、opacity 来设计CSS3动画，不使用 position: left | top 来定位 。 -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); box-sizing属性 content-box：设置的高度不包括上下 border、padding；宽度包括左右 border、padding； border-box：设置的宽高值包括 border、padding。 背景边框的问题 背景图片大小 background: url(xxx) no-repeat top top/80% auto; /**部分手机不支持\"/\"后加参数的写法*，可改用下面写法/ background: url(xxx) no-repeat top top auto; background-size: 80%； 渐变颜色 /*部分手机不支持background-image属性写渐变颜色。如酷派、联想s810t；*/ background-image: -webkit-radial-gradient(center center, circle cover, #0087fb 0%, #0087fb 35%,transparent 35%); 透明色 IOS中 background 渐变色中 transparent 显示为黑色。 background: linear-gradient(to right, #f91250 0%, transparent 10%, transparent 90%, #f91250 100%); 错误解决方法：将 transparent 改成 rgba(255,255,255,0)。 background: linear-gradient(to right, rgba(249,18,80,1) 0%, rgba(255,255,255,0) 10%, rgba(255,255,255,0) 90%, rgba(249,18,80,1) 100%); 正确解决方法：将 transparent 改成 rgba(249,18,80,0)，即将透明色前的色值 #f91250 转换成 rgba 值，并设置透明度设为0。 background: linear-gradient(to right, rgba(249,18,80,1) 0%, rgba(249,18,80,0) 10%, rgba(249,18,80,0) 90%, rgba(249,18,80,1) 100%); 圆形有些扁 元素设置 border-radius: 100px（大于元素宽高），圆形有些扁。 父标签字体大小设置为零，由子标签设置 font-size 属性。 底部的导航栏挡住 body 设置 height: 100% 后被底部的导航栏挡住。 document.documentElement.style.height = `${window.innerHeight}px` 滚动条未隐藏 body 设置 width: 100%; overflow: hidden，仍有 X 方向滚动条。 原因： body 没有设置 postion:relative，且有子元素中有绝对定位元素宽度超过屏幕宽度。 -webkit的问题 禁止用户选中文字：-webkit-user-select:none； 去掉按钮touch时蓝色边框 :-webkit-tap-highlight-color:rgba(0,0,0,0)； 去除webkit的滚动条: ::-webkit-scrollbar{ display: none; }； 禁止保存或者拷贝图像(仅ios有效) : img { -webkit-touch-callout: none; }； 禁止选中内容 htm: { -webkit-user-select: none;}； 修改表单元素中placeholder 的样式： ::-webkit-input-placeholder{ }； 去除表单元素的默认样式: -webkit-appearance:none； 如select、input； input type=number之后，PC 端出现上下箭头： input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none !important; margin: 0; } 快速回弹滚动 (iOS上拥有像Native 的滚动效果) { overflow: auto; -webkit-overflow-scrolling:touch; } table样式的问题 td 用 col 设置了宽度后超出部分隐藏：table 加属性 table-layout:fixed（固定宽度布局） ; col 和 colgroup 发挥作用且保证兼容的应用就只有俩： width、background； table 定义了 border-collapse:collapse 属性，border-spacing 属性不生效； table中 实现圆角效果：在 table 中设置 border-radius 发现不起作用，原因是 border-collapse: collapse 和 border-radius 不兼容。以下方法解决（chrome试验可行，未测手机兼容性）： 旧手机上的问题（机型可能已淘汰） border-radius失效 部分 Android 不识别百分比单位，可设置一个较大值的px、em、rem单位； 部分手机下，width 值过大，border-radius 无效； Android 4.2.x 不支持 border-radius 缩写； Samsung S4 (Android Browser4.4.2) 使用了 border-radius，并且使用了 -webkit-transform 属性，当使用了 translatez 或者 translate3d 值，圆角会出现问题，可用 -webkit-transform: translate(0, 0) 来避免这个问题。 Android 4.x bug 三星 Galaxy S4中自带浏览器不支持border-radius缩写 同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 android无法同时播放多音频audio © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-11 20:42:05 "},"bugs/05-JS常见问题概览.html":{"url":"bugs/05-JS常见问题概览.html","title":"JS常见问题概览","keywords":"","body":"JS常见问题 字符串转数值 parseInt(string, num) string为字符串；num为进制位数，默认为10。 把字符串中数字转换成对应进制的整数数值。 parseFloat(string) 与parseInt()方法的处理方式相似。不同之处：字符串必须以十进制形式表示浮点数，把字符串中数字转换成对应进制的浮点数。 Number(param) 将参数强制转换为数值。param类型可以为布尔值、undefined、null、字符串、Object，可为整数、浮点数。为undefined、Object时返回NAN。 +运算： 数字字符串前加\"+\"，可以转换成整数、浮点数。如：+ \"12\"、+ 12.1。 *运算 数字字符串* 1，可以转换成数值，可为整数、浮点数。 ~~运算。 运算符~原意是按位取反，使用~~可以将一个数字字符串转化成整数。如：~~'1223' >>运算 运算符>>原意是带符号右移，使用>>0可以将一个数字字符串转化成整数。如：12>>0 数字千位分隔符 (101102298.29382).toLocaleString('en')。 //'en'，必需加上，也为小写，否则会有兼容性问题 进制转换 //charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。 'a'.charCodeAt(0).toString(2) //1100001 //十进制转其他进制 const x = 97; console.log(x.toString(8)); // 十进制转八进制 \"141\" console.log(x.toString(16)) // 十进制转十六进制 \"61\" console.log(x.toString(32)); // 十进制转三十二进制 \"31\" // 其他进制转十进制 const x = '110'; console.log(parseInt(x, 2)); // 2进制转十进制 6 console.log(parseInt(x, 8)); // 8进制转十进制 72 console.log(parseInt(x, 32)) // 32进制转十进制 1056 Js预处理和各种提升 var c = 1; function c (c) { console.log(c); var c = 3; } c(2); //TypeError: c is not a function 预解析各种提升后，实际执行： var c; c = function (c) { console.log(c); var c = 3; }; c = 1; c(2); 移动端判断 let ua = navigator.userAgent.toLowerCase() // 判断微信浏览器 if (ua.match(/MicroMessenger/i) ==\"micromessenger\") {} // Android if ( /android/i.test(ua)){} // 判断IOS if ( /ipad|iphone|mac/i.test(ua)){} JQuery中attr和prop的区别 attr 和 prop 分别是单词 attribute 和 property 的缩写。在 JQuery 中， attribute 表示 HTML 文档节点的属性，property 表示 JS 对象的属性。 标签自带的属性为称为原生属性，如 checked、select、disabled，有 true、false 两个属性。 attr()： 设置和获取原生属性。 用户点击选中表单元素，用 attr() 方法无法将其取消，不论 “”、false、null 都不行；用户点击取消选中后，用 attr() 方法无法将其选中。 通过 attr() 给 checked 赋值为false|true， 用 attr( ) 获取的值为 \"true|false\" 字符串；赋值为null，attr() 获取值为 false 布尔值；赋值为 \"\"，attr( ) 获取值为 true 布尔值。 prop( )： 获取值 checked、select、disabled 为 true|false 布尔值。如果 select 的 option 定义为 disabled，则不能用 val( ) 获取其 value 值，可用 prop(\"value\")。 不要使用 removeProp( ) 来删除原生的属性。这将完全移除该属性，一旦移除，不能再次被添加到元素上，可使用 prop( ) 设置为 false 代替。 checkbox、radio、select 元素的属性 checked 和 selected。使用 attr() 和 prop() 取的值有差异： //prop()取值 $(\"#chk1\").prop(\"checked\") === false $(\"#chk2\").prop(\"checked\") === true //attr()取值 $(\"#chk1\").attr(\"checked\") === undefined $(\"#chk2\").attr(\"checked\") === \"checked\" © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-22 22:05:47 "},"bugs/06-移动端兼容性问题概览.html":{"url":"bugs/06-移动端兼容性问题概览.html","title":"移动端兼容性问题概览","keywords":"","body":"移动端兼容性问题概览 兼容性问题与手机型号、系统版本有关，只出现在部分手机上 设备更新换代快——低端机遗留下问题、高端机带来新挑战 。 浏览器厂商不统一——兼容问题多 。 网络更复杂——弱网络，页面打开慢 。 低端机性能差——页面操作卡顿 。 HTML5新技术多——学习成本不低 。 常见原因 使用了es6语法：不支持canvas\\promise等；有部分手机不支持es6，可用babel将es6转成es5。 Babel转换问题：Babel 默认只转换新的 JavaScript 语法，但是不转换新的API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比 如 Object.assign ）都不会转码。而@babel/polyfill就可以做到。 缓存问题：由于路由器或者 CDN 缓存，导致请求的文件不是最新的，或者缓存的文件内容缺失。 网络问题：部分地区网络出错，导致第三方插件无法加载、网络协议： http 和 https 使用不对。 JS API 兼容性： 不支持类数组的遍历 //部分手机中，这种遍历会报错。比如：华为畅享5S（TAG-TL00） document.querySelectorAll('div').forEach((ele, index) => {}); //修改为 Array.prototype.slice.call(document.querySelectorAll('div')).forEach((ele, index) => {}); 典型问题 IOS中input的readonly、disabled问题 disabled： 安卓设备上可以显示，IOS 设备上显示空白。解决：改为 readonly 属性。 readonly： IOS 设备上，点击仍会出现软键盘弹框。解决：样式中加 point-events: none。 IOS移动端click事件300ms的延迟相应 移动设备上的web网页是有300ms延迟的，往往会造成按钮点击延迟甚至是点击失效。这是由于区分单机事件和双击屏幕缩放的历史原因造成的。 fastclick可以解决在手机上点击事件的300ms延迟。 注意：使用了fastclick，可能会引起标签点击失效（非必现）。 zepto的touch模块，tap事件也是为了解决在click的延迟问题。 绑定ontouchstart。触摸屏顺序：touchstart > touchmove > touchend > click。 消除 transition 闪屏 -webkit-transform-style: preserve-3d; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-backface-visibility: hidden; /*(设置进行转换的元素的背面在面对用户时是否可见：隐藏)*/ 打电话发短信写邮件怎么实现 打电话： 打电话给:0755-10086 发短信（winphone 系统无效）：发短信给: 10086 写邮件：peun@foxmail.com 屏幕旋转的事件和样式 window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； window.onorientationchange = function(){ switch(window.orientation){ case -90: case 90: alert(\"横屏:\" + window.orientation); break; case 0: case 180: alert(\"竖屏:\" + window.orientation); break; } } /*竖屏时使用的样式*/ @media all and (orientation:portrait) { } /*横屏时使用的样式*/ @media all and (orientation:landscape) { } fixed元素的bug IOS 下 fixed 元素容易定位出错，软键盘弹出时，影响 fixed 元素定位。android 下 fixed 表现要比 IOS 更好，软键盘弹出时，不会影响fixed 元素定位。IOS4 下不支持position:fixed。 暂无完美方案。 Android和Ios设备，打开相机\\选择相册功能 var ua = navigator.userAgent.toLowerCase(); var isIos = (ua.indexOf('iphone') != -1) || (ua.indexOf('ipad') != -1); if (isIos) { $(\"input:file\").removeAttr(\"capture\"); }; 软键盘关闭，元素错位(部分安卓机) 弹层(加了position: fixed)中点击输入框弹出虚拟键盘，在区域1内点击（虚拟键盘关闭），页面元素错位。 原因: 与手机型号和系统版本有关，具体未知 解决方法: 无 相关链接 移动端web常见问题解决方案 H5移动端ios/Android兼容性总结 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:09:43 "},"bugs/07-小程序问题概览.html":{"url":"bugs/07-小程序问题概览.html","title":"小程序问题概览","keywords":"","body":"小程序开发中遇到的问题 常见问题 个人或海外公众号不支持webview内嵌h5页面。webview中内嵌的链接来源必须在业务域名内。 navigator跳转的链接，不能是app.json中tabBar.list中的页面 wxss，即小程序样式，不支持样式嵌套 清除缓存问题: 微信开发者工具 -> 小程序开发: 有清除缓存功能 移动端: 删除小程序(如不启效，尝试把开发版、体验版、线上版都删掉) 版本的判断：目前(2018-9-25)，小程序中没有提供判断开发版、体验版、线上版的api 页面缓存问题：小程序回到打开过的页面，不会像网页那样需要刷新页面。如果每次回到页面都需要刷新数据，可以在onShow中加逻辑。 小程序运行机制 小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。 热启动：用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台。 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况。 销毁：小程序没有重启的概念。当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁。当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁。 小程序开发工具 使用mpvue开发微信小程序 mpvue 是一个使用 Vue.js 开发小程序的前端框架（美团的开源项目）。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"css探索系列/00-CSS基础知识.html":{"url":"css探索系列/00-CSS基础知识.html","title":"CSS基础知识","keywords":"","body":"CSS基础知识 Img标签图片空隙问题 img本来是行内元素，却可以用width 和height，当父元素没有设置高度的时候，用子元素们的高度计算出的高度给父元素的时候就会出现3px空隙这类的问题。 img图片默认排版为 inline-block;而所有的inline-block元素之间都会有空白。 解决方法 方法一： display:block，把 img 标签设为块级元素 ； 方法二： font-size:0，将父容器字体大小设为零； 方法三： 去掉 img 标签之间的空格，将所用的 img 标签书写在同一行（即各个 img标签之间不换行、不留空格）； 方法四： vertical-align: top|bottom|text-top|text-bottom，修改 img元素的垂直对齐方式； 方法五： img 元素、 img 的父元素设置相同宽高，父元素加 overflow:hidden ，截掉超出的空白部分； 方法六： float: left，设置 img 的浮动属性； 方法七： 图片宽高最好为偶数。具体原理与设备的象素比有关 rem产生的小数像素问题 rem 是 css 中的相对长度单位。概括地说，rem 单位的意思是\"根元素的字体大小“，即 HTML 节点的 fontsize 值。响应式开发中，用rem 做单位，可以通过修改 HTML 节点的 fontsize 值，实现在不同屏宽下，渲染出不同尺寸的元素。 比如：HTML 节点的 font-size: 16px，其子元素 font-size: 1rem，最终计算子元素的 font-size 值 16px * 1 = 16px。 与此同时，rem 单位的使用也带来一个问题：对于单倍像素密度的屏幕而言，px 是最小的单位，如果子元素 font-size: 1.03rem，最终计算出来的值是 16px * 1.03 = 16.475px。那么，这16.475px 最终是如果渲染的呢？ .box1 ul li { height: 1.03rem; } console.log('LI元素的CSS计算高度和实际渲染高度：') Array.prototype.slice.call(document.querySelector('.box1').getElementsByTagName('li')).map((e, i) => { console.log(`第${i + 1}个：`, getComputedStyle(e).height, e.clientHeight) }) 查看DEMO 从示例可见，元素最终渲染出来的高度，有可能是17，也有可能是16。 浏览器的渲染规则：对像素小数进行四舍五入，元素最终渲染出来的像素是整数体，但是，元素真实占据的空间依旧是原始大小，即带小数的值。 也就是说，如果当前元素没有被其他元素占用空间，其尺寸带小数 0.475px，那么小数部分的渲染尺寸应该是 0px，但它会占用其临近的元素的空间。如果其临近的元素也带小数 0.475px ，加上被占用的 0.475px，实际的小数部分是0.95px，四舍五入，最终渲染为 1px，同时，它还有 0.05px 的空间可以被其它元素占用。 了解更多，可参考 http://trac.webkit.org/wiki/LayoutUnit 文本超出时省略 /*单行*/ { white-space: nowrap; overflow: hidden; text-overflow:ellipsis; } /*多行*/ { overflow: hidden; text-overflow: ellipsis; display:-moz-box; display:-webkit-box; display:box; -moz-line-clamp: 3; -webkit-line-clamp: 3; line-clamp: 3; -moz-box-orient: vertical; -webkit-box-orient: vertical; box-orient: vertical; } 自定义滚动条的颜色 注：设置在 body 上的滚动条颜色样式无效，需加在 html 标签。 /*滚动条整体样式*/ /*高宽分别对应横竖滚动条的尺寸*/ html::-webkit-scrollbar { width: 15px; /*height: 1px;*/ } /*滚动条里面小方块*/ html::-webkit-scrollbar-thumb { border-radius: 10px; background-color: skyblue; background-image: -webkit-linear-gradient( 45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.2) 75%, transparent 75%, transparent ); } /*滚动条里面轨道*/ html::-webkit-scrollbar-track { box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); background: #ededed; border-radius: 10px; } table圆角效果 在 table 中设置 border-radius 发现不起作用，原因是 border-collapse: collapse 和 border-radius不兼容。 /* 方法一 */ table { border-radius: 12px; border-spacing: 0; border: 1px solid #ccc; } /* 方法二 */ table { border-radius: 12px; border-style: hidden; box-shadow: 0 0 0 1px #ccc; } © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:09:43 "},"css探索系列/01-CSS探索系列-margin.html":{"url":"css探索系列/01-CSS探索系列-margin.html","title":"CSS探索系列 Margin","keywords":"","body":"CSS探索系列之Margin Margin是什么？ CSS 边距属性定义元素周围的空间。通过使用单独的属性，可以对上、右、下、左的外边距进行设置。也可以使用简写的外边距属性同时改变所有的外边距。 ——W3School 边界，元素周围生成额外的空白区。“空白区”通常是指其他元素不能出现且父元素背景可见的区域。 ——CSS 权威指南 Margin经常被用来做什么？ 让块元素水平居中 让元素之间留有舒适的留白 处理特殊的 first 或 last 一些布局 需要注意的地方 margin 神奇的外边距折叠 margin 怪异的百分比值 margin 的 auto 值 margin 和相对偏移 top、right、bottom、left 的异同 Margin神奇的外边距折叠 我喜欢回忆，是因为回忆是我们审视自己生活的过滤器。 回忆模糊不清，就给自我欺骗提供了机会。 .wrap { border: 1px solid #f00; } .wrap p { margin: 50px; } 按照常规思路，这两个 之间的空白应该是第一个 margin-bottom 50px 加上第二的 margin-top 50px，即 50 + 50px = 100px ，但结果总是出乎意料不是么？ 它们之间只剩下了 50px。 Why? 这就是Margin的外边距折叠现象。 这？这内部到底发生了什么，才会有这样的表现 早在CSS1中就有对 margin 折叠的说明，我们来看看： 原文：The width of the margin on non-floating block-level elements specifies the minimum distance to the edges of surrounding boxes. Two or more adjoining vertical margins (i.e., with no border, padding or content between them) are collapsed to use the maximum of the margin values. In most cases, after collapsing the vertical margins the result is visually more pleasing and closer to what the designer expects. 翻译：外边距用来指定非浮动元素与其周围盒子边缘的最小距离。两个或两个以上的相邻的垂直外边距会被折叠并使用它们之间最大的那个外边距值。多数情况下，折叠垂直外边距可以在视觉上显得更美观，也更贴近设计师的预期。 从这段话中，我们能获得一些有用的信息： 发生折叠需要是相邻的非浮动元素。 折叠发生在垂直外边距上，即margin-top/margin-bottom。 注：此特性受书写模式影响，具体可看本文后面章节。 折叠后取其中最大的那个margin值作为最终值。 到底什么是Margin折叠？ 在CSS中，两个或以上的块元素（可能是兄弟，也可能不是）之间的相邻外边距可以被合并成一个单独的外边距。通过此方式合并的外边距被称为折叠，且产生的已合并的外边距被称为折叠外边距。 处于同一个块级上下文中的块元素，没有行框、没有间隙、没有内边距和边框隔开它们，这样的元素垂直边缘毗邻，则称之为相邻。 什么是垂直边缘毗邻？ 元素的上外边距和其属于常规流中的第一个孩子的上外边距。 元素的下外边距和其属于常规流中的下一个兄弟的上外边距。 属于常规流中的最后一个孩子的下外边距和其父亲的下外边距，如果其父亲的高度计算值为 auto。 元素的上、下外边距，如果该元素没有建立新的块级格式上下文，且 min-height 的计算值为零、height 的计算值为零或 auto、且没有属于常规流中的孩子。 说得很清楚了，我想是的。你可能需要注意的是发生 margin 折叠的元素不一定是兄弟关系，也能是父子或祖先的关系。 如何避免margin折叠？ 我想肯定有人要问，那我不想有 margin 折叠的情况发生，该怎么办？其实从上面的规则中，我们已经可以抽出避免 margin 折叠的条件来。 不折叠场景： margin 折叠元素只发生在块元素上。 浮动元素不与其他元素 margin 折叠。 定义了属性 overflow 且值不为 visible（即创建了新的块级格式化上下文）的块元素，不与它的子元素发生margin 折叠； 绝对定位元素的 margin 不与任何 margin 发生折叠。 根元素的 margin 不与其它任何 margin 发生折叠； 折叠场景： 上外边距折叠：如果常规流中的一个块元素没有 border-top、padding-top，且其第一个浮动的块级子元素没有间隙，则该元素的上外边距会与其常规流中的第一个块级子元素的上外边距折叠。 如果一个元素的 min-height 属性为0，且没有上或下边框以及上或下内边距，且 height 为0或者 auto，且不包含行框，且其属于常规流的所有孩子的外边距都折叠了，则折叠其外边距。 Margin怪异的百分比 你可能从没注意过它 我必须承认这是一个非常基础的知识点，但仍然有很多人可能对此有错误的认知。 假设一个块级包含容器，宽600px，高300px，块级子元素定义 margin:10% 5%; 大家说说 margin 的 top, right, bottom, left 计算值最终是多少？ 应该有不少人脱口而出：60px 15px 60px 15px 。 我喜欢回忆，是因为回忆是我们审视自己生活的过滤器。 .wrap { width: 600px; height: 300px; border: 1px solid #f00; } .wrap p { margin: 10% 5%; background: #0aa; } 事实告诉我们结果是 60px 30px 60px 30px。 为什么会这样？ 诧异吗？不用怀疑浏览器出了问题，因为这是正确的实现。 规范中注明 margin 的百分比值参照其包含块的宽度进行计算。 Note that in a horizontal flow, percentages on ‘margin-top’ and ‘margin-bottom’ are relative to the width of the containing block, not the height (and in vertical flow, ‘margin-left’ and ‘margin-right’ are relative to the height, not the width). Note that percentages on ‘padding-top’ and ‘padding-bottom’ are relative to the width of the containing block, not the height (at least in a horizontal flow; in a vertical flow they are relative to the height). 当然，它不会这么简单，以上只是发生在默认的横向书写的情况下。 注：此特性受书写模式影响，具体可看本文后面章节。 为什么参照的是width，而不是height? 对于margin/padding-top/bottom 的百分比之所以按照 width 计算，目前主要有以下两种解释： 相对于height计算会引起无线循环 正常流中的大多数元素都会足够高以包含其后代元素（包括外边距），如果一个元素的上下外边距是父元素的height的百分数，就可能导致一个无限循环，父元素的height会增加，以适应后代元素上下外边距的增加，而相应的，上下外边距因为父元素height的增加也会增加，如此循环。 基于排版的需求 之所以按照同一个width来计算，是为了要横向和纵向2个方向都创建相同的margin/padding，如果它们的参照物不一致，那用百分比就无法得到垂直和水平一致的留白。 Margin: Auto auto是margin的可选值之一。相信大家平时使用auto值时，最多的用法大概是 margin: 0 auto; 和 margin: auto;，恩，是的，块元素水平居中。 不过你可能也发现了，不论是 margin: auto; 还是 margin: 0 auto; 效果都是一样的，都是让元素水平居中了，但纵向并没有任何变化。 根据规范，margin-top: auto; 和 margin-bottom: auto;，其计算值为0。这也就解释了为什么 margin: auto; 等同于 margin: 0 auto;。 为什么auto能实现水平居中？ 这是因为水平方向的 auto，其计算值取决于可用空间（剩余空间）。 注：此特性受书写模式影响，具体可看本文后面章节。 想象这样一个场景：一个宽200px的元素被包含在一个宽600px的元素，此元素的 margin-left: auto，大家觉得结果会怎样？ 我喜欢回忆，是因为回忆是我们审视自己生活的过滤器。回忆模糊不清，就给自我欺骗提供了机会。—— 石黑一雄《远山淡影》 .wrap { width: 600px; border: 1px solid #f00; } .wrap .margin_left { width: 200px; margin-left: auto; background: #0aa; } 这与规范描述一致。margin-left:auto; 自动占据了父节点的的可用空间，即600 - 200px = 400px。而元素中没有margin-right，也就是可用空间全部是margin-left占用的，最后的结果要当于 margin-left:400px;。即 margin-left:auto; 的结果会相当于右对齐。 同样，margin: auto; 和 margin: 0 auto; 能实现水平居中了。因为左右方向的auto值均分了可用空间，使得块元素得以在包含块内居中显示。 auto只能用于常规流中的 block-level 元素 常规流 常规流，有的也称为普通流，标准中是用normal flow一词。 将窗体自上而下分成一行一行，块级元素从上至下、 行内元素在每行中按从左至右的依次排放的布局称为常规流。 浮动机制（float）、绝对定位（postion: absolute）布局被称为是脱离常规流。 除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 block-level 元素 block-level 指的是 display 值为 block 的元素吗？我知道不少人一直有这样的认知，不过这不完全准确。 block-level 元素包含 display 值为： block list-item table table-* flex 如果position既不是static也不是relative、float不是none或者元素是根元素，当display:inline-table时，display的计算值为table；当display值为 inline | inline-block | run-in | table-* 时，display的计算值为block Margin与Relative的异同 我喜欢回忆，是因为回忆是我们审视自己生活的过滤器。回忆模糊不清，就给自我欺骗提供了机会。—— 石黑一雄《远山淡影》 我喜欢回忆，是因为回忆是我们审视自己生活的过滤器。回忆模糊不清，就给自我欺骗提供了机会。—— 石黑一雄《远山淡影》 .wrap { border: 1px solid #f00; } .wrap .compare { display: inline-block; width: 49%; padding: 10px; vertical-align: top; box-sizing: border-box; } .wrap .margin { margin-top: 50px; background: #a0a; } .wrap .relative { position: relative; top: 50px; background: #0aa; } 这似乎没什么不同？都完成了向下偏移 50px的需求。 好吧。这里还真没什么不同，至少在这里没有！不论是 margin-top 还是 relative top 都是以自身作为参照物进行偏移的。 注意： absolute 偏移相对的是上一个不为static的元素 ，并且偏移值是从其 padding 区域开始计算。 但它们真的不一样! 我们来看看规范怎么说： margin: 原文：Margins in CSS serve to add both horizontal and vertical space between boxes. 翻译：CSS中的margin用来添加盒子之间的水平和垂直间隙。 top, right, bottom, left: 原文：An element is said to be positioned if its ‘position’ property has a value other than ‘static’. Positioned elements generate positioned boxes, and may be laid out according to the following four physical properties: top, right, bottom, left. 翻译：一个元素的position属性值如果不为static则发生定位。定位元素会产生定位盒，并且会根据 top, right, bottom, left 这4个物理属性进行排版布局。 意思很明白，margin 是用来增加自身与他人之间的空白，而 top, right, bottom, left 是用来对自身进行排版，作用完全不同。 也就是说 margin 是互动的，因为它要影响他人； 而 top, right, bottom, left是孤独的，他只是自己一个人玩，不影响他人。 不是很明白？！还是直接看图吧： 我喜欢回忆，是因为回忆是我们审视自己生活的过滤器。回忆模糊不清，就给自我欺骗提供了机会。—— 石黑一雄《远山淡影》 我们不一样，每个人都有不同的境遇。。。 我喜欢回忆，是因为回忆是我们审视自己生活的过滤器。回忆模糊不清，就给自我欺骗提供了机会。—— 石黑一雄《远山淡影》 我们不一样，每个人都有不同的境遇。。。 .wrap { border: 1px solid #f00; } .wrap .compare { display: inline-block; width: 49%; padding: 10px; vertical-align: top; box-sizing: border-box; } .wrap .margin { margin-top: 50px; background: #a0a; } .wrap .relative { position: relative; top: 50px; background: #0aa; } .wrap .diff { position: relative; padding: 10px; color: #f00; } 结果有出乎你的意料吗？好吧，不论怎么，解释下为什么会这样？ 上面说过，margin 是用来增加自身与他人之间的空白，是互动的，因为他要影响他人。即margin元素往下偏移了50px，他后面的兄弟元素是从他偏移后的位置开始排版； 而 top, right, bottom, left 是用来对自身进行排版，他只是自己一个人玩，不影响他人。即ralative元素虽然也往下偏移了50px，但他的兄弟元素，还是从他偏移前的位置开始排版。 简而言之，你眼睛看到的relative元素，并不是他在布局中的真正位置。 这才是他在布局中的位置： Margin 灵活应用 等高布局 要求：不论是主栏还是侧栏，总是以最高的那列为基准高度。 但凡死缠烂打的人，大都不是真的深爱你，那只是在跟自己赛跑。真正爱你的人，做不到死缠烂打。因为自尊不允许。我们一直深信，爱就是把最好的一切给予对方，包括尊严。--多少浅浅淡淡的转身，是旁人看不懂的情深。—— 苏芩 多少浅浅淡淡的转身，是旁人看不懂的情深 .wrap { overflow: hidden; font-size: 0; } .main, .aside{ display: inline-block; width: 50%; padding: 10px; font-size: initial; background: #a0a; vertical-align: top; box-sizing: border-box; } .aside { background: #0aa; } margin的实现方法： .main, .aside{ margin-bottom: -999px; padding-bottom: 999px; } 需要提醒的是，这其实只是视觉欺骗，做到的了伪高等高。主栏和侧栏的实际高度其实并不相等，之所以可以达成这样的效果，其原因在于负 margin 值。 margin 会影响其上下文布局，当我们将元素的 margin-bottom 设置为负值时，元素及其相邻的元素，底部会自动上去其负值的高度，直到最高的那列底部边缘为止，然后裁剪。但该列本身的高度并不会发生变化，同时因为有 padding-bottom 向下扩展，颜色被填充满padding区域，于是达到视觉上的等高。 去掉列表最后一项下边框 多少浅浅淡淡的转身，是旁人看不懂的情深 多少浅浅淡淡的转身，是旁人看不懂的情深 多少浅浅淡淡的转身，是旁人看不懂的情深 多少浅浅淡淡的转身，是旁人看不懂的情深 多少浅浅淡淡的转身，是旁人看不懂的情深 .wrap li{ list-style: none; padding: 5px; border-bottom: 1px solid #a0a; } 实现的方法有很多，比如： :first-child, :nth-last-child(n), :nth-last-of-type(n) 之类的CSS3选择符，以及最原始的为最后一项单独写一个去除边框的class。 这里用margin也可以简单实现的。它有一定优势，比如兼容ie6-8、需要用到不兼容css3的html转pdf的插件。当然，如果用不上，你也可以了解下。。。 方法很简单： .wrap{ overflow: hidden; } .wrap ul{ margin-bottom: -1px; } Margin左右结构布局 absolute + margin 方式 侧边栏固定宽度 主内容栏自适应宽度 .aside{ position: absolute; top: 0; left: 0; width: 200px; background: #a0a; } .main{ margin-left: 210px; background: #0aa; } float + margin 方式 侧边栏固定宽度 主内容栏自适应宽度 .aside{ float: left; width: 200px; background: #a0a; } .main{ margin-left: 210px; background: #0aa; } float + 负margin 方式 主内容栏自适应宽度 侧边栏固定宽度 .wrap { padding-left: 210px; } /*主内容必需加float: left，不然后面内容会换行*/ .main{ float: left; width: 100%; background: #0aa; } .aside{ float: left; position: relative; left: -210px; width: 200px; margin-left: -100%; background: #a0a; } 注：这三种方法只适用左侧宽度固定的。 方法1，无法撑开父元素的高度，它将会溢出父元素区域。方法2，无法支持主内容优先显示。方法3，注意清除float。 书写模式对Margin的影响 CSS中有一些样式是受书写模式影响的。非常不幸，margin 正好是其中之一。 在水平书写模式下，发生 margin 折叠的是垂直方向，即 margin-top/margin-bottom；在垂直书写模式下，发生 margin 折叠是的水平方向，即 margin-right/margin-left。 在水平书写模式下， margin/padding-* 的百分比都按照width计算。在垂直书写模式下， margin/padding-* 都按照 height计算。 在水平书写模式下， margin: auto; 等同于 margin: 0 auto; ，即top、bottom为0；在垂直书写模式下， margin: auto; 等同于 margin: auto 0; ，即left、right为0。 可用 write-mode 更改书写模式，属性值： CSS 书写模式的24种方式 /* 关键值 */ horizontal-tb：水平方向自上而下的书写方式。即 left-right-top-bottom vertical-rl：垂直方向自右而左的书写方式。即 top-bottom-right-left vertical-lr：垂直方向内内容从上到下，水平方向从左到右 sideways-rl：内容垂直方向从上到下排列 sideways-lr：内容垂直方向从下到上排列 /*除火狐浏览器，其他的浏览器都不支持 sideways-*/ 在水平书写模式（默认）： /*块级方向：由上到下；行内方向：水平方向，从左至右。 */ .h { writing-mode: horizontal-tb; direction: ltr; } 在垂直书写模式： .v { writing-mode: vertical-rl; } direction ：用来设置文本、表列水平溢出的方向。 rtl 表示从右到左 (类似希伯来语或阿拉伯语)， ltr 表示从左到右 (类似英语等大部分语言)。 参考链接 margin系列文章 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"css探索系列/02-由z-index引发的层叠上下文思考.html":{"url":"css探索系列/02-由z-index引发的层叠上下文思考.html","title":"由Z Index引发的层叠上下文思考","keywords":"","body":"由z-index引发的层叠上下文思考 CSS 是 Cascading Style Sheets的缩写，翻译为层叠样式表。这里的层叠是css的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在CSS处于核心地位。 而本文讲的层叠上下文是三维空间Z轴上与层叠相关的概念。这里的层叠，意味着可覆盖，用户只能够看到最上层的东西，开发者必须将最终要的东西放在最上面，让用户能够一眼就看到。 这两个层叠的简述： Cascading 这个层叠，也可以翻译为级联，指的是样式的优先级，定义了如何合并来自多个源的属性值的算法。 浏览器要显示元素时求索一个 CSS 属性值的次序： 元素内嵌样式 文档内嵌样式 外部样式表 用户样式 浏览器样式 Stacking 在CSS 2.1中，每一个盒子处在三维空间中。除了水平轴和垂直轴外，还有一个z轴（z-axis），这三个轴共同决定了盒子在三维空间中的位置。 这个层叠，也可以翻译为堆叠，指的是盒子在z轴上的位置与盒子之间的重叠关系。 英文名词解释与概述 由于将英文名词翻译为中文名词容易产生歧义（如Normal flow被翻译为文档流、普通流、常规流等）。因此将Stacking涉及的一些英文名词解释如下： non-positioned element：非定位元素。也就是position: static的元素。 positioned element：定位元素。也就是position: relative/absolute/fixed/sticky的元素。 box：盒子。文档树由元素组成，渲染树由盒子组成，实际进行元素大小、布局渲染操作的对象是盒子进行而不是元素。 在构造渲染树时会为每个元素生成对应的盒子。但盒子不一定全部由元素生成，如：anonymous box不是由元素对应生成，而是渲染器根据规则自动生成。 non-positioned / positioned element：（非）定位盒子。非定位元素对应的是非定位盒子。定位元素对应的是定位盒子。 z-axis：box定位坐标系中的z轴。 stacking context：层叠上下文，z轴的基本组成单位。层叠上下文与盒子的映射关系为1:N，即每个层叠上下文可以有N个盒子。 每个层叠上下文有一个父层叠上下文（除了root stacking context外）和0~N个子层叠上下文。 root stacking context：根层叠上下文。与根盒子（html/body对应的盒子）对应的层叠上下文，是其他层叠上下文的祖先上下文，根层叠上下文的范围覆盖整条z轴。 stack level：层叠等级。当N个盒子位于同一个层叠上下文中，则通过层叠等级来决定它们位于z轴上的位置。 stacking Order：层叠顺序。表示元素发生层叠时候有着特定的垂直显示顺序。 一切从z-index开始 以上名词的具体介绍，后面会提及。此文的起因是z-index，我就从z-index开始吧。 大家可能都熟悉CSS中的z-index属性，需要跟大家讲的是，z-index实际上只是CSS层叠上下文和层叠等级中的一叶小舟。 z-index只是层叠等级中的一个属性而已，而理解z-index背后的原理实质上就是要理解层叠上下文。看一下下面示例： .box_01 > div { position: relative; padding: 5px; border-bottom: 1px solid #a0a; min-height: 100px; } .box_01 > div:nth-child(1) { background: #f00; z-index: 10; } .box_01 > div:nth-child(1) p { min-height: 80px; margin-top: 40px; background: #fa0; z-index: -999; } .box_01 > div:nth-child(2) { margin: -30px 0 0 30px; background: #a0a; z-index: 8; } .box_01 > div:nth-child(3) { margin: -30px 0 0 60px; background: #0aa; z-index: 9; } 查看DEMO 在构造渲染树时，三个div元素生成三个盒子，按先后顺序做个标记：div_1_box、div_2_box、div_3_box，p元素生成p_box。 对比这三个盒子的z-index：div_1_box > div_3_box > div_2_box。正如我们所看到，第一个div比其它两个更靠近用户，第三个div比第二个更靠近用户。 靠近用户：可理解为元素在更上层，观察者优先看到。这个跟层叠等级有关，没那么简单，后面会讲到。 关键来了：为什么p_box的z-index: -999，它会比div_2_box、div_3_box更靠近用户？ 这就跟层叠上下文有关了。 对于定位元素而言，若z-index属性值不是auto，则会创建一个新的层叠上下文，并且其子孙盒子将属于这个新层叠上下文。 同一个层叠上下文的z-index才具有可比性。 三个div元素是属于同一层叠上下文的，所以谁的z-index值大，谁就更靠近用户。而p_box虽然设置的z-index比div_2_box、div_3_box的小，但它属于第一个div元素创建的层叠上下文，与其他两个div不在同一层叠上下文。因此，它们中谁更靠近用户，并不是通过z-index简单对比决定的。 层叠规则决定哪个盒子更靠近用户 层叠规则决定了到底哪个盒子更靠近用户，四个规则如下： 盒子属于同一个层叠上下文且z-index相同： 按照盒子对应的元素在文档树的顺序，后者比前者更靠近用户。 盒子属于同一个层叠上下文，但z-index不同： z-index属性值大的盒子更靠近用户。 盒子属于不同的层叠上下文，并且层叠上下文没有祖孙/父子关系： 盒子会向上沿着父盒子进行搜索，直到父盒子属于同一个层叠上下文为止，然后比较父盒子的z-index属性值，z-index属性值大的盒子更靠近用户。 盒子属于不同的层叠上下文，并且层叠上下文为祖孙/父子关系。 子层叠上下文的盒子必定更靠近用户。 z-index在层叠中起什么作用呢 简单来说，z-index只有一个作用：设置盒子在其所属的层叠上下文中的层叠等级。z-index本身是很简单的，这也是为什么前文说，z-index只是层叠的一叶小舟。 理解z-index，就要先了解下它的特性： z-index属性值仅对定位盒子生效，而非定位盒子的z-index永远为auto。 z-index属性值不为auto，则会创建一个新的层叠上下文，并且其子孙盒子将属于这个新层叠上下文。 z-index属性值为auto，盒子不会创建一个新的本地层叠上下文。在当前层叠上下文中生成的盒子的层叠层级和父级盒子相同。 这个是css3标准。也有说法（可能是css2）： 对于具有z-index：auto，将其视为已创建新的堆栈上下文，但是任何定位的后代和实际创建新堆栈上下文的后代均应视为父级堆栈上下文的一部分，而不是此新堆栈上下文的一部分。 同一个层叠上下文的z-index才具有可比性。常说的，z-index越大层叠等级越高，并不准确。这是基于在同一层叠上下文的前提条件下。 z-index可以设置为负值。值为负的盒子比较特殊，它们会先被绘制，意味着它们可以出现在其它盒子的后面，包括父盒子。但是必要条件是该盒子必须与父盒子处于同一层叠上下文，并且父盒子不是这个层的根盒子。 为更好的理解z-index，下面举两个例子： z-index仅对定位盒子生效 将上面示例代码中的div的position: relative注释，你会发现所有的z-index值都失效了： .box_01 > div { /*position: relative;*/ padding: 5px; border-bottom: 1px solid #a0a; min-height: 100px; } 当然，将relative改成absolute/fixed/sticky，z-index也是有效的，不过它们的表现行为是不一样的，且有各自的特性。 Position属性 z-index值为auto和0的区别 z-index:0实际上和z-index:auto单纯从层叠等级上看，是可以看成是一样的。注意这里的措辞——“单纯从层叠等级上看”，实际上，两者在层叠上下文领域有着根本性的差异。 如图所示：红色元素位于紫色元素的上方。这个似乎没什么问题？毕竟红色元素的z-index值大于紫色的！ .box_02 > div { position: relative; } .box_02 > div > p { position: relative; min-height: 100px; } .box_02 > div:nth-child(1) > p { margin: 0 0 -30px 30px; background: #f00; z-index: 2; } .box_02 > div:nth-child(2) > p { background: #a0a; z-index: 1; } 查看DEMO 接下来，我们把div标签中z-index: auto改为z-index: 0： 结果反过来了：紫色的元素位于红色的上方。 按照前面的【层叠规则】和【 z-index的特性】解释下： p元素的div设置了z-index为auto，不会创建层叠上下文。所以两个元素属于同一层叠上下文，谁的z-index大，谁就更靠近用户。 由于div本身是定位元素，div的z-index改为0后，会创建新的层叠上下文，并且p元素会属于这个新建层叠上下文。如此，这两个元素就不在同一层叠上下文了，没有了可比性。不过，事情还没完，虽然它们已经无法对战，但它们的父标签div可以决出胜负。由于div属于同一层叠上下文且z-index相同，遵循后者比前者更靠近用户的规则，紫色p元素的div赢了，它更靠近用户。 z-index的内容到这里就结束了。 但，对于【层叠】来说，z-index只是一小部分。前文中也有许多地方提到层叠上下文、层叠等级等，你可以接着往下看。。。 先了解层叠的一些重要概念： 什么层叠上下文？ stacking context，通常翻译为层叠上下文，是 HTML 中的一个三维的概念，特性类似于BFC。即层叠上下文的内部子元素再怎么折腾，它们都跳不出层叠上下文的限制，不会影响外部的元素。这有点像，孙猴子有七十二般变化、一个筋头十万八千里，但他逃不出如来佛的手掌心。 在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的X轴，Y轴以及表示层叠的Z轴。x轴指向屏幕的右边，y轴指向屏幕的底部，z轴的方向指向查看者。 一般情况下，元素在页面上沿X轴Y轴平铺，我们察觉不到它们在Z轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。 如果一个元素含有层叠上下文，我们可以理解为这个元素在Z轴上就“高人一等”，并且最终表现就是它离屏幕观察者更近，也就是前面说的更靠近用户。 什么是层叠等级? Stack Level，通常翻译为层叠等级，也有译为层叠水平。它决定了同一个层叠上下文中元素在z轴上的显示顺序。 注意以下几点： 所有的元素都有层叠等级，包括层叠上下文元素，普通元素的层叠等级优先由层叠上下文决定。 层叠等级的比较只有在当前层叠上下文元素中才有意义。 千万不要把层叠等级和CSS的z-index属性混为一谈。z-index只影响定位元素以及Flex盒子的孩子元素；而层叠等级所有的元素都存在。 什么是层叠顺序？ stacking order，通常翻译为层叠顺序，表示元素发生层叠时候有着特定的垂直显示顺序。 注意：这里跟上面两个不一样，上面的层叠上下文和层叠等级是概念，而这里的层叠顺序是规则。 在HTML文档中，默认情况之下有一个自然层叠顺序（Natural Stacing Order），即元素在z轴上的顺序。它是由许多因素决定的。比如下图，它显示了元素盒子放入层叠上下文的顺序，从层叠的底部开始，共有七种层叠等级： 背景和边框：形成层叠上下文的元素的背景和边框。 层叠上下文中的最低等级。 负z-index值：层叠上下文内有着负z-index值的子元素。 块级盒：文档流中非行内非定位子元素。 浮动盒：非定位浮动元素。 行内盒：文档流中行内级别非定位子元素。 z-index: 0|auto的定位元素或者不依赖于z-index的层叠上下文（比如：opacity小于1等）。 正z-index值：定位元素。 层叠上下文中的最高等级。 这里，我们要关注的信息是： 层叠上下文的元素的背景和边框等级最低，正z-index值的定位元素等级最高。 inline/inline-block元素等级要高于block(块级)/float(浮动)元素。 不创建层叠上下文z-index: auto元素、不依赖于z-index的层叠上下文的元素与z-index:0创建了层叠上下文的元素，它们的层叠顺序是一样的，遵循后者比前者更靠近用户的层叠规则。它们的等级都比块级元素、浮动元素、行内元素更高。 层叠上下文的创建 来做一个小的测试：如果你无法实现，或者对以下的实现方法不理解，那么恭喜你，即将学习新的技能。 问题：尝试把红色的元素放到其他两个元素后面，但是必须遵守下面的规则 点击试试？： 不能修改HTML中元素的顺序 不能增加或修改任何元素的z-index属性 不能增加或修改任何元素的position属性 .box_03 > div > p { position: relative; min-height: 100px; } .box_03 > div:nth-child(1) > p{ background: #f00; z-index: 1; } .box_03 > div:nth-child(2) { margin: -30px 0 0 30px; } .box_03 > div:nth-child(2) > p{ background: #a0a; } .box_03 > div:nth-child(3) { margin: -30px 0 0 60px; } .box_03 > div:nth-child(3) > p{ background: #0aa; } 查看DEMO 你想到解决方法了吗？ 其实很简单，你只需要给第一个div标签加opacity小于1。注意：这里说的是第一个div标签，不是p标签 原因是：opacity值小于1的元素，会创建一个层叠上下文。 讲到这里，你可能会问，为什么为opacity值小于1会创建层叠上下文。这个没有为什么——这是css3的渲染机制（css2中没有）。 接下来，你可能又会问了：我知道创建了层叠上下文啊，可跟红色的跑下面有什么关系？ 原因是： 一开始有两个层叠上下文，一个由根节点产生，一个由设置了z-index:1并且position: relative的红色产生。 当我们给第一个div设置opacity小于1时，产生了第三个层叠上下文，并且会把子元素提到这个层叠上下文，意味着的z-index的作用域只在这个层叠上下文里面。而第一个div创建的是不依赖z-index（不指定z-index）的层叠上下文，它与其他两个定位元素的等级是一样的。在层叠顺序按照在文档出现顺序排列，于是这个div在最后面。 这里要注意一点：设置opacity小于1的div，是位于其他两个div的上面的。 我们把p元素去删了，给div加上边框： .box_04 > div { min-height: 100px; background: #fff; } .box_04 > div:nth-child(1) { border: 1px solid #f00; } .box_04 > div:nth-child(2) { margin: -30px 0 0 30px; border: 1px solid #a0a; } .box_04 > div:nth-child(3) { margin: -30px 0 0 60px; border: 1px solid #0aa; } 查看DEMO 设置了opacity小于1的div，属于不依赖z-index的层叠上下文，遵守层叠顺序（具体查看上一节【层叠顺序】），它的层叠等级比其他两个div块级元素高。 最后，你需要掌握以下内容：层叠上下文，什么时候会被创建？ 满足以下任意一个条件的元素，信息来源：mozilla -> css开发者指南： 文档根元素 position值为 relative | absolute | fixed且z-index值不为 auto 的元素 position值为 fixed | sticky的元素 注：css2中，position: fixed必需设置z-index为非0值 ，而css3中只要设置fixed就会创建 flex容器的子元素，且z-index值不为 auto grid容器的子元素，且z-index值不为 auto opacity属性值小于 1 的元素 mix-blend-mode属性值不为 normal 的元素 以下任意属性值不为none的元素： transform filter perspective clip-path mask/mask-image/mask-border isolation属性值为 isolate 的元素 -webkit-overflow-scrolling属性值为 touch 的元素 will-change值设定了任一属性而该属性在non-initial值时会创建层叠上下文的元素 contain属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。 注意：前面两条是CSS2的创建方法，后面的都是css3新增的。 总结： 层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。 每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。 每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。 Note: 层叠上下文的层级是 HTML 元素层级的一个子级，因为只有某些元素才会创建层叠上下文。可以这样说，没有创建自己的层叠上下文的元素会被父层叠上下文同化。 常见问题 为什么建议给absolute元素加z-index 比如下面代码 点击查看： 影斑驳，叶落纷纷，一路的繁华，消瘦在秋风里。 .box_05 { width: 300px; position: relative; } .box_05 > img { display: block; width: 100%; } .box_05 > p { position: absolute; left: 0; bottom: 0; padding: 10px; margin: 0; background: rgba(255, 255, 255, 0.8); opacity: 1; } 当给img加类似opacity/transform等属性，会发生一个奇怪现象。如下图：将的opacity设置为0.99后，图片将绝对定位的文本遮掉了。这是因为，img创建了不依赖z-index的层叠上下文，它与z-index为auto的同级，遵循层叠顺序规则，img的层级更高。 如果你已经掌握了层叠并且代码风格有良好规范，你可以忽略z-index。 IE6/7的诡异行为 IE6/IE7浏览器中，只要是定位元素就会创建层叠上下文， 就算z-index:auto也会。 总结 属于同一层叠上下文的元素（无论它们在结构上是兄弟或父子，甚至是祖孙），都遵循上文所述的层叠顺序； 不同的层叠上下文之间，层级较大的层叠上下文元素及其内部元素位于层级小的层叠上下文元素及其内部元素之上； 不同的层叠上下文之间互相独立； 层叠上下文可嵌套，内部规则不影响外部。 参考链接 CSS魔法堂：你真的理解z-index吗？ 深入理解CSS中的层叠上下文和层叠顺序 CSS 开发者指南-层叠上下文 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:14:03 "},"css探索系列/03-由浮动塌陷引发的块级格式上下文思考.html":{"url":"css探索系列/03-由浮动塌陷引发的块级格式上下文思考.html","title":"由浮动塌陷引发的块级格式上下文思考","keywords":"","body":"由浮动塌陷引发的块级格式上下文思考 浮动最初的定义：实现文本环绕图片的效果。除此之外，没有其他方法可实现。 查看DEMO 什么是浮动? css中的浮动是用float属性来定义：float: left | right | none | inline-start | inline-end float值不为none，会对display属性的值产生影响： inline-block、inline、block -> block table-* -> block inline-table、table -> table flex、inline-flex -> 值不变，但是float对这样的元素不起作用 其他值不变 当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。浮动元素不属于文档中的普通流，属于浮动布局。 (CSS三种基本的定位机制：普通流、浮动和绝对定位) 浮动的元素不会影响到普通流的块级元素的布局（如同浮动元素不存在一样），只会影响内联元素（如：文本环绕）的排列，如下图2所示。当浮动元素高度超出父元素的时候，就会出现父元素不会自动伸高来闭合浮动元素（高度塌陷现象）。顾名思义，浮动就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。 读书，去别人的灵魂里偷窥。旅行，去陌生的环境里去感悟。电影，去荧屏里感受别人的生活历程。冥想，去自己内心的秘境里探寻。读书，去别人的灵魂里偷窥。旅行，去陌生的环境里去感悟。电影，去荧屏里感受别人的生活历程。冥想，去自己内心的秘境里探寻。 .box_02 img { width: 100%; } .box_02 > .item_02 { padding: 20px; border: 1px solid #0aa; } .box_02 > .item_02 .container_float, .box_02 > .item_02 .img_float { float: left; width: 100px; margin-left: 20px; margin-right: 20px; } .box_02 > .item_02 .bg { height: 50px; margin-top: 5px; background: #0aa; } 查看DEMO 浮动造成影响 会对相邻的元素（紧邻浮动元素后面的元素）产生影响。 如果相邻元素是块级元素会无视这个浮动的块框（如上图中的背景色模块），也就是我们平时看到的效果——使到自身尽可能与这个浮动元素处于同一行，导致被浮动元素覆盖。 如果相邻元素是内联元素，则会尽可能围绕浮动元素（如上图中的文案模块）。 父元素在获取高度计算时，会忽略浮动元素，即不计算浮动元素高度。这就是浮动塌陷，也称高度塌陷现象。 什么是块级格式化上下文? 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 BFC 主要用于对块级元素排版。创建了 BFC 的元素就是一个独立的盒子（HTML中的一个盒子, 看不见而已），里面的子元素不会在布局上影响外面的元素，同样，外面的元素，也不会影响其子元素。 从这一点来说，块级格式化上下文的特性与层叠上下文（css探索系列之CSS层叠）类似。 下列方式会创建块格式化上下文： 根元素：html> 浮动元素：float不为 none 绝对定位元素：position不为static | relative overflow值不为 visible的块元素 行内块元素：display: inline-block 表格单元格：display: table-cell。HTML表格单元格默认为该值 表格标题：display: table-caption。HTML表格标题默认为该值 匿名表格单元格元素：display: table | inline-table | table-row | table-row-group | table-header-group | table-footer-group display: flow-root。一个新的 display 属性的值，它可以创建无副作用的 BFC。注：Safari不支持。 弹性元素：display: flex | inline-flex元素的直接子元素 网格元素：display: grid | inline-grid 元素的直接子元素 contain: layout | content | paint 多列容器：column-count 或 column-width 不为 auto、column-count: 1 column-span: all。即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 注意：display: table本身并不会创建BFC，但是它会产生匿名盒子（anonymous boxes），而匿名盒子中的display: table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display: table。所以通过display:table和display: table-cell创建的BFC效果是不一样的。 块级格式化上下文的特性 块格式化上下文对浮动定位（float）、清除浮动（clear）、外边距折叠（Margin collapsing）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。 块级格式化上下文的三个特性： BFC会阻止外边距折叠（CSS探索系列之Margin） 当两个相邻的块框在同一个块级格式化上下文中时，它们之间垂直方向的外边距会发生叠加。换句话说，如果这两个相邻的块框不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。 根据规定，一个块级格式化上下文的边框不能和它里面的元素的外边距重叠。由于这个原因，当给一个挨着浮动的块级格式化上下文添加负的外边距时将会不起作用 BFC不会重叠浮动元素 BFC内的浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。 BFC通常可以包含浮动，即计算BFC的高度时，浮动元素也参与计算 独立的块级上下文可以包裹浮动流，全部浮动子元素也不会引起容器高度塌陷，也就是说父元素会把浮动元素的高度也计算在内，所以不用清除浮动来撑起高度。同时BFC任然属于文档中的普通流。 因此，父元素创建了新的BFC，可以闭合浮动 什么是hasLayout? hasLayout是ie私有的概念，ie7及更低版本的ie浏览器不支持BFC，但我们可以针对ie7、6浏览器加入对应的hasLayout规则来实现BFC的效果！ IE使用Layout概念来控制元素的尺寸和位置。可以用Javascript函数hasLayout查看一个元素是否拥有Layout，返回true | false。如果一个元素有Layout，它就有自身的尺寸和位置；如果没有，它的尺寸和位置由最近的拥有布局的祖先元素控制。 hasLayout是一个只读属性，所以无法使用Javascript进行设置。它的值为true的时候会达到和BFC类似的效果。 以下方法可以使元素hasLayout为true： position: absolute float: left | right display: inline-block width: 除 auto 外的任意值 height: 除 auto 外的任意值 zoom: 除 normal外的任意值 writing-mode: tb-rl IE7中overflow: hidden|scroll|auto 怎样清除浮动呢？ 清除浮动，也可以称为闭合浮动。两者实质上，都是为了消除浮动塌陷。它们的区别在于： 清除浮动：对应的单词是 clear，对应CSS中的属性是clear：left | right | both | none，只能清除同一BFC中在它前面的元素的浮动。 闭合浮动：更确切的含义是使浮动元素闭合，即创建BFC，从而消除浮动塌陷。 确切的说，我们想要达到的效果是闭合浮动，而不是单纯的清除浮动。单纯的清除浮动，并不能解决容器高度塌陷的问题。 比如：我们将上一个示例的背景色模块，加上样式clear: both清除浮动，该模块的浮动还是会影响其后面的兄弟元素。如下图3： ... 查看DEMO 再如：我们将上一个示例的背景色模块，加上样式 display: flow-root 闭合浮动，创健了新 BFC，那么，它就不会影响其他 BFC 的元素了。如下图4： ... 查看DEMO 三种清除浮动的方法 方法一（摧荐）： 父元素加伪元素，并给伪元素加clear：both ，据说是最高大上的方法 优点：浏览器支持好，不容易出现怪问题 缺点：注意浏览器兼容问题 .clear_float { /*对IE6/7的兼容处理，触发 hasLayout*/ zoom: 1; } .clear_float:after, .clear_float::after { clear: both; content: '.'; display: block; width: 0; height: 0; visibility: hidden; } ... ... 查看DEMO 方法二：浮动元素后，新增空标签div，并设置样式clear：both 优点：通俗易懂，容易掌握 缺点：将添加很多无意义的空标签 ... ... 查看DEMO 方法三：浮动元素后，新增空标签br标签，并设置属性clear=\"both\"。与方法二类似 ... ... 查看DEMO 闭合浮动的方法 为浮动元素的父元素创建 BFC（为兼容ie6，还需触发hasLayout，如加:zoom: 1）。比如： (推荐)display: inline-block。注意设置width: 100%。 overflow: auto | hidden | visible。据说auto对seo比较友好， hidden对seo不是太友好，但切记不能使用visible值。缺点：内部元素宽高超过父元素时，会出现滚动条（scroll）或者隐藏溢出部分(hidden)。 float: left | right。缺点：使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body。 display: table。缺点：盒模型属性已经改变，由此造成的一系列问题，得不偿失。 display: flow-root。一个新的 display 属性的值，它可以创建无副作用的 BFC。缺点：Safari不支持。 参考链接 MDN float MDN 块格式化上下文 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"css探索系列/04-CSS探索系列-flex布局.html":{"url":"css探索系列/04-CSS探索系列-flex布局.html","title":"CSS探索系列 Flex布局","keywords":"","body":"CSS探索系列之flex布局 当对一个文档进行布局的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）。每个盒子由四个部分组成：内容 Content、内边距 Padding、边框 Border、外边距 Margin。CSS 决定这些盒子的大小、位置以及属性（例如颜色、背景、边框尺寸…）。 布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 Flex是 Flexible Box的缩写，意为\"弹性盒子\"，用来为盒状模型提供最大的灵活性。 弹性盒子布局（Flexible Box Layout）定义了一种针对用户界面设计而优化的 CSS盒子模型。在弹性布局模型中，弹性容器的子元素可以在任何方向上排布，也可以弹性伸缩其尺寸，既可以增加尺寸以填满未使用的空间，也可以收缩尺寸以避免父元素溢出。子元素的水平对齐和垂直对齐都能很方便的进行操控。 基本概念 弹性盒子布局是一种一维的布局模型，一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局 网格布局，可以同时处理行和列上的布局。 .container { display: flex | inline-flex; /**生成块或内联的弹性容器**/ } 弹性容器： display属性的值为 flex | inline-flex 的元素。 弹性项目：弹性容器的每个子元素都称为弹性项目。 轴：每个弹性盒子布局包含两个轴。弹性项目沿其依次排列的那根轴称为主轴。垂直于主轴的那根轴称为侧轴(cross axis)。 方向：弹性容器的主轴起点(main start)/主轴终点(main end)和侧轴起点(cross start)/侧轴终点(cross end)描述了弹性项目排布的起点与终点。它们具体取决于弹性容器的主轴与侧轴中，由 writing-mode 确立的方向（从左到右、从右到左，等等）。 行：根据 flex-wrap 属性指定弹性项目单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向（从左到中、从右到左）。 尺寸：根据弹性容器的主轴与侧轴，弹性项目的宽和高中，对应主轴的称为主轴尺寸(main size) ，对应侧轴的称为 侧轴尺寸(cross size)。 由于弹性盒子使用了不同的布局算法，某些属性用在弹性容器上没有意义： 多栏布局模块的 column-* 属性对弹性项目无效。 float与 clear对弹性项目无效。使用 float将使元素的 display属性计为block。 vertical-align 对弹性项目的对齐无效。 容器的属性 以下6个属性设置在容器上： flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction属性 定义了主轴的方向(正方向或反方向)，即弹性项目的排列方向。 初始值：row 取值： row：主轴为水平方向，从左到右。 row-reverse：主轴为水平方向，从右到左。 column：主轴为垂直方向，从上往下。 column-reverse：主轴为垂直方向，从下往上。 请注意： row 和 row-reverse 受 flex 容器的direction属性的影响。 css属性 direction 用来设置文本、表列水平排列的方向，初始值ltr。 ltr 表示从左到右 (类似汉语、英语等大部分语言)， rtl 表示从右到左 (类似希伯来语或阿拉伯语)。 direction属性是 ltr，row表示从左到右定向的水平轴，而 row-reverse 表示从右到左; 如果 dir属性是 rtl，row表示从右到左定向的轴，而row-reverse 表示从左到右。 column和column-reverse受弹性容器的 writing-mode 属性的影响。 writing-mode 属性指定块流动方向，即块级容器堆叠的方向，以及行内内容在块级容器中的流动方向。 horizontal-tb：行内元素从左到右或从右到左（受direction属性的影响） ，块元素由上往下。 vertical-rl：行内元素由上往下或由下往上，块元素从左到右或从右到左。（受direction属性的影响） vertical-lr：行内元素由上往下或由下往上，块元素从左到右或从右到左。（受direction属性的影响） flex-wrap属性 指定弹性项目单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向。 初始值：nowrap 取值： nowrap：弹性项目被摆放到到一行，这可能导致溢出弹性容器。 cross-start 会根据 flex-direction 的值 相当于 start 或 before。 wrap：弹性项目被打断到多个行中，行由上往下排列。 wrap-reverse：和 wrap的行为一样，但是行由下往上排列。 flex-flow属性 flex-flow 属性是 flex-direction 和flex-wrap 的简写。 初始值：row nowrap。 flex-flow: column-reverse wrap; justify-content属性 定义了弹性项目在主轴上的对齐方式及其周围的空间的分配。 初始值：flex-start 取值： flex-start：主轴起点对齐。 flex-end：主轴终点对齐。 center： 居中。 space-between：两端对齐，弹性项目之间的间隔都相等。 space-around：每个弹性项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 space-evenly：弹性项目之间、弹性项目与边框之间的间隔都相等。 以上六个是常见取值，还有值start、left、right、baseline、first baseline、last baseline、stretch、safe、unsafe。？？ align-items属性 属性定义弹性项目在侧轴上如何对齐。 初始值：normal。取决于我们处在什么布局模式中 取值： flex-start：侧轴起点对齐 flex-end：侧轴终点对齐 center：中间对齐 baseline: 弹性项目的第一行文字的基线对齐 stretch：弹性项目将占满整个容器的高度（弹性项目未设置高度或设为auto）。 align-content属性 当弹性盒子分多行时，定义了行的对齐方式和周围分配空间。该属性对单行（即：未设置flex-wrap或 flex-wrap: nowrap）弹性盒子模型无效。 取值： flex-start：侧轴起点对齐 flex-end：侧轴终点对齐 center：中间对齐 space-between：与侧轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个侧轴（弹性项目未设置高度或设为auto）。 place-content属性 是 align-content 和 justify-content 的简写。第一个值为 align-content属性, 第二个值为justify-content 。 place-content: center start; 非常重要：如果没有设置第二个值，那么第二个的值与第一个相等，此前提是第一个值对两个属性都是有效的。如果设置的这个值对两个属性都无效，那么整个设置的值就是无效的。 项目的属性 以下6个属性设置在项目上： order flex-grow flex-shrink flex-basis flex align-self order属性 定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性 指定了弹性项目扩展规则，即弹性容器中剩余空间的应该分配多少给弹性项目。 剩余的空间是弹性容器的主轴尺寸减去所有弹性项目的尺寸和。 默认为0，即如果存在剩余空间，也不放大；大于0，则弹性容器剩余空间的分配就会发生；负值无效。 具体规则如下： 所有剩余空间总量是1 只有一个弹性项目设置了 flex-grow属性值 如果flex-grow值小于1，则扩展的空间就是总剩余空间 * flex-grow值 如果flex-grow值大于1，则独享所有剩余空间 有多个弹性项目设置了flex-grow属性值 如果flex-grow值总和小于1，则每个子项扩展的空间就是总剩余空间 * flex-grow值。 如果flex-grow值总和大于1，则所有剩余空间被利用，分配比例就是flex-grow属性值的比例。 如：所有弹性项目都有相同的flex-grow系数，那么所有的项目将获得相同的剩余空间。 如：三个弹性项目，有一个的flex-grow属性为2，其他项目都为1，即：1：2：1，则值为2的占据剩余空间的2/4，其他两个分别占1/4。 flex-shrink属性 指定了弹性项目的收缩规则。弹性项目仅在默认宽度之和大于容器，且未设置flex-wrap或者flex-wrap: nowrap的时候才会发生收缩。 不足空间是所有弹性项目的宽度和 - 弹性容器的宽度。 默认值为1，即如果空间不足，弹性项目将缩小；值为0表示不收缩；负值无效。 具体规则： 只有一个弹性项目设置了flex-shrink flex-shrink值小于1，则收缩的尺寸不完全，会有一部分内容溢出弹性容器。 flex-shrink值大于等于1，则收缩完全，正好填满弹性容器。 多个弹性项目设置了flex-shrink flex-shrink值的总和小于1，则收缩的尺寸不完全，每个弹性项目的收缩尺寸为不足空间 * flex-shrink值。 flex-shrink值的总和大于1，则收缩完全，每个弹性项目收缩尺寸的比例和flex-shrink值的比例一样。 如：所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。 如：一个弹性项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性 指定了弹性项目在主轴方向上的初始大小。浏览器根据这个属性，计算主轴是否有多余空间。 注意：弹性项目的最终尺寸，是由一系列盒模型属性和布局算法决定的，具体可查看下文【弹性项目尺寸的计算】章节。 初始值：auto 取值： auto，即弹性项目的本来大小。 最初 auto的含义是 \"参照width和height属性\"。 在此之后，auto的含义变成了自动尺寸, 而 main-size 变成了 \"参照width和height属性\"。实际执行于 bug 1032922. 然后呢，这个更改又在 bug 1093316 中被撤销了, 所以 auto变回了原来的含义；而一个新的关键字 content变成了自动尺寸。 (bug 1105111 包括了增加这个关键字)。 可以跟width或height属性的值一样（比如350px、2rem、30%），则弹性项目将占据固定空间。负值是不被允许的。 Note: 当一个元素同时被设置了 flex-basis (除值为 auto 外) 和 width (或者在 flex-direction: column 情况下设置了height) ， flex-basis 具有更高的优先级。 content 基于弹性项目的内容自动调整大小。除火狐，其他大多数浏览器不支持。 其他值。除火狐，其他大多数浏览器不支持。 /* 固有的尺寸关键词 */ flex-basis: fill; flex-basis: max-content; flex-basis: min-content; flex-basis: fit-content; flex属性 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，后两个属性可选。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 默认值：initial，0 1 auto。 flex 属性可以指定1个，2个或3个值： 单值语法：值必须为以下其中之一 一个无单位数值：它会被当作的值。 一个有效的宽度(width)值：它会被当作 的值。 关键字none，auto或initial。 auto ：1 1 auto none：0 0 auto initial：0 1 auto。即：flex-grow、flex-shrink、flex-basis的默认值。 双值语法：第一个值必须为一个无单位数值，当作 的值。第二个值必须为以下之一 一个无单位数：它会被当作 的值。 一个有效的宽度值：它会被当作 的值。 三值语法 第一个值必须为一个无单位数，并且它会被当作 的值。 第二个值必须为一个无单位数，并且它会被当作 的值。 第三个值必须为一个有效的宽度值， 并且它会被当作 的值。 align-self属性 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。 初始值：auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 取值：可能取6个值，除了auto，其他都与align-items属性完全一致。 弹性项目尺寸的计算 在弹性盒子布局中，一个弹性项目的最终尺寸是基础尺寸、弹性增长或收缩、最大最小尺寸限制共同作用的结果： 基础尺寸：由CSS flex-basis、width等属性，内容尺寸以及box-sizing盒模型共同决定； 弹性增长指的是flex-grow属性，弹性收缩指的是flex-shrink属性； 最大最小尺寸限制指的是min-width/max-width等CSS属性，以及min-content最小内容尺寸。 #优先级 最大最小尺寸限制 > 弹性增长或收缩 > 基础尺寸 弹性项目尺寸的计算规则： 如果没有设置 flex-basis 属性，那么 flex-basis 的大小就是弹性项目的 width 属性的大小； 如果没有设置 flex-basis 、 width 属性，那么 flex-basis 的大小就是弹性项目内容的大小； 默认情况下，flex-basis的大小不会收缩至小于内容尺寸。若想改变这一状况，可以设置 min-width、width 属性。 主轴空间有剩余空间，遵循flex-grow规则；空间不足，遵循flex-shrink规则 以下在实际开发的项目中遇到的问题：使用了flex布局后，弹性项目中文本溢出自动省略号（...）的属性（即， text-overflow:ellipsis ）失效。 低眉含笑间 寒灯纸上梨花雨凉 谁的深情绚烂了三生石上的一见倾心 灯烛依旧 无人执手。低眉含笑间 寒灯纸上梨花雨凉 谁的深情绚烂了三生石上的一见倾心 灯烛依旧 无人执手 .box_01 { display: flex; padding: 10px; border: 1px solid #0aa; } .box_01 .item_01 { margin-right: 15px; padding: 10px; color: #fff; text-align: center; background-color: #0aa; white-space: nowrap; } .box_01 .item_01 .text { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .box_01 .item_01_text01 { min-width: 0; } /* .box_01 .item_01_text02 { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } */ 查看DEMO 从本质上来说，ellipsis失效的是因为.text元素中的文本没有溢出。 .text_parent元素是一个弹性项目，设置了flex: 1（即：flex-grow:1; flex-shrink:1; flex-basis: auto;，flex-basis: auto;），且没有设置width属性，它的宽度由内容宽度决定，即.text元素的宽度。 .text元素默认情况下width: 100%，宽度与父元素.text_parent一样。父元素宽度不固定的情况下，.text元素的宽度取内容宽度，即文本的宽度。 最终结果：.text_parent的宽度 = .text的宽度 = 文本宽度，所有文本没有溢出 要使ellipsis启效，首先我们可以想到的方法是给.text元素设置一个小于文本宽度的width值，但这种方法显然不适用于响应式开发。 另一种思路是：给.text_parent指定一个小于文本宽度的width值。 方法一：.text_parent设置overflow属性 .text_parent { overflow: hidden; } 弹性项目在弹性容器中，有一个可用宽度。设置overflow后，表示弹性项目宽度不超出可用宽度。 方法二：.text_parent设置width属性 .text_parent { width: 0; } 弹性项目的width属性的作用是告诉浏览器：我有自己的宽度，不需要取内容的宽度。注意：弹性项目的最终尺寸不一定是css中的width值，它会根据一系列的盒模型属性来计算。 方法三：.text_parent设置min-width属性 /** 根据CSS规范草案，一般情况下min-width属性默认值是0，但弹性项目的min-width属性默认值是auto，这样能为弹性盒子布局指明更合理的默认表现。 **/ .text_parent { min-width: 0; } 弹性项目设置了min-width属性，浏览器将采用如下算法（shrink-to-fit算法 ??）： 弹性项目宽度 = min ( max (最小宽度, 可用宽度) , 首选宽度) 最小宽度：min-width的值 可用宽度：弹性项目在弹性容器中的允许宽度 首选宽度：内容不发生换行的时的宽度。（示例中的文本宽度） 以上是个人对弹性项目width计算的理解，如有不对，敬请指正。 参考文章： 张鑫旭 - Oh My God，CSS flex-basis原来有这么多细节 flexbox 布局中 flex 项的宽度计算原理 浏览器前缀 flex布局需要一些浏览器前缀来最大力度地兼容大多数的浏览器。Flex布局的前缀不只是在属性前面添加浏览器前缀，不同浏览器下的属性名和属性值都不同，这是因为Flexbox布局的标准一直在变，一共有old, tweener, new三个版本。 可能处理前缀的最好方法是使用新的语法书写CSS并通过Autoprefixer运行CSS，能够很好地处理这个问题。 另外，这里有一个Sass中 @mixin 来处理一些前缀，也可以给你一些处理前缀的启发： @mixin flexbox() { display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; } @mixin flex($values) { -webkit-box-flex: $values; -moz-box-flex: $values; -webkit-flex: $values; -ms-flex: $values; flex: $values; } @mixin order($val) { -webkit-box-ordinal-group: $val; -moz-box-ordinal-group: $val; -ms-flex-order: $val; -webkit-order: $val; order: $val; } .wrapper { @include flexbox(); } .item { @include flex(1 200px); @include order(2); } 参考链接 MDN CSS 布局 mdn CSS 弹性盒子布局 Flex 布局教程：语法篇 张鑫旭 写给自己看的display: flex布局教程 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"css探索系列/05-CSS探索系列-gradient.html":{"url":"css探索系列/05-CSS探索系列-gradient.html","title":"CSS探索系列 Gradient","keywords":"","body":"CSS3探索系列之gradient 是一种特别的数据类型，用于表现两种或多种颜色的过渡转变。只能被用于可以使用的地方。因此，它并不适用于background-color以及类似的使用数据类型的属性中。 通常，在CSS中渐变就是background的background-image，也就是说，适用于背景图像的CSS属性都适合于渐变。 渐变容器（渐变框） 图像和传统的背景图像不一样，它是无限的渐变图像，可见区域是由渐变容器大小来决定的。 一个DOM元素的background-image使用linear-gradient，其显示区域就是元素的border-box区域（即：包括内容、内边距和边框，但不包括外边距）。其实也是background-color或者说通过url引入背景图像的显示区域。 然而，如果你通过CSS的background-size设置一个尺寸，比如说200px * 200px，这个时候渐变容器（渐变尺寸）就是200px * 200px。在没有使用background-position设置为其他值时，它默认是显示在DOM元素的左上角（也就是background-position: left top）。 线形渐变 颜色值沿着一条隐式的直线逐渐过渡。由linear-gradient()创建一个表示两种或多种颜色线性渐变的图片。 语法 linear-gradient([ | to ,]? [] ... ) 通过指向边或者角，指定渐变的方向，可不写，默认值为 to bottom。 取值：to left/ to right/ to top/ to bottom/ to top left/ to bottom right。关键词的先后顺序无影响，即to top left和to left top是一样的。 用角度值指定渐变的方向（或角度），可不写，默认值为 180deg（等价to bottom）。 0deg表示指向北方的方向，角度顺时针增加。 取值：90deg、135deg、0.25turn、100grid、1rad。 在带前缀的变体和不带前缀的提案之间仍然存在一项语义的分歧：标准将0deg指向北方，带前缀的保持原始的角度定义，即0deg指向东方。 CSS角度单位：deg、grad、rad、turn 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad deg：度（Degress）。一个圆共360度 grad：梯度（Gradians）。一个圆共400梯度 rad：弧度（Radians）。一个圆共2π弧度 turn：转、圈（Turns）。一个圆共1圈 颜色终止点，由组成，位置可不写。如：#e66465、#e66465 50%、#e66465 100px等。可写两个或多个颜色终止点。 颜色终止列表中颜色的终止点应该是依次递增的。如果一个颜色中间点的位置比前一个小，那么将会被设定成与前一个相同的值。 如果第一个颜色中间点没有位置属性,那么它默认为0%。如果最后一个颜色中间点没有位置属性, 则默认为100%。如果一个既不是起始也不是终止的颜色中间点，没有被明确声明位置，那么这个颜色就会从前后两个颜色的中间位置开始。 定义了在相邻之间过渡的中点，默认值50%。注：相邻两个之间只能有一个过渡点。 background-image: linear-gradient(#e66465, #9198e5); /*下图左，与【#e66465, 50%, #9198e5】等价*/ background-image: linear-gradient(#e66465, 10%, #9198e5); /*下图中*/ background-image: linear-gradient(#fb3 40%, #e66465 30%, #9198e5); /*下图右*/ 示例 查看DEMO .box_01 .item_01 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; border: 1px solid #0aa; background-image: linear-gradient(#e66465, #9198e5); } .box_01 .item_01:nth-child(2) { background-image: linear-gradient(0.25turn, #3f87a6, #ebf8e1, #f69d3c); } .box_01 .item_01:nth-child(3) { background-image: linear-gradient(217deg, rgba(255, 0, 0, .8), rgba(255, 0, 0, 0) 70.71%), linear-gradient(127deg, rgba(0, 255, 0, .8), rgba(0, 255, 0, 0) 70.71%), linear-gradient(336deg, rgba(0, 0, 255, .8), rgba(0, 0, 255, 0) 70.71%); } .box_01 .item_01:nth-child(4) { background-image: linear-gradient(#3f87a6 33.33%, #fb3 0, #fb3 66.66%, #e45b5a 0); background-size: 100% 42px; } 径向渐变 颜色值由一个中心点（原点）向外扩散并逐渐过渡到其他颜色值。由radial-gradient()函数产生。 语法 radial-gradient([ [ | ] at ]? [] ... ) 表示用于设置相对于框的位置的2D空间中的坐标，即x轴、y轴坐标，默认值center。 取值：关键字（left, right, top, bottom or center），或者百分比，或是一个绝对的长度值 如：left、left top、left center、center top、50%、100px、5rem等。x轴、y轴都是关键字时，顺序无影响。 渐变的形状，默认值ellipse（椭圆）。 取值：ellipse（椭圆）、circle（正圆） 渐变圆的半径长度。 当渐变类型为 circle 时，只能指定一个size值，值必需为具体的长度值，即直径；当渐变类型为 ellopse时，可以指定两个size值，即水平半径，垂直半径，值可以为具体的长度值或者百分比。 关键字用于描述边缘轮廓的具体位置。以下为关键字常量： | 常量 | 描述 | | :---------------- | :----------------------------------------------------------- | | closest-side | 渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆）。 | | closest-corner | 渐变的边缘形状与容器距离渐变中心点最近的一个角相交。 | | farthest-side | 与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边）。 | | farthest-corner | 渐变的边缘形状与容器距离渐变中心点最远的一个角相交。 | 颜色终止点，由组成，位置可不写。如：#e66465、#e66465 50%、#e66465 100px等。可写两个或多个颜色终止点。 颜色终止列表中颜色的终止点应该是依次递增的。如果一个颜色中间点的位置比前一个小，那么将会被设定成与前一个相同的值。 如果第一个颜色中间点没有位置属性,那么它默认为0%。如果最后一个颜色中间点没有位置属性, 则默认为100%。如果一个既不是起始也不是终止的颜色中间点，没有被明确声明位置，那么这个颜色就会从前后两个颜色的中间位置开始。 定义了在相邻之间过渡的中点，默认值50%。 示例 查看DEMO .box_02 .item_02 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; border: 1px solid #0aa; background-image: radial-gradient(#ff0, #9198e5); } .box_02 .item_02:nth-child(2) { background-image: radial-gradient(at top, #ff0, #9198e5); } .box_02 .item_02:nth-child(3) { background-image: radial-gradient(circle at top, #ff0, #9198e5); } .box_02 .item_02:nth-child(4) { background-image: radial-gradient(circle closest-corner at top, #ff0, #9198e5); } .box_02 .item_02:nth-child(5) { background-image: radial-gradient(ellipse 50px 50px at top, #ff0, #9198e5); } .box_02 .item_02:nth-child(6) { background-image: radial-gradient(#3f87a6 33.33%, #fb3 0, #fb3 66.66%, #e45b5a 0); background-size: 42px 42px; } 圆锥渐变 圆锥渐变创建一个图像，由一个梯度组成，颜色起始点是图形中心，然后以顺时针方向绕中心实现渐变效果（而不是从中心辐射）。由conic-gradient()函数产生。 语法 conic-gradient([ from ]? [ at ]?, [] ... ) ) 颜色围绕中心点旋转的角度值，可不写，默认值为0deg（指向北方）。 表示用于设置相对于框的位置的2D空间中的坐标，即x轴、y轴坐标，默认值center。 取值：关键字（left, right, top, bottom or center），或者百分比，或是一个绝对的长度值 如：left、left top、left center、center top、50%、100px、5rem等。x轴、y轴都是关键字时，顺序无影响。 颜色终止点，由组成，位置可不写。如：#e66465、#e66465 90deg、#e66465 0.25turn、#e66465 0.25turn 0.75turn等。可写两个或多个颜色终止点。 定义了在相邻之间过渡的中点，默认值50%。 示例 查看DEMO .box_03 .item_03 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; border: 1px solid #0aa; background-image: conic-gradient(red, orange, yellow, green, teal, blue, purple); } .box_03 .item_03:nth-child(2) { background-image: conic-gradient(from 40deg, red 0deg, orange 90deg, yellow 180deg, green 270deg, blue 360deg) } .box_03 .item_03:nth-child(3) { background-image: conic-gradient(from 40deg at 25% 25%, red 0deg, orange 90deg, yellow 180deg, green 270deg, blue 360deg) } .box_03 .item_03:nth-child(4) { background-image: conic-gradient(red 36deg, orange 36deg 170deg, yellow 170deg); } .box_03 .item_03:nth-child(5) { background-image: conic-gradient(red 12.5%, orange 0 37.5%, red 0 62.5%, orange 0 87.5%, red 0); background-size: 50px 50px; } .box_03 .item_03:nth-child(6) { background-image: conic-gradient(#3f87a6 33.33%, #fb3 0, #fb3 66.66%, #e45b5a 0); background-size: 42px 42px; } .box_03 .item_03:nth-child(7) { position: relative; background: conic-gradient(rgba(255, 152, 0, 1) 0, rgba(255, 152, 0, 0) 100%); border: 0; text-align: center; vertical-align: top; } .box_03 .item_03:nth-child(7):after { position: absolute; top: 10%; left: 10%; display: block; width: 80%; height: 80%; content: \" \"; background: #fff; } 重复渐变 重复多次渐变图案直到足够填满指定元素。 重复线性渐变 repeating-linear-gradient()创建一个由重复线性渐变组成的， 这是一个类似linear-gradient 的函数，并且采用相同的参数，但是它会在所有方向上重复渐变以覆盖其整个容器。 重复径向渐变 repeating-radial-gradient() 创建一个从原点辐射的重复渐变组成的 。它类似于radial-gradient并且采用相同的参数，但是它会在所有方向上重复颜色，以覆盖其整个容器。 重复圆锥渐变 repaeting-conic-gradient 创建一个颜色过渡旋转围绕中心点的重复渐变组成的 。重复圆锥渐变语法与conic-gradient()相似。 示例 查看DEMO .box_04 .item_04 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; border: 1px solid #0aa; background-image: repeating-linear-gradient(-45deg, transparent, transparent 25px, orange 25px, orange 50px); } .box_04 .item_04:nth-child(2) { background-image: repeating-linear-gradient(transparent, transparent 23%, orange 23%, orange 27%), repeating-linear-gradient(90deg, transparent, transparent 23%, orange 23%, orange 27%); } .box_04 .item_04:nth-child(3) { background-image: repeating-radial-gradient(red, yellow 10%, green 15%); } .box_04 .item_04:nth-child(4) { background-image: repeating-radial-gradient(circle, red, red 10px, yellow 10px, yellow 20px); background-size: 25px; } .box_04 .item_04:nth-child(5) { background-image: repeating-conic-gradient(red 0 9deg, yellow 9deg 18deg); } .box_04 .item_04:nth-child(6) { background-image: repeating-conic-gradient(red 0 9deg, yellow 9deg 18deg); background-size: 50px 50px; } 其他渐变 查看DEMO 愿你走出 半生归来 仍是少年 .box_05 .item_05 { display: inline-block; width: 200px; height: 200px; margin-right: 15px; vertical-align: middle; border: 1px solid #0aa; } .box_05 .item_05:nth-child(1) { border: 10px solid transparent; border-image: linear-gradient(to top, red, orange); border-image-slice: 10; } .box_05 .item_05:nth-child(2)>div { height: 60px; margin-top: 60px; font-size: 42px; background-image: linear-gradient(to top, red, orange); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; } .box_05 .item_05:nth-child(3)>div { height: 60px; margin-top: 60px; font-size: 42px; position: relative; color: red; text-align: center; } .box_05 .item_05:nth-child(3)>div:before { position: absolute; color: orange; -webkit-mask: linear-gradient(to top, red, transparent); content: attr(text); z-index: 1; } .box_05 .item_05:nth-child(4)>div { height: 60px; margin-top: 60px; text-align: center; } .box_05 .item_05:nth-child(4)>div .gradient-text-three { fill: url(#SVGID_1_); font-size: 48px; } 参考链接 MDN 使用 CSS 渐变 MDN linear-gradient 神奇的 conic-gradient 圆锥渐变 复杂的css背景图 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"css探索系列/06-为什么使用PostCSS处理CSS？.html":{"url":"css探索系列/06-为什么使用PostCSS处理CSS？.html","title":"为什么使用PostCSS处理CSS？","keywords":"","body":"为什么使用PostCSS 处理CSS ？ postcss是什么？ PostCSS是一个用 JavaScript 工具和插件转换 CSS 代码的工具。 PostCSS并不是一门语言，而是一个类似于webpack的工具，它支持很多插件，来达到便捷的编译效果，组成一个CSS编译/lint/autoprefixer的生态圈。它的作者是Euil Martians，一家致力于技术研究与网站外包开发的公司。其后端技术栈偏重于Ruby，而前端从 React 到 Node 都有涉猎。 PostCSS 本身是一个功能比较单一的工具。它提供了一种方式用 JavaScript 代码来处理 CSS。它负责把 CSS 代码解析成抽象语法树结构（Abstract Syntax Tree，AST），再交由插件来进行处理。 插件基于 CSS 代码的 AST 所能进行的操作是多种多样的，比如可以支持变量和混入（mixin），增加浏览器相关的声明前缀，或是把使用将来的 CSS 规范的样式规则转译（transpile）成当前的 CSS 规范支持的格式。从这个角度来说，PostCSS 的强大之处在于其不断发展的插件体系。 目前 PostCSS 已经有 200 多个功能各异的插件。开发人员也可以根据项目的需要，开发出自己的 PostCSS 插件。 实际上，PostCSS 的主要功能只有两个： 第一个就是前面提到的把 CSS 解析成 JavaScript 可以操作的 AST， 第二个就是调用插件来处理 AST 并得到结果。 因此，不能简单的把 PostCSS 归类成 CSS 预处理或后处理工具。PostCSS 所能执行的任务非常多，同时涵盖了传统意义上的预处理和后处理。 为什么选择postcss？ 随着前端工程化的不断完善，CSS 预处理器已经成为项目中不可缺少的部分，很多人在项目技术选型阶段就会先选择一个 CSS 预处理器，绝大部分前端工程的脚手架也内置了一系列的 CSS 预处理的模版。 CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成 CSS 的程序。 市面上有很多 CSS 预处理器可供选择，且绝大多数 CSS 预处理器会增加一些原生 CSS 不具备或不完善的高级特性，这些特性让 CSS 的结构更加具有可读性且易于维护。当前社区代表的 CSS 预处理器 主要有以下几种： Sass：2007 年诞生，最早也是最成熟的 CSS 预处理器，拥有 Ruby 社区的支持和 Compass 这一最强大的 CSS 框架，目前受 LESS 影响，已经进化到了全面兼容 CSS 的 SCSS。 Less：2009年出现，受 SASS 的影响较大，但又使用 CSS 的语法，让大部分开发者和设计师更容易上手，在 Ruby 社区之外支持者远超过 SASS，其缺点是比起 SASS 来，可编程功能不够，不过优点是简单和兼容 CSS，反过来也影响了 SASS 演变到了 SCSS 的时代，著名的 Twitter Bootstrap 就是采用 LESS 做底层语言的。 Stylus：Stylus 是一个CSS的预处理框架，2010 年产生，来自 Node.js 社区，主要用来给 Node 项目进行 CSS 预处理支持，所以 Stylus 是一种新型语言，可以创建健壮的、动态的、富有表现力的 CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似， 相比其他的 CSS 预处理器，postcss 优势主要体现在以下几个方面： 根据你需要的特性进行模块化，而不是像 less 或者 scss 一样的全家桶。 多样化的功能插件，创建了一个生态的插件系统 拥有极高的处理性能（3倍以上的处理速度） 可以自己编写postcss插件 既可以写正常的CSS，也可以结合 LESS 或者 SASS 一起编写 可以与许多流行工具无缝部署，例如webpack、gulp、codepen 等 对 Source Map 支持更好 一句话来概括PostCSS：CSS编译器能够做到的事情，它也可以做到，而且能够做得更好 postcss的使用 PostCSS的一大特点是，具体的编译插件甚至是CSS书写风格，可以根据自己的需要进行安装，选择自己需要的特性：嵌套，函数，变量。自动补全，CSS新特性等等，而不是像less或者scss一样的大型全家桶。因此，不需要再专门去学习less或者scss的语法，只要选择自己喜欢的特性，可以只写 CSS 文件，但依旧可以写嵌套或者函数，然后选择合适的插件编译它就行了。 到目前，PostCSS有200个多个插件。你可以在插件列表或搜索目录找到它们。你也可以自己开发PostCSS插件。 安装：npm i -D postcss-loader postcss的配置： webpack.config.js，优先级最高 // webpack.config.js { test: /\\.css$/, use: [ 'style-loader', 'css-loader', { loader: 'postcss-loader', options: { ident: 'postcss', plugins: (loader) => [ require('postcss-import')({ root: loader.resourcePath }), require('postcss-preset-env')(), require('cssnano')() ] } } ] } postcss.config.js或者.postcssrc.js // postcss.config.js module.exports = ({ file, options, env }) => ({ parser: file.extname === '.sss' ? 'sugarss' : false, plugins: { 'autoprefixer': {}, 'postcss-import': { root: file.dirname }, 'postcss-preset-env': options['postcss-preset-env'] ? options['postcss-preset-env'] : false, 'cssnano': env === 'production' ? options.cssnano : false } }) .postcssrc { \"plugins\": { \"postcss-plugin\": {} } } package.json 中的 postcss，优先级最低 { \"postcss\": { \"plugins\": { \"postcss-plugin\": {} } } } 基于webpack，创建测试项目 鉴于现在webpack也越来越火，所以之后的配置主要是借助于postcss-loader，将PostCSS的生态圈依托在webpack之下。 安装： npm i webpack webpack-cli -g npm i webpack npm i css-loader postcss-loader mini-css-extract-plugin -D 项目结构如下： - build - webpack.postcss.config.js - src - index.css - index.js - package.json - postcss.config.js // webpack.postcss.config.js const webpack = require('webpack') const Path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const webpackConfig = { mode: 'production', entry: './src/index.js', output: { path: Path.resolve(__dirname, '../dist'), filename: 'index.js' }, module: { rules: [ { // 使用 PostCSS 处理 CSS 文件 test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', ] } ] }, plugins: [ new MiniCssExtractPlugin({ filename: 'index.css', chunkFilename: 'chunkIndex.css', }) ] } webpack(webpackConfig, err => {}) MiniCssExtractPlugin 不能与 style-loader 一起使用 webpack(webpackConfig, err => {})，要传回调函，可以为空 // index.js import './index.css' /*index.css*/ .hello { box-sizing: border-box; } // package.json { ... \"scripts\": { \"postcss\": \"node build/webpack.postcss.config.js\" }, ... } // postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { } }) 常用插件 Autoprefixer 安装：npm i autoprefixer -D 利用从 Can I Use 网站获取的数据为 CSS 规则添加特定厂商的前缀。Autoprefixer 自动获取浏览器的流行度和能够支持的属性，并根据这些数据帮你自动为 CSS 规则添加前缀。 我们可以用以下方法，对插件配置参数，(Browserslist，指定目标浏览器范围 )： postcss.config.js： //postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { \"autoprefixer\": { \"overrideBrowserslist\": [ \"> 0.1%\", \"last 2 versions\", \"Android >= 3.2\", \"Firefox >= 20\", \"iOS >= 7\", \"chrome > 20\" ] } } }) package.json 增加如下配置： { \"browserslist\": [ \"> 1%\", \"last 2 versions\", \"Android >= 3.2\", \"Firefox >= 20\", \"iOS >= 7\", \"chrome > 20\" ] } 根目录下加.browerslistrc配置文件： # 注释是这样写的，以#号开头 \"> 1%\", \"last 2 versions\", \"Android >= 3.2\", \"Firefox >= 20\", \"iOS >= 7\", \"chrome > 20\" 具体配置参数，可以参考前端工程基础知识点--Browserslist (基于官方文档翻译） /* 输入 src/index.css */ .autoprefixer { box-sizing: border-box; } /* 输出 dist/index.css */ .autoprefixer { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } postcss-nesting 、postcss-nested 支持css的嵌套写法。 安装：npm i postcss-nesting -D 安装：npm i postcss-nested -D 他们两个的区别是： postcss-nesting: W3C nested selectors，遵循W3C的写法，每个嵌套的样式前面都需要一个&（注意符号后面有个空格） postcss-nested: Sass-like nested selectors，不需要加&符号 建议是使用 postcss-nesting ，遵循W3C规则。 //postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { \"postcss-nesting\": {} } }) /*postcss-nesting，嵌套样式前需要加&符号*/ /*postcss-nested，正常样式前不需加&符号，伪类前还是要加*/ /*输入*/ .postcss_nesting { & sub_class { width: 100%; } & a { color: red; } } /*输出*/ .postcss_nesting sub_class { width: 100%; } .postcss_nesting a { color: red; } postcss-import 允许css通过@ import内联其他css模块。 安装：npm i postcss-import -D // postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { \"postcss-nesting\": {} } }) 新增一个import.css文件，在index.css中导入： /*import.css*/ .import { color: red; } .import_sub { width: 100%; } /*index.css*/ @import './import.css'; 最终输出到dist/index.css： /*import.css*/ .import { color: red; } .import_sub { width: 100%; } postcss-preset-env 安装：npm i postcss-preset-env -D 帮你将现代 CSS 语法转换成大多数浏览器都能理解的东西，根据你的目标浏览器或运行时环境来确定你需要的 polyfills，基于 cssdb 实现。 postcss-preset-env 已经内置了 autoprefixer、postcss-nesting/postcss-nested、postcss-import 等相关功能。 //postcss.config.js module.exports = { plugins: { \"postcss-preset-env\": { features: { \"custom-properties\": { preserve: false, variables: {} }, \"nesting-rules\": true } } } } 具体参数可查看postcss-preset-env 或者 feature cssnano 安装：npm i cssnano -D cssnano会采用格式良好的CSS并通过许多有针对性的优化来运行它，以确保最终结果对于生产环境而言尽可能小。 //postcss.config.js module.exports = { plugins: { \"cssnano\": { preset: [\"default\", { // 禁止插件对自定义动画名称的重命名 reduceIdents: false, // 禁用postcss重写z-index值 zindex: true }] } } } /*输入*/ .autoprefixer { box-sizing: border-box; } .postcss_nesting { & sub_class { width: 100%; } & a { color: red; } } .cssnano { font-size: 16px; z-index: 1000; } /*输出*/ .autoprefixer{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.postcss_nesting sub_class{width:100%}.postcss_nesting a{color:red}.cssnano{font-size:16px;z-index:1000} postcss-apply 允许您将一组属性存储在指定的定制属性中，然后在其他样式规则中引用它们。 您正在使用@apply 规则和自定义属性集。该功能将不会包含在 postcss-cssnext 的下一个主要版本中。这很可能不会得到来自浏览器供应商的更多支持，因为该规范尚未被认可，并且正在讨论替代解决方案。 安装：npm i postcss-apply -D //postcss.config.js module.exports = { plugins: { \"postcss-import\": {}, \"postcss-apply\": {} } } 新增一个apply.css，引入到index.css： /*apply.css*/ :root { --no-wrap: { width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } } /*index.css*/ @import './apply.css'; .apply { color: green; @apply --no-wrap; } 最终输出到dist/index.css： /*dist/index.css*/ .apply { color: green; width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } postcss-apply 要跟 postcss-import 一起使用 postcss-mixins 样式混入文件中。 安装：npm i postcss-mixins -D //postcss.config.js module.exports = ({ file, options, env }) => ({ plugins: { \"postcss-mixins\": {}, } }) /*输入*/ @define-mixin icon $name, $color: blue { .icon.is-$(name) { color: $color; } .icon.is-$(name):hover { color: white; background: $color; } } @mixin icon twitter { background: url(twt.png); } /*输出*/ .icon.is-twitter { color: blue; } .icon.is-twitter:hover { color: white; background: blue; } postcss-px2rem-exclude 安装：npm i postcss-px2rem -D 安装：npm i postcss-px2rem-exclude -D //postcss.config.js module.exports = { \"plugins\": { \"postcss-px2rem-exclude\": { remUnit: 75, exclude: /node_modules|folder_name/i } } } /*输入*/ .px2rem { width: 100px; font-size: 30px; } /*输出*/ .px2rem { width: 1.333333rem; font-size: 0.4rem; } 参考文档 postCss 初识 （文章较长，需要耐心） 2019年，你是否可以抛弃 CSS 预处理器？ © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:36:58 "},"css探索系列/11-CSS3中一些高级属性的应用.html":{"url":"css探索系列/11-CSS3中一些高级属性的应用.html","title":"CSS3中一些高级属性的应用","keywords":"","body":"CSS3中一些高级属性的应用 关于CSS3 CSS3 是层叠样式表（Cascading Style Sheets）语言的最新版本，旨在扩展 CSS2.1。 它带来了许多期待已久的新特性， 例如圆角、阴影、gradients(渐变) 、transitions(过渡) 与 animations(动画) 。以及新的布局方式，如 multi-columns 、 flexible box 与 grid layouts。实验性特性以浏览器引擎为前缀，应避免在生产环境中使用，或极其谨慎地使用，因为将来它们的语法和语义都有可能被更改。 CSS Level 2 经历了 9 年的时间（从 2002 年 8 月到 2011 年 6 月）才达到推荐状态，主要原因是被一些次要特性拖了后腿。为了加快那些已经确认没有问题的特性的标准化速度，W3C 的CSS 工作组作出了一项被称为 Beijing doctrine 的决定，将 CSS 划分为许多小组件，称之为模块。这些模块彼此独立，按照各自的进度来进行标准化。其中一些已经是 W3C推荐状态，也有一些仍是早期工作草案。当新的需求被肯定后， 新的模块也会同样地添加进来。 从形式上来说，CSS3 标准自身已经不存在了。每个模块都被独立的标准化，现在标准 CSS 包括了修订后的 CSS2.1 以及完整模块对它的扩充，模块的 level（级别）数并不一致。可以在每个时间点上为 CSS 标准定义一个快照（snapshots），列出 CSS 2.1 和成熟的模块。 W3C 会定期的发布这些快照 ，如 2007, 2010, 2015 或 2017。 目前为止，还没有标准（level）超过 3 的模块被标准化，未来应该会有所改变。 不过有些模块，比如 Selectors（选择器）4 或 CSS Borders and Backgrounds（边框和背景）标准4早已拥有了编辑草案，即使它们还没达初次发布工作草案状态。 CSS3 带来众多全新的设计体验，但 web 开发人员最关心的一个问题：浏览器对 CSS3 特性的兼容情况如何？ 目前而言，CSS3 特性大部分都已经有了很好的浏览器支持度。各主流浏览器对 CSS3 的支持越来越完善，曾经让多少web开发人员心碎的 IE 也开始挺进 CSS3 标准行列。 当然，即使 CSS3 标准制定完成，现代浏览器要普及到大部分用户也是一个相当漫长的过程。 本文主要是整理一些有趣的且有用的，但容易被忽视的高级属性。以后还会继续补充一些。 -webkit-mask CSS 属性 mask 允许使用者通过遮罩或者裁切特定区域的图片的方式来隐藏一个元素的部分或者全部可见区域。 原理：蒙板（CSS3 渐变、半透明的PNG图）元素的 alpha 值为 0 的时候会覆盖下面的元素，为1的时候会完全显示下面的内容。 mask属性实际上已经成为了诸多mask-*的缩写，这和background, border性质是一样的。 具体属性： mask-image：指遮罩使用的图片资源，默认值是none，也就是无遮罩图片 mask-mode：默认值是match-source，意思是根据资源的类型自动采用合适的遮罩模式。 mask-repeat：默认值是repeat，行为类似于background-repeat属性。 mask-position：和background-position支持的属性值和表现基本上都是一模一样的。 mask-clip：和background-clip类似，但是mask-clip支持的属性值要多一点，主要是多了个SVG元素的mask-clip支持。 mask-origin：和background-origin类似，但是mask-origin支持的属性值要多一点，主要是多了个SVG元素的mask-origin支持。 mask-size：和background-size类似，支持的属性值也类似，作用是控制遮罩图片尺寸。 mask-type：和mask-mode类似，都是设置不同的遮罩模式。但还是有个很大的区别，那就是mask-type只能作用在SVG元素上，本质上是由SVG属性演变而来，因此，Chrome等浏览器都是支持的。但是mask-mode是一个针对所有元素的CSS3属性，Chrome等浏览器并不支持，目前仅Firefox浏览器支持。 mask-composite：当同时使用多个图片进行遮罩时候的混合方式 具体使用可查看 客栈说书：CSS遮罩CSS3 mask/masks详细介绍 .box_01 { padding: 10px 20px; border: 1px solid #0aa; } .box_01 img { width: 290px; } .box_01 img.mask { animation: aniMask 2s infinite; } @keyframes aniMask { 0 { -webkit-mask-image: conic-gradient(rgba(0,0,0,0), rgba(0,0,0,0.2), rgba(0,0,0,1), rgba(0,0,0,1)); } 100% { -webkit-mask-image: conic-gradient(rgba(0,0,0,1), rgba(0,0,0,1), rgba(0,0,0,0), rgba(0,0,0,0.2)); } } 查看 -webkit-mask DEMO 以上只是一个简单的示例。mask是一个非常有趣的属性，我们可以用mask + gradient + animation 制造一些非常酷炫的效果。 -webkit-text-stroke CSS边框的一个不足就是只有矩形的元素才能使用。-webkit-text-stroke 可以为文字添加边框。它不但可以设置文字边框的宽度，也能设置其颜色。而且，配合使用color: transparent 属性，你还可以创建镂空的字体！ .box_02 { font-size: 42px; font-family: 'Times New Roman'; text-align: center; } .box_02 span { color: transparent; -webkit-text-stroke: 1px red; } Today is good and tomorrow will be the same 查看 -webkit-text-stroke DEMO -webkit-box-reflect -webkit-box-reflect 属性使您可以在一个特定方向上反映元素的内容。 -webkit-box-reflect:none | none：无倒影 ：指定倒影与对象的方向。取值：above、below、left、right ：设置倒影与对象的距离。 : 设置倒影的遮罩图像。可以为：none| | 。 .box_03 { font-size: 24px; text-align: center; } .box_03 img { width: 200px; -webkit-box-reflect: below 5px linear-gradient(to right, transparent, white); } .box_03 span { display: inline-block; color: #0aa; -webkit-box-reflect: below 5px; } Today is good and tomorrow will be the same 查看 -webkit-box-reflect DEMO font-size-adjust font-size-adjust 属性为某个元素规定一个 aspect值，这样就可以保持首选字体的 x-height。 字体的小写字母 \"x\" 的高度与 \"font-size\" 高度之间的比率被称为一个字体的 aspect 值。当字体拥有高的 aspect 值时，那么当此字体被设置为很小的尺寸时会更易阅读。 假如：我们设置的font-family 的第一个字体是Verdana，由于某种原因用户的电脑上没有安装 Verdana，用的是 Arial，那么 Arial 就会被修正，从而和 Verdana有相同的长宽比。 注：目前 chrome 目前（2021.10.14）已不支持该属性。 .box_04 { font-size: 24px; text-align: center; color: #0aa; } “砌下梨花一堆雪，明年谁此凭栏杆？”一树梨花一承乾，此番美景属何人，只愿你在树下，梨花落如雪... “砌下梨花一堆雪，明年谁此凭栏杆？”一树梨花一承乾，此番美景属何人，只愿你在树下，梨花落如雪... 查看 font-size-adjust DEMO background-clip background-clip 设置元素的背景（背景图片或颜色）是否延伸到边框、内边距盒子、内容盒子下面。 border-box：背景延伸至边框外沿（但是在边框下层）。 padding-box：背景延伸至内边距（padding）外沿。不会绘制到边框处。 content-box：背景被裁剪至内容区（content box）外沿。 text ：背景被裁剪成文字的前景色。 通过值 text，可以给文字设置多种颜色，包括渐变色。 .box_05 { font-size: 100px; text-align: center; } .box_05 .two { background: linear-gradient(to right, #0aa 0%, #0aa 50%, red 50%, red 100%); color: transparent; -webkit-background-clip: text; } .box_05 .gradient { background: linear-gradient(to right, #0aa 0%, red 100%); color: transparent; -webkit-background-clip: text; } A A 查看 background-clip DEMO columns CSS 属性 columns 用来设置元素的列宽和列数。 columns: || column-count：描述元素的列数 column-width：理想的列宽。容器将具有尽可能多的适合的列，而其中任何一个列的宽度均小于该column-width值。如果容器的宽度小于指定的值，则单列的宽度将小于声明的列的宽度。 column-fill：控制列的高度。auto 指示按顺序填充列；balance，指示内容在各列之间平均分配。 column-rule：是 column-rule-color、column-rule-style、column-rule-width 的组合写法，类似 border。 column-gap：列之间的间隔。 column-span：设置为 all 时，可以让一个元素跨越所有的列。 .item_06 { width: 600px; margin-bottom: 10px; padding: 20px; border: 1px solid #0aa; } .item_06.columns { columns: 3; column-rule: 1px solid #0aa; column-gap: 30px; column-fill: auto; height: 210px; } .item_06.columns h3 { column-span: all; } 一轮皓月，柔情似水，洒满心湖，照亮远方；一株幽兰，清香淡雅，彼此凝望，寂静欢喜；一叶兰舟，盛满思念，载滿祝福，划过秦时明月，穿过唐风宋韵，驶向心灵的渡口。一轮皓月，柔情似水，洒满心湖，照亮远方；一株幽兰，清香淡雅，彼此凝望，寂静欢喜；一叶兰舟，盛满思念，载滿祝福，划过秦时明月，穿过唐风宋韵，驶向心灵的渡口。 一轮皓月，柔情似水，洒满心湖，照亮远方 一轮皓月，柔情似水，洒满心湖，照亮远方；一株幽兰，清香淡雅，彼此凝望，寂静欢喜；一叶兰舟，盛满思念，载滿祝福，划过秦时明月，穿过唐风宋韵，驶向心灵的渡口。一轮皓月，柔情似水，洒满心湖，照亮远方；一株幽兰，清香淡雅，彼此凝望，寂静欢喜；一叶兰舟，盛满思念，载滿祝福，划过秦时明月，穿过唐风宋韵，驶向心灵的渡口。 查看 background-clip DEMO -webkit-margin-collapse 通常，两个相邻的元素的margin会折叠起来(collapse)，即外边距折叠。这意味着第一个元素的底部的边距和第二个元素的头部边距会被合并到一起。 margin-collapse 可以指定垂直间距的表现形式。元素可以保持它们各自的间距，也可以共同使用一个间距。 这个属性值允许模拟表格在一些浏览器的quirks模式下的行间距表现形式。比如垂直相邻表格单元格的边距可以合并入边框。 margin-top-collapse 控制该元素与其上方相邻元素之间间距的表现形式，而 margin-bottom-collapse 正好相反，控制的是该元素与其下方相邻元素之间间距的表现形式。 collapse：两个相邻元素的垂直间距合并成一个间距。 discard：如果该元素与其垂直相邻元素之间存在间距，那么将取消该间距。 separate：保持两个垂直相邻元素自身的间距。 其他 webkit 属性 -webkit-tap-highlight-color：rgba(0,0,0,0)：禁止 IOS、iPhone、iPad 在点击时出现半透明的灰色背景。 -webkit-touch-callout：none：你触摸并按住触摸目标时候，禁止或显示系统默认菜单 -webkit-appearance: none：禁止输入框中的默认样式 -webkit-user-select：none：禁止选择文本 -webkit-text-size-adjust： 网页字体缩放样式 -webkit-overflow-scrolling: touch：目前只能针对 IOS 出现滚动条 参考链接 MDN CSS3 CSS3那些不为人知的高级属性 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:18:02 "},"css探索系列/14-CSS探索系列-line-height.html":{"url":"css探索系列/14-CSS探索系列-line-height.html","title":"CSS探索系列 Line Height","keywords":"","body":"CSS探索系列之line-height line-height，又称行高，具体来说是指两行文字间基线间的距离，也可以称为一行文字所占的高度。在CSS，line-height 被用来控制行与行之间的垂直距离。 常规使用 line-height CSS 属性用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度。 替代的 inline 元素：img、iframe、video之类的由加载资源决定显示尺寸的元素 line-height 属性被指定为以下任何一个： normal: 取决于用户端。桌面浏览器（包括Firefox）使用默认值，约为1.2，这取决于元素的 font-family。 数字（推荐）: 无单位数字，乘以该元素的字体大小。 长度: 以em、px、rem等为单位的值。 百分比: 与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小。 基本概念 顶线、中线、基线、底线 文本排版的几个基本概念：顶线、中线、基线、底线。vertical-align 属性中有 top、middle、baseline、bottom，与这四条线有关。 基线（baseline），指的是一行字横排时下沿的基础线，基线并不是汉字的下端沿，通常可以理解为英文字母 x 的下端沿。 字体高度、行高、行距和半行距 字体高度：顶线到底线的距离。我们，一般字体高度会大于或者等于字体大小，不同的字体会有差异。 行高：两行文本基线之间的距离。 行距：两行文本之间第一行的底线到第二行顶线的距离。行距 = 行高 - 字体高度 半行距：行距的一半。 内容区域、内联盒子、行框盒子、包含盒子 内容区域(content area)：是一种围绕文字看不见的盒子。内容区域的大小与 font-size 大小和 font-family 相关，与 line-height 没有任何关系。点击查看字体字号和盒子的关联 内联盒子(inline boxes)：每个行内元素会生成一个行内框，行内框是一个浏览器渲染模型中的一个概念，无法显示出来。内联盒子不会让内容成块显示，而是排成一行。 如：外部包含inline水平的标签(span、a、em、strong等)，则属于内联盒子。如果是个光秃秃的文字，则属于匿名内联盒子。行内框默认等于内容区域，除非设置了padding。 行框盒子(line boxes)：每一行就是一个行框盒子，每个行框盒子又是由一个一个内联盒子组成。行框盒子是浏览器渲染模式中的一个概念，无法显示出来。行框高度等于本行中所有行内框高度的最大值。当有多行内容时，每一行都有自己的行框。 包含盒子(containing box)：由一行一行的行框盒子组成，高度就是单行文本高度的累加。 内联元素的高度表现 行高(line-height) = 内容区域高度(content area) + 行间距(vertical spacing) 行高决定内联盒子的高度；内容区域高度只跟 font-size、font-family 有关；行间距可大可小(甚至负值)，保证高度正好等于行高。 行框盒子里面有多个不同行高的内联盒子，高度并不是简单的由行高最高的那个盒子决定，还需要考虑 vertical-align 属性值。 如下图： 上部分内联元素的高度：第一个 span: 28.4px，第二个 span: 54.8px，第三个 span: 18px。span 外层的包含盒子高度取决于第二个span，高度为52.8px（不包含 span 的边框）。 下部分内联元素的高度，与上部分完全一样。同时，给第三个 span 加一个 css 属性 \"vertical-align: -40px;。span 外层的包含盒子高度为 87.6px（具体计算逻辑未知？？）。 中文 English English 中文 English English 查看内联元素的高度DEMO 另外，行间距为负值时，如果 line-height 小于 font-size，inline box 会优先于行高，以保证 inline box 的高度正好等于行高。 line-height应用 单行文字的垂直居中对齐 一般来说，line-height 值设置为 height 一样大小的值，可以实现单行文字的垂直居中。实际上，height 是非必要的，删除height 单行文字也能居中的。 .box_02 { /*height: 50px;*/ line-height: 50px; border: 1px solid #eee; color: #5dc2d0; } 不要问，不要等，不要犹豫，不要回头。 查看单行文字的垂直居中DEMO 多行文字的垂直居中 高度不固定 div，多行文字垂直居中可以用 padding。 高度固定的 div，多行文字垂直居中可以借助于 line-height 来实现。 .box_03 { height: 100px; line-height: 100px; border: 1px solid #eee; color: #e60012; } .box_03 span { display: inline-block; line-height: 18px; vertical-align: middle; } 盈盈一点芳心，占多少春光，问卿知否？红妆莫斗。谁得似、净骨天然清瘦。神娟韵秀。 盈盈一点芳心，占多少春光，问卿知否？红妆莫斗。谁得似、净骨天然清瘦。神娟韵秀。 注：span 标签要加 display: inline-block属性，或者改用块级标签。 查看多行文字的垂直居中DEMO 图片的垂直居中 高度固定的 div，可以用 line-height 来实现不同高度图片的垂直居中。 .box_04 ul li { display: inline-block; width: 150px; line-height: 150px; border: 1px solid #eee; } .box_04 ul li img { width: 100px; vertical-align: middle; } 查看图片的垂直居中DEMO 相关扩展：vertical-algin vertical-algin属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。它只对行内元素、表格单元格元素生效，不能用它垂直对齐块级元素。 属性值可以为： baseline：元素的基线与父元素的基线对齐。 sub：元素的基线与父元素的下标基线对齐。 super：元素的基线与父元素的上标基线对齐。 text-top：元素的顶部与父元素的字体顶部对齐。 text-bottom：元素的底部与父元素的字体底部对齐。 middle：元素的中线与父元素的基线加上父元素 x-height（译注：x高度）的一半对齐。 ：元素的基线对齐到父元素的基线之上的给定长度。可以是负数。 ：元素的基线对齐到父元素的基线之上的给定百分比，该百分比是 line-height 属性的百分比。可以是负数。 top：元素及其后代元素的顶部与整行的顶部对齐。 bottom：元素及其后代元素的底部与整行的底部对齐。 注：上述值，top、bottom是相对整行垂直对齐，其余是相对其父元素垂直对齐。 表格单元格的值 baseline、sub、super、text-top、text-bottom、、，是单元格的基线，与该行中所有以基线对齐的其它单元格的基线对齐。 top：使单元格内边距的上边缘与该行顶部对齐。 middle：使单元格内边距盒模型在该行内居中对齐。 bottom：使单元格内边距的下边缘与该行底部对齐。 注：没有基线的元素，使用外边距的下边缘替代。 一个inline-block元素，如果里面没有inline内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线。 vertical-algin 的百分比值是按 line-height 属性计算的。 相关问题 img元素底部为何有空白？ 在 div 中加入 img 标签，如果 div 有背景色或者边框属性，会发现图片底部会有一些空白。如下图： .box_05 { border: 1px solid #5aa572; } .box_05 img { height: 250px; } wenqingzhifou？ 查看img元素底部空白DEMO 在HTML5文档声明下，块状元素内部的内联元素的行为表现，就好像块状元素内部还有一个（更有可能两个-前后）看不见摸不着没有宽度没有实体的空白文本节点。 其具体表现，和图片后面有文字是一样的，如下图： 具体跟 vertical-align 和 line-height 有关： img 标签默认的 display 属性值是 inline，其后面的文本是由一个匿名内联元素包裹。图片和文本的垂直对齐方式是 vertical-align: baseline，即基线对齐。img 标签的基线是图片的下边缘，文本的基线一般认为是小写 x 的下边缘（上图中，为 w 的下边缘）。图片与文本的基线对齐，最终渲染出来，图片底部就会留出一些空白。 这里的一个关键点是，为什么 img 标签的基线是图片的下边缘？怎么来定位内联元素的基线？ CSS2的可视化格式模型文档中有一么一段话： The baseline of an ‘inline-block’ is the baseline of its last line box in the normal flow, unless it has either no in-flow line boxes or if its ‘overflow’ property has a computed value other than ‘visible’, in which case the baseline is the bottom margin edge. 这段话，我理解为：内联元素的基线是元素内正常流中最后一个内联元素的基线。如果，该元素里面没有内联元素，或者本身 overflow 属性的计算值而不是 visible，这种情况下基线是 margin 底边缘。 img 是单标签，其内部没有其他内联元素，所以它的基线是 margin 底边缘。 常用解决方法：img 标签加 display: block、div 标签加 font-size: 0 或者 line-height: 0、img 标签加 vertical-align: top | middle | bottom 等。 为什么line-height推荐使用无单位数字？ line-height 的取值有：1.5、150%、1.5em 从计算上来讲，当前元素这三个line-height 的值是没有任何差别的。但子元素的 line-height 计算有差别： line-height: 1.5：子元素继承父元素 line-height 的系数，其具体值需要根据子元素的字体大小重新计算，即，子元素的 line-height = 1.5 * 子元素的 font-size 值。 line-height: 150%/1.5em：子元素继承父元素 line-height 的计算值，即，子元素的 line-height = 父元素的 line-height = 1.5 * 父元素的 font-size 值。 由此可见：无单位时，子元素的行高随子元素 font-size 值变化（推荐使用）；有单位时，子元素继承了父元素计算得出的行距，与子元素 font-size 无关。 .box_06 > div { display: inline-block; width: 30%; border: 1px solid #5aa572; vertical-align: top; font-size: 30px; } .box_06 > div span { color: #e60012; font-size: 15px; } 盈盈一点芳心，占多少春光，问卿知否？红妆莫斗。谁得似、净骨天然清瘦。神娟韵秀。 盈盈一点芳心，占多少春光，问卿知否？红妆莫斗。谁得似、净骨天然清瘦。神娟韵秀。 盈盈一点芳心，占多少春光，问卿知否？红妆莫斗。谁得似、净骨天然清瘦。神娟韵秀。 查看line-height单位DEMO 上面的三个 li 元素的 line-height 计算值都是 30px * 1.5 = 45px。而第一个 li 下的 span 的 line-height 计算值是 1.5 * 15px = 22.5px，其余两个 li 下的 span 的计算值是父元素的 line-height 计算值，即 45px。 line-height 在内联元素和块级元素作用区别 line-height 影响内联元素的高度。内联元素的行高 = 内容区域高度 + 行间距。line-height 之所以起作用，就是通过调整行距大小来实现的。 line-height 无法影响替换元素，如：img、iframe、video。 通常，line-height 对块级元素本身是没有任何作用的。但在块元素没有提定 height时，它可以改变块级元素里面内联元素占据的高度来影响块元素高度。 为何line-height可以让单行文本垂直居中？ 在CSS中，如果我们把一段文本的 line-height 设置为父容器的高度就可以实现文本垂直居中。 那么，它怎么实际垂直居中的呢？ 默认情况下一行文本的行高分为：上半行距，内容区域的高度，下半行距，并且上半行距是等于下半行距的。当line-height增大，内容区域的高度不变，上下行距增大（且保持相等），文本区域的位置往下移；当 line-height 值与 height 相等时，可以近似的看成内容区域垂直居中于父容器。 参考资料 MDN line-height MDN vertical-align 张鑫旭 css行高line-height的一些深入理解及应用 CSS深入理解之line-height css line-height 用法详解 Deep dive CSS: font metrics, line-height and vertical-align © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:18:02 "},"css探索系列/_关于css.html":{"url":"css探索系列/_关于css.html","title":" 关于Css","keywords":"","body":"关于CSS 层叠样式表 (Cascading Style Sheets，缩写为 CSS），是一种 样式表 语言，用来描述 HTML 或 XML（包括如 SVG、MathML、XHTML 之类的 XML 分支语言）文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。 CSS 是开放网络的核心语言之一，由 W3C 规范 实现跨浏览器的标准化。CSS节省了大量的工作。 样式可以通过定义保存在外部.css文件中，同时控制多个网页的布局，这意味着开发者不必经历在所有网页上编辑布局的麻烦。CSS 被分为不同等级：CSS1 现已废弃， CSS2.1 是推荐标准， CSS3 分成多个小模块且正在标准化中。 CSS 的历史 CSS1 于1994年，Håkon Wium Lie (哈肯·维姆·莱) 和 Bert Bos (伯特·波斯) 合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。 1996年12月 发表的 CSS1 的要求有第一版主要规定了选择器、样式属性、伪类 、对象几个大的部分。 CSS2 CSS2 在 1998 年 5月 由 W3C 发布，CSS2 规范是基于 CSS1 设计的，扩充和改进了很多更加强大的属性。包括选择器、位置模型、布局、表格样式、媒体类型、伪类、光标样式。 CSS 2.1 修复了 CSS 2中的错误，删除了支持不良或不能完全互操作的特性，并为规范增加了已经实现的浏览器扩展。 为了遵守 W3C 标准化技术规范的过程，CSS 2.1 在 Working Draft (WD) 状态和 Candidate Recommendation (CP) 状态之间来回了很多年。 CSS3 CSS3 是层叠样式表（Cascading Style Sheets）语言的最新版本，旨在扩展CSS2.1。 为了加快那些已经确认没有问题的特性的标准化速度，W3C 的 CSS Working Group 作出了一项被称为 Beijing doctrine 的决定，将 CSS 划分为许多小组件，称之为模块。这些模块彼此独立，按照各自的进度来进行标准化。其中一些已经是 W3C Recommendation 状态，也有一些仍是 Early Working Drafts（早期工作草案）。当新的需求被肯定后， 新的模块也会同样地添加进来。 从形式上来说，CSS3 标准自身已经不存在了。每个模块都被独立的标准化，现在标准 CSS 包括了修订后的 CSS2.1 以及完整模块对它的扩充，模块的 level（级别）数并不一致。可以在每个时间点上为 CSS 标准定义一个 snapshots（快照），列出 CSS 2.1 和成熟的模块。 有一张图可以更加直观的表示当前 CSS3 Modules 的分类和状态： 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/CSS https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"frontend/00-关于前端.html":{"url":"frontend/00-关于前端.html","title":"关于前端","keywords":"","body":"关于前端 编辑器 Visual Studio Code （推荐） Sublime Text（推荐） Notepad++ HBuilder Dreamweaver WebStorm Atom Emmet工具包 SourceTree Brackets EditPlus 优秀技术网站 https://www.kancloud.cn/zhangqh/front/937678 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-25 22:33:01 "},"frontend/00-基础-02-浏览器工作原理.html":{"url":"frontend/00-基础-02-浏览器工作原理.html","title":"基础 02 浏览器工作原理","keywords":"","body":"浏览器内核、JS 引擎及其工作原理 浏览器（Web Browser，网页浏览器）是一种用来检索、展示以及传递 Web 信息资源的应用程序。Web 信息资源由统一资源标识符（Uniform Resource Identifier，URI）所标记，它是一张网页、一张图片、一段视频或者任何在Web上所呈现的内容。使用者可以借助超级链接( Hyperlinks)，通过浏览器浏览互相关联的信息。 浏览器发展历程 世界上第一个浏览器 Tim Berners-Lee（蒂姆·伯纳斯·李） 于1990年发明了第一个网页浏览器 WorldWideWeb，后来为了避免和 World Wide Web 命名冲突而改叫 Nexus。这时浏览器的功能很简单，只支持文本、简单的样式表和有限格式的图片和声音。 Erwise 是第一个普遍可用的使用 GUI 的网页浏览器，由罗伯特·卡里奥发起开发。 第一次浏览器大战 1993年，马克·安德森 发布 Mosaic——“世界上最流行的浏览器”，进一步推动了浏览器的创新，这使得万维网更易于使用。安德森的浏览器引发了1990年代的互联网热潮。安德森是 NCSA 中 Mosaic 团队的领导者，他不久后辞职并成立了自己的公司—— Netscape，发布了受 Mosaic 影响的 Netscape Navigator。Netscape Navigator 很快便成为世界上最流行的浏览器，市占率一度达到90%。 作为应对，错失了互联网浪潮的微软匆促购入了 Spyglass 公司的技术，发布 Internet Explorer。这引发了第一轮浏览器大战。因捆绑于 Windows，Internet Explorer 于网页浏览器市场获取了主导地位，其市占率于2002年达到最高时超过95%。 第二次浏览器大战 由于微软推出的 IE 的影响， 网景公司的 Netscape 每况日下。但网景公司并没有坐以待毙，在 1998 年 成立了 Mozilla 基金会，并准备开发新的浏览器 。 2003 年，苹果公司搭配自家的 Mac OS X Panther 推出了 Safari浏览器，受限于 Mac 的用户量，Safari 并未产生多大的影响；2005 年，苹果开源了 Safari 的内核（渲染引擎）—— 大名鼎鼎的 Webkit，意义之重大，不言而喻。 2004 年，网景公司发布了全新的浏览器 Firefox，并搭配了 Gecko 内核。它功能丰富，支持用户拓展，一推出就深受大家喜爱，市场份额也稳步上升。 2008 年，Google 公司以苹果的开源项目 Webkit 作为内核，创建了一个全新的项目 Chromium 浏览器。它被谷歌拿来做 Web 技术试验场，尝试一些大胆创新的技术。同年，推出了面向用户的浏览器 —— Chrome，它会选择 Chromium 的稳定版本为基础，集成一些私有的编码解码器。或许你会疑惑，既然推出了 Chromium，为什么还要推出 Chrome？其实很简单，Chromium 是面向开发者玩的，Chrome 是选取 Chromium 的稳定版面向普通大众的，二者并不冲突。 自此，微软 IE 依靠 Windows 系统依然占据重要地位，Mozilla 火狐 和 Google Chrome 二者也拥有大量粉丝，逐步谗食 IE 的市场份额，形成三足鼎立之势。 2010 ~ 现在 2010 年，苹果宣布了 Webkit2 ，改为多进程的结构模型。 2013 年，Google 和 苹果 出现了对内核发展的分歧。于是 4 月份，Google 宣布了全新的内核项目 —— Blink。该内核早期是完全复制了 Webkit ，之后删除了与 Chromium 无关的代码，并开始大刀阔斧地对内核进行改革。 2015 年，随着 Windows 10 的发布，微软公司宣布了全新的浏览器 —— Microsoft Edge，用来取代 IE 浏览器，一代王者逐步退出舞台。 2017 年，Mozilla 宣布了为 Firefox 全新的打造的 Quantum 版本，号称新时代的最快浏览器。 目前为止，Google Chrome 以绝对的优势远远领先于其他浏览器，并且对 Web 技术 依然充满热情，以优秀的特性和性能吸引了绝大部分开发者。 浏览器的主要组件 简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。 shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。 内核才是浏览器的核心：内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。 用户界面：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎：在用户界面和呈现引擎之间传送指令。 呈现引擎：也称浏览器内核，负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络：用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 Javascript解析器：用于解析和执行 JavaScript 代码。 数据存储：这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 浏览器最重要的部分是浏览器的内核。浏览器内核是浏览器的核心，也称“渲染引擎”，用来解释网页语法并渲染到网页上。浏览器内核决定了浏览器该如何显示网页内容以及页面的格式信息。不同的浏览器内核对网页的语法解释也不同，因此网页开发者需要在不同内核的浏览器中测试网页的渲染效果。 浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。 渲染引擎 渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有 10 多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 Trident 该内核程序在 1997 年的 IE4 中首次被采用，是微软在 Mosaic 代码的基础之上修改而来的，并沿用到 IE11，也被普遍称作 IE内核。 由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核（也被称为 IE 内核）长期一家独大，微软也很长时间都并没有更新 Trident 内核。这导致了两个后果： 一是 Trident 内核曾经几乎与 W3C 标准脱节（2005年）。 二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决。 再加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox 和 Opera 就是这个时候兴起的。 注：IE 从版本 11 开始，初步支持 WebGL 技术。IE8 的 JavaScript 引擎是 Jscript，IE9 开始用 Chakra，这两个版本区别很大，Chakra 无论是速度和标准化方面都很出色。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 Gecko Netscape6 开始采用的内核，后来的 Mozilla FireFox 浏览器也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。 Gecko 内核的浏览器以 Firefox 用户最多，所以有时也会被称为 Firefox 内核。此外 Gecko 也是一个跨平台内核，可以在Windows、 BSD、Linux 和 Mac OS X 中使用。 Webkit Safari 是苹果公司开发的浏览器，使用了KDE（Linux桌面系统）的 KHTML 作为浏览器的内核，Safari 所用浏览器内核的名称是大名鼎鼎的 WebKit。 Safari 在 2003 年 1 月 7 日首度发行测试版，并成为 Mac OS X v10.3 与之后版本的默认浏览器，也成为苹果其它系列产品的指定浏览器（也已支持 Windows 平台）。 如上述可知，WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。当年苹果在比较了 Gecko 和 KHTML 后，选择了后者来做引擎开发，是因为 KHTML 拥有清晰的源码结构和极快的渲染速度。 Webkit 内核可以说是以硬件盈利为主的苹果公司给软件行业的最大贡献之一。 注：苹果在 Safari 里面使用了自己的 Nitro JavaScript 引擎（只用 WebKit 来渲染 HTML），所以一般说到 Webkit，通常指的就是渲染引擎（而不包括 Javascript 引擎）。 Chromium/Blink 2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。 chromium 是基于 webkit 引擎的，却把 WebKit 的代码梳理得可读性提高很多。因此 Chromium 引擎和其它基于 WebKit 的引擎所渲染页面的效果也是有出入的。所以有些地方会把 chromium 引擎和 webkit 区分开来单独介绍，而有的文章把 chromium 归入 webkit 引擎中，都是有一定道理的。 Blink 是一个由 Google 主导开发的开源浏览器引擎，Google 计划将这个渲染引擎作为 Chromium 计划的一部分，并且在2013年4月的时候公布了这一消息。 webkit 用的好好的，为何要投入到一个新的内核中去呢？ Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit 作为渲染引擎，但出于某种原因，并没有将其多进程架构移植入Webkit。 后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。 基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。 总的来说，Chromium 基于 Webkit 引擎，衍生出 Blink。据说 Blink 删除了 880w 行 webkit 代码。 Presto Presto 是 Opera 自主研发的渲染引擎，然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎。 在 Chrome 于 2013 年推出 Blink 引擎之后，Opera 也紧跟其脚步表示将转而使用 Blink 作为浏览器核心引擎。 Opera 的一个里程碑作品是 Opera7.0，因为它使用了 Opera Software 自主开发的 Presto 渲染引擎，取代了旧版 Opera 4 至 6 版本使用的 Elektra 排版引擎。该款引擎的特点就是渲染速度的优化达到了极致，然而代价是牺牲了网页的兼容性。 换内核的代价对于 Opera 来说过于惨痛。使用谷歌的 WebKit 内核之后，原本快速，轻量化，稳定的 Opera 浏览器变得异常的卡顿，而且表现不稳定，Opera 原本旧内核浏览器书签同步到新内核上的工作 Opera 花了整整两年时间，期间很多 Opera 的用户纷纷转投谷歌浏览器和其他浏览器，造成了众多的用户流失。 JS 引擎 JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 主流浏览器的 JavaScript 引擎： V8：用 C++ 编写，开放源代码，由 Google 丹麦开发，是 Google Chrome 的一部分，也用于 Node.js。 JavaScriptCore：开放源代码，用于 webkit 型浏览器，如：Safari。2008年实现了编译器和字节码解释器，升级为了 SquirrelFish。苹果内部代号为 Nitro 的 JavaScript 引擎也是基于 JavaScriptCore 引擎的。 Rhino：由Mozilla基金会管理，开放源代码，完全以Java编写，用于 HTMLUnit。 SpiderMonkey：第一款 JavaScript 引擎，早期用于 Netscape Navigator，现时用于Mozilla Firefox。 Chakra（JScript引擎）：用于Internet Explorer 11。 Chakra （JavaScript引擎）用于Microsoft Edge。 KJS：KDE 的 ECMAScript／JavaScript 引擎，最初由哈里·波顿开发，用于 KDE 项目的 Konqueror 网页浏览器中。 主流浏览器 国内常见的浏览器有：IE、Firefox、QQ浏览器、Safari、Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360浏览器、UC浏览器、遨游浏览器、世界之窗浏览器等。但目前最为主流浏览器有五大款： IE Firefox Google Chrome Safari Opera 各常用浏览器所使用的内核： IE：Trident 内核 Chrome：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核 Firefox：Gecko 内核 Safari：Webkit 内核 Opera：最初是自己的 Presto 内核，后来是 Chromium 内核，现在是 Blink 内核 360、猎豹浏览器：Trident + Chrome 双内核 搜狗、遨游、QQ浏览器：Trident（兼容模式）+ Webkit（高速模式） 百度、世界之窗浏览器：Trident 内核 2345：以前是IE内核，现在也是 IE + Chrome 双内核 浏览器 内核（渲染引擎） JavaScript 引擎 Chrome Blink（28~） Webkit（Chrome 27） V8 FireFox Gecko SpiderMonkey Safari Webkit JavaScriptCore Edge EdgeHTML Chakra(for JavaScript) IE Trident Chakra(for JScript) PhantomJS Webkit JavaScriptCore Node.js - V8 浏览器的工作原理 从浏览器中输入URL并回车，到显示器上看到网页，这中间都发生了什么？ 一、导航 导航是加载 web 页面的第一步。它发生在以下情形：用户通过在地址栏输入一个URL、点击一个链接、提交表单或者是其他的行为。 1.DNS 查找 导航的第一步是解析域名，找到页面资源的位置。 浏览器通过服务器名称请求 DNS 进行查找，最终返回一个IP地址，第一次初始化请求之后，这个IP地址可能会被缓存一段时间，这样可以通过从缓存里面检索IP地址而不是再通过域名服务器进行查找来加速后续的请求。其具体过程如下： 查找浏览器缓存：浏览器会缓存2-30分钟访问过网站的 DNS 信息 检查系统缓存：检查hosts文件，它保存了一些访问过网站的域名和IP的数据 检查路由器缓存：路由器有自己的DNS缓存 检查ISP DNS缓存：ISP服务商DNS缓存（本地服务器缓存） 递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索对应目标域名的IP DNS 查找对于性能来说是一个问题，特别是对于移动网络。当一个用户用的是移动网络，每一个 DNS 查找必须从手机发送到信号塔，然后到达一个认证 DNS 服务器。手机、信号塔、域名服务器之间的距离可能是一个大的时间等待。 2.TCP 握手协议 一旦获取到服务器IP地址，浏览器就会通过TCP 三次握手 与服务器建立连接。这个机制的是用来让两端尝试进行通信—浏览器和服务器在发送数据之前，通过上层协议Https可以协商网络TCP套接字连接的一些参数。 第一次握手：客户端向服务器端发送请求等待服务器确认 第二次握手：服务器收到请求并确认，回复一个指令 第三次握手：客户端收到服务器的回复指令并返回确认 3.TLS 协商 TLS 是 Transport Layer Security 的缩写，中文翻译 传输层安全性协议。 为了在HTTPS上建立安全连接，另一种握手是必须的。更确切的说是TLS协商 ，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。 虽然建立安全连接对增加了加载页面的等待时间，对于建立一个安全的连接来说，以增加等待时间为代价是值得的，因为在浏览器和web服务器之间传输的数据不可以被第三方解密。 二、响应 一旦我们建立了到 web 服务器的连接，浏览器就代表用户发送一个初始的 HTTP GET 请求，对于网站来说，这个请求通常是一个 HTML 文件。 一旦服务器收到请求，它将使用相关的响应头和HTML的内容进行回复。 三、解析 解析是浏览器将通过网络接收的数据转换为 DOM树 和 CSSOM树 的步骤，通过渲染器把 DOM树 和 CSSOM树 在屏幕上绘制成页面。 1.构建DOM树 第一步是处理 HTML 标记并构造 DOM 树。HTML解析涉及到标记化和树的构造。HTML标记包括开始和结束标记，以及属性名和值。 如果文档格式良好，则解析它会简单而快速。解析器将标记化的输入解析到文档中，构建文档树。 当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。当遇到一个CSS文件时，解析也可以继续进行，但是对于 script 标签（特别是没有 async 或者 defer 属性）会阻塞渲染并停止HTML的解析。尽管浏览器的预加载扫描器加速了这个过程，但过多的脚本仍然是一个重要的瓶颈。 2.构建CSSOM树 第二步是处理 CSS 并构建 CSSOM 树。CSS 对象模型和 DOM 是相似的。DOM 和 CSSOM是两棵树。它们是独立的数据结构。浏览器将CSS 规则转换为可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和兄弟关系的节点树。 JavaScript 编译 当 CSS 被解析并创建 CSSOM 时，其他资源，包括JavaScript文件正在下载（多亏了preload scanner）。JavaScript被解释、编译、解析和执行。脚本被解析为抽象语法树。一些浏览器引擎使用 Abstract Syntax Tree 并将其传递到解释器中，输出在主线程上执行的字节码。这就是所谓的 JavaScript 编译。 构建辅助功能树 浏览器还构建辅助设备用于分析和解释内容的辅助功能树。可访问性对象模型（AOM）类似于DOM的语义版本。当DOM更新时，浏览器会更新辅助功能树。辅助技术本身无法修改可访问性树。 四、渲染 渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。在解析步骤中创建的 CSSOM 树和 DOM 树组合成一个 Render 树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。在某些情况下，可以将内容提升到它们自己的层并进行合成，通过在 GPU 而不是CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。 1.样式计算 第三步是将 DOM 树和 CSSOM 树组合成一个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点。 2.布局计算 第四步是在渲染树上运行布局以计算每个节点的几何体。布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。 第一次确定节点的大小和位置称为布局。随后对节点大小和位置的重新计算称为回流。 3.绘制 最后一步是将各个节点绘制到屏幕上，第一次出现的节点称为首次有效绘制（first meaningful paint）。在绘制阶段，浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素。绘画包括将元素的每个可视部分绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素。 合成 绘制可以将布局树中的元素分解为多个层（类似层级上下文）。当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。 层确实可以提高性能，但是它以内存管理为代价，因此不应作为 web 性能优化策略的一部分过度使用。 解析 html 生成 DOM 树，解析 css，生成 CSSOM 树，将 DOM 树和 CSSOM 树结合，生成渲染树； 根据渲染树，浏览器可以计算出网页中有哪些节点，各节点的CSS以及从属关系 - 回流； 根据渲染树以及回流得到的节点信息，计算出每个节点在屏幕中的位置 - 重绘； 最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面。 五、交互 主线程绘制页面完成后，页面不一定是可用的。比如：有 JS 文件可能是2 MB，而且用户的网络连接很慢。在这种情况下，用户可以非常快地看到页面，但是在下载、解析和执行脚本之前，就无法滚动。 重流和重绘 渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。 页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（a:hover）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。 重流 当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为重流（回流）。 会导致回流的操作： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 一些常用且会导致回流的属性和方法： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 一些会导致回流的CSS属性： width, height, padding, border, margin, position, top, left, bottom, right, float, clear, text-align, vertical-align, line-height, font-weight, font-size, font-family, overflow, white-space 重绘 (Repaint) 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 容易造成重绘操作的css： color, border-style, border-radius, text-decoration, box-shadow, outline, background 如何进行优化，减少重绘和重流 浏览器自己的优化 每次回流都会对浏览器造成额外的计算消耗，所以浏览器对于回流和重绘有一定的优化机制。浏览器通常都会将多次回流操作放入一个队列中，等过了一段时间或操作达到了一定的临界值，然后才会挨个执行，这样能节省一些计算消耗。但是在获取布局信息操作的时候，会强制将队列清空，也就是强制回流，比如访问或操作以下或方法时： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft scrollIntoView()、scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientRect() scrollTo() 这些属性或方法都需要得到最新的布局信息，所以浏览器必须去回流执行。因此，在项目中，尽量避免使用上述属性或方法，如果非要使用的时候，也尽量将值缓存起来，而不是一直获取。 减少重流与重绘 CSS： 避免使用table|flex布局。可能很小的一个小改动会造成整个 table|flex 的重新布局。 使用 visibility 替换 display: none 。因为前者只会引起重绘，后者会引发回流（改变了布局） 尽可能在DOM树的最末端改变class。回流是不可避免的，但可以减少其影响，可以限制回流的范围，使其影响尽可能少的节点。 避免设置多层内联样式； 将动画效果应用到 position 属性为 absolute|fixed 的元素上。 避免使用CSS表达式。 使用 transform 替代 top。 将频繁重绘或者回流的节点设置为图层。图层能够阻止该节点的渲染行为影响别的节点。如： will-change、video、iframe等标签，浏览器会自动将该节点变为图层。 css3硬件加速（GPU加速）。 使用css3硬件加速，可以让 transform、opacity、filters、will-change 这些动画不会引起回流重绘 。但对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。 JavaScript： 避免频繁操作样式。最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM。创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性。如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。 浏览器加载JavaScript脚本 正常加载流程 浏览器加载 JavaScript 脚本，其正常流程如下： 浏览器的渲染引擎持有渲染的控制权，它正常解析HTML页面 解析遇到 script标签，渲染引擎移交控制权给 Javascript 引擎 如果 script 标签引用了外部脚本那就先下载再执行，否则直接执行代码 JavaScript 引擎执行完毕移交控制权给渲染引擎，渲染引擎继续解析 defer属性 浏览器解析到包含 defer 属性的 script 元素时，其运行流程如下： 浏览器的呈现引擎持有渲染的控制权，它正常解析HTML页面 解析遇到包含 defer 属性的 script 标签，继续解析 HTML，同时并行下载外链脚本 解析完成，文档处于交互状态时开始解析处于 deferred 模式的脚本 脚本解析完毕后，将文档状态设置为完成，DOMContentLoaded 事件随之触发 使用 defer 属性时需要注意的点： defer 属性下载的脚本文件在 DOMContentLoaded 事件触发前执行，即，刚刚读取完标签 defer 属性可以保证执行顺序就是它们在页面上出现的顺序 对于内置而不是加载外部脚本的 script 标签，以及动态生成的 script 标签，defer 属性不起作用 使用 defer 加载的外部脚本不应该使用 document.write 方法 async属性 浏览器解析到包含 async 属性的 script 元素时，其运行流程如下： 浏览器的呈现引擎持有渲染的控制权，它正常解析 HTML 页面 解析遇到包含async属性的 script 标签，继续解析 HTML，让另一进程同时并行下载外链脚本 脚本下载完成，浏览器暂停解析 HTML，开始执行下载的脚本 脚本执行完毕，浏览器恢复解析 HTML 使用 async 属性时需要注意的点： async 属性可以保证脚本下载的同时，浏览器继续渲染 async 属性无法保证脚本的执行顺序，哪个先下载结束就先执行哪一个 包含 async 属性的脚本不应该使用 document.write 方法 如果同时使用 async 和 defer 属性，后者不起作用，浏览器行为由 async 属性决定 脚本的动态加载 JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么 它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解 析文档。 script 元素还可以动态生成，生成后再插入页面，从而实现脚本的动态加载。动态生成的script标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。如果想避免这个问题，可以设置 async 属性为 false。还可以监听脚本的 onload 事件来为脚本指定回调。 CSS 阻塞 JS 加载 因为 JS 脚本可能会引用 DOM 的样式做计算，所以为了保证脚本计算的正确性，Firefox 浏览器会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit 则是一旦发现脚本引用了样式，就会暂停执行脚本，等到样式表下载并解析完，再恢复执行。 此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。 预加载扫描器 当主线程在解析 HTML 和 CSS 时，预加载扫描器将找到脚本和图像，并开始下载它们。为了确保脚本不会阻塞进程，当 JavaScript 解析和执行顺序不重要时，可以添加async属性或defer属性。 请注意，预加载扫描器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。 浏览器引擎前缀 浏览器厂商们有时会给实验性的或者非标准的 CSS 属性和 JavaScript API 添加前缀，这样开发者就可以用这些新的特性进行试验，同时（理论上）防止他们的试验代码被依赖，从而在标准化过程中破坏 web 开发者的代码。开发者应该等到浏览器行为标准化之后再使用未加前缀的属性。 CSS 前缀 主流浏览器引擎前缀: -webkit-：Chrome、Safari、新版Opera浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器 -moz-：firefox 浏览器 -o-：旧版 Opera 浏览器 -ms-：IE、Edge 浏览器 -webkit-transition: all 4s ease; -moz-transition: all 4s ease; -ms-transition: all 4s ease; -o-transition: all 4s ease; transition: all 4s ease; API 前缀 过去，浏览器引擎也使用前缀修饰实验性质的 API。如果整个接口都是实验性的，前缀修饰的就是接口名（但不包括其中的属性或者方法）。如果将一个实验性的接口或者方法添加到一个标准化的接口中，这个新增的接口或者方法被前缀修饰。 接口前缀，需要使用大写的前缀修饰接口名： Webkit：Chrome、Safari、新版Opera浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器 Moz：firefox 浏览器 O：旧版 Opera 浏览器 Ms：IE、Edge 浏览器 属性和方法前缀，需要使用小写的前缀修饰属性或者方法： webkit：Chrome、Safari、新版Opera浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器 moz：firefox 浏览器 o：旧版 Opera 浏览器 ms：IE、Edge 浏览器 var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame; 相关问题 1. 渲染页面时常见哪些不良现象？ FOUC：无样式内容闪烁（Flash Of Unstyled Content），主要指的是样式闪烁的问题，由于浏览器渲染机制（比如：firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。 白屏：有些浏览器渲染机制（比如：chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。 参考链接 小文：浅谈浏览器发展简史 五大主流浏览器及四大内核 MDN 浏览器引擎前缀 MDN 渲染页面：浏览器的工作原理 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:09:43 "},"frontend/00-进阶-04-如何保证高质量代码.html":{"url":"frontend/00-进阶-04-如何保证高质量代码.html","title":"进阶 04 如何保证高质量代码","keywords":"","body":"如何保证高质量代码 通常项目中我们通过 eslint 和 stylelint 这些 lint 工具来检查代码的规范与否，保证良好的代码规范，从而在多人协作中保障项目质量和可维护性。正常我们会在提交代码前手动执行语法检查，而 lint-staged 和 husky 让这一过程自动化，在 git 的 pre-commit 阶段来检测你的代码，如果存在语法错误会中断 commit。 ESlint ESLint 属于一种QA工具，是一个 ECMAScript/JavaScript 语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 ESLint 旨在完全可配置，它的目标是提供一个插件化的 Javascript 代码检测工具。这意味着您可以关闭每个规则，只能使用基本语法验证，或者混合并匹配捆绑的规则和自定义规则，使ESLint完美的适用于您的项目。 安装：npm i eslint eslint-config-prettier eslint-plugin-prettier eslint-plugin-vue -D 配置：eslint --init // 运行后，会在当前目录下生成一个.eslintrc文件 有两种主要的方法来配置ESLint： 配置注释：使用 JavaScript 注释将配置信息直接嵌入到文件中。格式如下： 用注释指定全局变量： /* global var1, var2 */ 指定变量不应被重写（只读），你可以将它们设置为 false： /* global var1:false, var2:false */ 使用行注释禁用规则： /* eslint-disable no-alert, no-console */ alert('foo'); console.log('bar'); /* eslint-enable no-alert, no-console */ ESLint配置文件：使用下面任一的文件来为全部的目录和它的子目录指定配置信息 JavaScript： .eslintrc.js YAML： .eslintrc.yaml 或 .eslintrc.yml JSON： .eslintrc.json ，ESLint 的 JSON 文件允许 JavaScript 风格的注释。 (不推荐) 使用 .eslintrc，可以是 JSON ，也可以是 YAML。 package.json： package.json 中新增 eslintConfig属性，在那里定义配置数据。 如果同一个目录下有多个配置文件，ESLint 只会使用一个。优先级顺序如下： .eslintrc.js .eslintrc.yaml .eslintrc.yml .eslintrc.json .eslintrc（已弃用） package.json 默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 package.json 文件或者 .eslintrc.* 文件里设置 \"root\": true。ESLint 一旦发现配置文件中有 \"root\": true，它就会停止在父级目录中寻找。 .eslintrc.js文件示例：ESlint 中文官方网站 module.exports = { root: true, parser: \"vue-eslint-parser\", parserOptions: { parser: 'babel-eslint' }, env: { browser: true, }, globals: {}, // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style extends: ['plugin:vue/recommended', 'eslint:recommended'], rules: { \"no-unused-vars\": 0, \"no-console\": 0, 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'indent': [2, 2], //文件缩进 \"eqeqeq\": 0, //严格比较 === 和 !== \"no-useless-escape\": 0, //无效转义符 \"quotes\": [1, 'single'], //单引号 \"semi\": [\"error\", \"never\"], //名末分号 \"no-new\": 0, //new 未赋值给一个变量 \"no-multiple-empty-lines\": [1, { \"max\": 2, \"maxEOF\": 1 }], //最多空行、文件结尾最多空行 \"no-undef\": 0, \"no-empty\": 0, \"no-case-declarations\": 0, \"vue/max-attributes-per-line\": [2, { //单行最多两个属性 \"singleline\": 2, \"multiline\": { \"max\": 1, \"allowFirstLine\": false } }], \"vue/require-v-for-key\": 0, \"vue/no-use-v-if-with-v-for\": 0, \"vue/require-default-prop\": 0, \"vue/no-unused-vars\": 0, \"vue/require-prop-types\": 0, \"vue/no-unused-components\": 0, \"vue/valid-v-on\": 0, \"vue/no-v-html\": 0, \"vue/require-component-is\": 0, \"vue/valid-v-for\": 0, \"vue/no-parsing-error\": 0, \"vue/no-async-in-computed-properties\": 0, \"vue/no-side-effects-in-computed-properties\": 0, \"vue/valid-v-bind\": 0 } } Eslint使用： 命令行：eslint --fix '{src,packages}/**/*.{js,vue,ts}' webpack.config.js： { module: { rules: [ { test: /\\.(js|vue)$/, loader: 'eslint-loader', enforce: \"pre\", include: [resolve('src'), resolve('packages')], options: { formatter: require('eslint-friendly-formatter'), fix: true } } ] } } 忽略文件：新增eslintignore文件，加上需要忽略的路径： docs/** Stylelint 一个强大的css校验插件，可以帮助你避免错误和强制约定一些代码风格 安装：npm i stylelint stylelint-config-standard stylelint-selector-bem-pattern -D 配置：代码检查工具需要一个配置对象。您可以制作自己的配置或继承现有配置。 查找和加载配置对象从当前工作目录开始，它将按以下顺序查找以下可能的源： package.json 中的 stylelint 属性 .stylelintrc 文件 stylelint.config.js 文件 .stylelintrc 文件（没有扩展名）可以是 JSON 或 YAML 格式。或者您可以添加文件扩展名以指定格式：.stylelintrc.json、 .stylelintrc.yaml、 .stylelintrc.yml、 .stylelintrc.js。 找到并解析其中一个后，搜索将停止并将使用该对象。可以使用 config 或 configFile 选项绕过配置搜索。 stylelint.config.js文件示例：stylelint配置 { \"extends\": \"stylelint-config-standard\", \"plugins\": [ \"stylelint-selector-bem-pattern\" ], \"rules\": { \"block-no-empty\": null, \"color-no-invalid-hex\": true, \"comment-empty-line-before\": [ \"always\", { \"ignore\": [\"stylelint-commands\", \"after-comment\"] } ], \"declaration-colon-space-after\": \"always\", \"indentation\": [\"tab\", { \"except\": [\"value\"] }], \"max-empty-lines\": 2, \"rule-empty-line-before\": [ \"always\", { \"except\": [\"first-nested\"], \"ignore\": [\"after-comment\"] } ], \"unit-whitelist\": [\"em\", \"rem\", \"%\", \"s\"], \"plugin/selector-bem-pattern\": { componentSelectors: function (componentName) { var word = '[a-z0-9]+'; var namespace = `bx-tool`; var block = `(?:-${word})+`; var elementOrModifier = `(?:-|--${word})*`; return new RegExp(`^\\\\.${namespace}${block}${elementOrModifier}`); }, implicitComponents: \"packages/**/*.css\", ignoreSelectors: [ '\\.img-responsive', '\\.animate-.+$', '\\.transition-.+$', ] } } } stylelint-selector-bem-pattern，是stylelint的扩展插件，为css选择器指定正则匹配。 Eslint使用： 命令行：stylelint --cache **/*.{html,vue,css,sass,scss} --fix 各种编辑器：Sublime Text、Atom、Visual Studio Code等 各种构建工具：Gulp、Webpack等 通过 Node.js 的api 作为 postcss 的插件 Husky 现在最流行的版本管理工具非git莫属，而良好的代码规范有助于项目的维护，为了防止一些不规范的代码 commit并push到远端,我们可以在git命令执行前用一些钩子来检测并阻止。现在大前端主要有两种git钩子插件：husky（jquery与next.js都在用），pre-commit(antd在用) 。husky能够防止不规范代码被commit、push、merge等等。 安装：npm i husky -D //package.json { \"scripts\": { \"precommit\": \"lint-staged\" } } Lint-staged lint-staged可以在git staged阶段的文件上执行linters，简单点来说就是当我们运行eslint或stylelint的命令时，只会检查我们通过git add添加到暂存区的文件，可以避免我们每次检查都把整个项目的代码都检查一遍。 安装：npm i lint-staged -D //package.json { \"scripts\": { \"precommit\": \"lint-staged\" }, \"lint-staged\": { \"{src,packages}/**/*.{js,vue}\": [ \"eslint --fix\", \"prettier --write\", \"git add\" ], \"{src,packages}/**/*.{css,vue}\": [ \"stylelint --fix\", \"git add\" ] } } Prettier Prettier工具主要用来统一代码格式的，eslint 也会对代码进行一定程度的格式校验，但主要是用来对代码规范的扫描，而 prettier 则是专门用来对代码进行格式化，两个工具各司其职，为代码质量进行保驾护航。它的主要原理是将格式化前的代码和格式化后的代码进行比对，如果发现不一样，prettier就会对其进行标记并按照指定的格式化规范进行修复。 安装：npm i prettier eslint-plugin-prettier eslint-config-prettier -D 配置： .prettierrc 文件 prettier.config.js文件 package.json 中配置prettier属性 //prettier.config.js module.exports = { printWidth: 80, semi: true, singleQuote: true, trailingComma: 'none', bracketSpacing: true, jsxBracketSameLine: false, arrowParens: 'avoid', requirePragma: false, proseWrap: 'preserve' } 为了和eslint配合使用需要引入两个插件eslint-plugin-prettier和eslint-config-prettier，其中需要说明的是 eslint-config-prettier 插件的作用，这个插件是如果 eslint的规则和 prettier的规则发生冲突的时候（主要是不必要的冲突），例如eslint限制了必须单引号，prettier也限制了必须单引号，那么如果用 eslint驱动 prettier来做代码检查的话，就会提示2种报错，虽然他们都指向同一种代码错误，这个时候就会由这个插件来关闭掉额外的报错。 钩子工作流程 当开发者执行 git add 操作将代码提交到暂存区后，再执行 git commit 操作： 由于安装husky后，其在.git/hooks中写入了pre-commit钩子，该钩子在 git commit 执行时被触发，执行npm run precommit脚本（即lint-staged命令）； lint-staged的配置，就是利用linters对暂存区的文件路径应用过滤规则，匹配的文件将执行后面配置的任务，这里的任务就是调用项目中的eslint指令检查文件，如果报错则先自动修复--fix，最后把没有问题的代码加入暂存区git add。 如果最终还有报错，则流程终止，无法执行 commit 操作。 参考链接 eslint+husky+prettier+lint-staged提升前端应用质量 使用husky、lint-staged、prettier、eslint保持团队代码一致 深入浅出eslint——关于我学习eslint的心得 自定义规则 高级前端基础-JavaScript抽象语法树AST © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-25 22:40:21 "},"frontend/01-聊一聊Cookie的一些问题.html":{"url":"frontend/01-聊一聊Cookie的一些问题.html","title":"聊一聊Cookie的一些问题","keywords":"","body":"聊一聊Cookie的一些问题 Cookie是什么？ Cookie，是站点为了访客的一些信息来区分用户(Identifier)或者传递信息。在Session出现之前，基本上所有的网站都采用Cookie来区分用户身份。 Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。 Cookie机制采用的是在客户端保持Http状态的方案，是一种唯一标识一个用户，同时记录该用户的状态的机制。 注意：Cookie功能需要浏览器的支持。如果浏览器不支持Cookie或者把Cookie禁用了，Cookie功能就会失效。启用或禁用浏览器cookie，如：Chrome -> 在右上角“更多”图标 -> 设置 -> 隐私设置和安全性 -> 网站设置 -> Cookie 和网站数据 注意： Cookie 可以同站共享，即，一级域名相同的页面，可以共享cookie。 Cookie存在哪里？ 坦白的说，一个cookie就是存储在用户主机浏览器中的一小段文本文件。Cookies是纯文本形式，它们不包含任何可执行代码。一个Web页面或服务器告之浏览器来将这些信息存储并且基于一系列规则在之后的每个请求中都将该信息返回至服务器。Web服务器之后可以利用这些信息来标识用户。Cookie只是包含了数据，就其本身而言并不有害。 Cookies文件：Chrome的Cookie数据位于：%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\ Cookies。如：C:\\Users\\[whoami]\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Cookies。 在用户[whoami]文件夹中，AppData通常是隐藏的。window10下，点开查看 -> 勾中【隐藏的项目】。 chrome开发者工具中查看：F12 -> Application -> Cookies -> [website] chrome设置中查看：Chrome -> 在右上角“更多”图标 -> 设置 -> 隐私设置和安全性 -> 网站设置 -> Cookie 和网站数据 -> 所有 Cookie 和网站数据 Cookie的工作原理是什么？ Cookie使用HTTPHeader传递数据。Cookie机制定义了两种报头：Set-Cookie报头和Cookie报头。Set-Cookie报头包含于Web服务器的响应头（ResponseHeader）中，Cookie报头包含在浏览器客户端请求头（ReguestHeader）中。 Cookie的运行过程具体分析如下： 客户端在浏览器的地址栏中键入Web服务器的URL，浏览器发送读取网页的请求。 服务器接收到请求后，产生一个Set-Cookie报头，放在HTTP报文中一起回传客户端，发起一次会话。 客户端收到应答后，若要继续该次会话，则将Set-Cook-ie中的内容取出，形成一个Cookies文件储存在客户端计算机里。 当客户端再次向服务器发出请求时，浏览器先在电脑里寻找对应该网站的Cookies文件。如果找到，则根据此Cookies产生Cookie报头，放在HTTP请求报文中发给服务器。这些是浏览器自动做的，而且每一次http请求浏览器都会自动做。 服务器接收到包含Cookie报头的请求，检索其Cookie中与用户有关的信息，生成一个客户端所请示的页面应答传递给客户端。 浏览器的每一次网页请求，都可以传递已存在的Cookie文件。 Cookie有哪些属性？ 通常服务器只想知道[name]=[value]值，其余的字段有的为了存储，有的为了安全性。 Cookie属性名称不区分大小写。如：DOMAIN和domain，secure和SECURE。 Cookie名称本是区分大小写的。只不过由于 ASP 进行了封装，使得 cookie 名称不区分大小写。 ASP 中 ：response.cookies(\"aa\")与 response.cookies(\"AA\")是指的同一个 cookie。 JavaScript中：document.cookie = \"aa=1\"和document.cookie = \"AA=2\"是两个 cookie。 # 前端可设置的属性。其中Secure需在https协议下 [name]=[value];expires=[new Date()];domain=[domain];path=[path];Secure; # 全部属性。服务器可以全部设置 [name]=[value];expires=[new Date()];domain=[domain];path=[path];Secure;HttpOnly,size=[size];SameSite=[Strict | Lax | none];Priority=[Medium] name：一个唯一确定cookie的名称。Cookie名称是一个字符串，不分大小写。规则与JavaScript变量名称不同，但是常识适用：使用字母数字和下划线、避免使用“ $”，没有保留字或变量名限制。要真正理解命名规则，请阅读HTTP 1.1标准。 value：存储在cookie中的字符串值 cookie其实是个字符串，这个字符串中逗号、分号、空格被当做了特殊符号。所以当cookie的 key 和 value 中含有这3个特殊字符时，需要对其进行额外编码。可用escape | encodeURI | encodeURIComponent 进行编码，用unescape | decodeUR | decodeURIComponent进行解码。 通常的观点是cookie的值必须被URL编码，但是这其实是一个谬误。原始的文档中指示仅有三种类型的字符必须进行编码：分号，逗号，和空格。 生命周期 expires(未来某个时刻过期) expires其实是cookie失效日期，默认有效期为session（即，会话cookie，浏览器关闭后失效）。 expires必须是 GMT 格式的时间（可以通过new Date().toGMTString()或者new Date().toUTCString() 来获得）。JavaScript Date的使用和日期时间字符串格式 # 以下为表示一天后失效的日期 # 正确写法。注：时区原因，以下四种写法表示的过期时间有差异 `expires=${new Date(new Date().getTime() + 24 * 60 * 60 * 1000)};` `expires=${new Date(new Date().getTime() + 24 * 60 * 60 * 1000).toGMTString()};` # toGMTString：Sun, 02 Aug 2020 16:16:27 GMT `expires=${new Date(new Date().getTime() + 24 * 60 * 60 * 1000).toUTCString()};` # toUTCString：Sun, 02 Aug 2020 16:18:05 GMT `expires=${new Date(new Date().getTime() + 24 * 60 * 60 * 1000).toString()};` # toString：Mon Aug 03 2020 00:18:22 GMT+0800 (中国标准时间) # 错误写法。值无效，相当没有设置expires `aaa=1234;domain;path;expires=${new Date(new Date().getTime() + 24 * 60 * 60 * 1000).toISOString()};` # toISOString：2020-08-02T16:19:05.896Z `aaa=1234;domain;path;expires=${new Date(new Date().getTime() + 24 * 60 * 60 * 1000).toLocaleString()};` # toLocaleString：2020/8/3 上午12:19:20 max-age(经过一定秒数过期) max-age指定当前cookie是在多长时间之后而失效，默认值是 -1（即，会话cookie，浏览器关闭后失效）。 //以下为表示一天后失效的日期。单位为：秒(s) `max-age=${24 * 60 * 60};` 有三种可能值： 负数：有效期session 0：删除cookie 正数：以秒为单位，有效期为创建时刻 + max-age expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替，两者的作用都是限制cookie 的有效时间。expires的值是一个时间点（cookie失效时刻= expires），而max-age 的值是一个以秒为单位时间段（cookie失效时刻= 创建时刻 + max-age）。 domain：决定允许访问Cookie的域名。默认值为设置该cookie的网页所在的域名。 Cookie是不可跨域名的。域名www.google.com颁发的Cookie不会被提交到域名www.baidu.com去。这是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。 name相同但domain不同的两个Cookie是两个不同的Cookie。如果想要两个域名完全不同的网站共有Cookie，可以生成两个Cookie，domain属性分别为两个域名，输出到客户端。 domain不能是公共后缀，即不能设置为.com或com。 如果想所有www.baidu.com域名下的域名都可以使用该Cookie，需要设置Cookie的domain参数。需设置： `domain=.baidu.com;` 注意： domain参数必须以点(‘.’)开始? 早期的标准RFC 2109：domain必须以\".\"开始。不以\".\"开始，cookie对子域无效。然而，RFC 6265标准中，是不需要以'.'开始，如果存在‘.’，也会自动忽略。为兼容一些使用RFC 2109标准的旧浏览器，建议domain参数都以'.'开始。 path：决定允许访问Cookie的路径（ContextPath）。默认值为设置该cookie的网页所在的目录。 在默认情况下，与创建cookie的网页在同一目录或子目录下的所有网页都可以读取该cookie。指定域中的路径，应该向服务器发送path值。 name相同但path不同的两个Cookie也是两个不同的Cookie。 `path=/aaa;`//只允许/aaa下的程序使用Cookie `path=/;` //允许所有路径使用Cookie 注意： 不要包含结尾的'/'？： RFC 6265标准：path为空或者第一个字符为非\"/\"字符，默认为\"/\"。此外，cookie路径匹配，从path第一个字符开始到最右边的\"/\"，但不包括它。所以“尾部\"/\"是不需要的。 cookie的顺序： RFC推荐在request header中浏览器能够按path的长短排序，越长说明匹配的越精确，顺序越靠前。并不是所有的浏览器都遵守这个，并且服务器也不应该依赖于cookie出现的顺序。 domain是域名，path是路径，两者加起来就构成了 URL，domain和path一起来限制 cookie 能被哪些 URL 访问。 如：cookie的 domain为aaa.com, path为/。若请求的URL（js/html/img/css资源请求，但不包括 XHR 请求）的域名是aaa.com、api.aaa.com、ev.api.aaa.com，且 URL 的路径是/、/home、/home/login，则浏览器会将此 cookie 添加到该请求的 cookie 头部中。 secure：设置cookie只在确保安全协议的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。 默认情况下，cookie不会带secure选项(即为空)。所以默认情况下，不管是HTTPS协议还是HTTP协议的请求，cookie 都会被发送至服务端。 客户端通过 javascript去设置secure类型的 cookie，必须保证网页是https协议的。在http协议的网页中是无法设置secure类型cookie的。查看相关 `Secure;` //不区分大小写 注意：secure选项只是限定了在安全情况下才可以传输给服务端，但chrome中还是可以看到这个 cookie的。 httponly：设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过javascript代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过javascript代码去访问（包括读取、修改、删除等），只能通过服务端来设置。查看相关 `httpOnly;` //不区分大小写 size：未找到相关说明。似乎是浏览器根据value自动设置的。?? SameSite：让 Cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF），从而减少安全风险。Cookie 的 SameSite 属性。 跨站和跨域是不同的： 跨域是浏览器同源策略中的概念。其同源是指两个 URL 的协议/主机名/端口一致，判断比较严格。 Cookie中的「同站」：只要两个 URL 的 顶级域名（也称一级域名）+ 二级域名，比如aaa.com 相同即可，不需要考虑协议和端口，判断比较宽松。 sameSite有三个值： Strict：最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。 Lax：规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。 None：Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。 2020年2月份发布的 Chrome 80 版本中默认屏蔽了第三方的 Cookie，即，之前默认是 None 的，Chrome80 后默认是 Lax。 其影响详见下表： | 请求类型 | 示例 | Strict | Lax | None | | :-------- | :----------------------------------: | -------- | ---------- | ---------- | | 链接 | | 不发送 | 发送 Cookie | 发送 Cookie | | 预加载 | | 不发送 | 发送 Cookie | 发送 Cookie | | GET 表单 | | 不发送 | 发送 Cookie | 发送 Cookie | | POST 表单 | | 不发送 | 不发送 | 发送 Cookie | | iframe | | 不发送 | 不发送 | 发送 Cookie | | AJAX | $.get(\"...\") | 不发送 | 不发送 | 发送 Cookie | | Image | | 不发送 | 不发送 | 发送 Cookie | 有两点要注意的地方： HTTP 接口不支持SameSite=none。因为，加SameSite=none 属性，必须加上 Secure属性，而 Secure属性表示只有在 HTTPS协议下该 Cookie才会被发送。 如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。 需要 UA 检测，部分浏览器不能加 SameSite=none IOS 12 的 Safari 以及老版本的一些 Chrome 会把SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行User-Agent 检测，对这些浏览器不下发SameSite=none 属性。 priority：未找到相关说明。?? Cookie管理机制 有时效cookie（也称持久化cookie）：expires带有有效时间或者max-age为正数。在下次访问之前，如果失效时间到期，会自动清除对应cookie。 会话cookie：expires时间是session或者比当前时间还要早的时间或者未设或者max-age为负数。在会话结束时（浏览器关闭）会被删除。 如果浏览器中的cookie限制到达，那么cookies会被删除以为新建cookies创建空间。 对于任何这些自动删除来说，Cookie管理显得十分重要，因为这些删除都是无意识的。 如何操作cookie？ 除了服务器发送给客户端（浏览器）的时候，通过Set-Cookie，创建或更新对应的cookie之外，还可以通过浏览器内置的一些脚本，比如 javascript，去设置对应的cookie，对应实现是操作javascript中的document.cookie。 浏览器可以通过设置来接受和拒绝访问 cookie。出于功能和性能的原因考虑，建议尽量降低 cookie 的使用数量，并且要尽量使用小 cookie。 前端对cookie进行操作 设置 cookie：客户端可以设置cookie 的下列选项：expires、domain、path、secure（只在https协议的网页中），但无法设置HttpOnly选项。 一次只能设置一个cookie。当设置多个cookie时document.cookie = \"aaa=1234; bbb=1234; ccc=1234\";，只会添加第一个cookie aaa=1234，后面的所有cookie都没有添加成功。所以最简单的设置多个cookie的方法就在重复执行document.cookie = \"[name]=[value]\"。 document.cookie = `aaa=1234;domain=;path=/;expires=${new Date(new Date().getTime() + 24 * 60 * 60 * 1000)};Secure;SameSite=none;Priority=Medium` 查看cookie：document.cookie 修改 cookie：要想修改一个cookie，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新cookie时，name/domain/path 这3个字段都相同的时候，cookie才会被覆盖。否则不会修改旧值，而是添加了一个新的 cookie。 document.cookie = `aaa=5678;domain=;path=/;expires=${new Date(new Date().getTime() + 24 * 60 * 60 * 1000)};Secure;SameSite=none;Priority=Medium` 删除 cookie： 通过浏览器工具清除 cookie (有第三方的工具，浏览器自身也有这种功能) 。 通过设置 cookie 的有效期来清除 cookie。对cookie重新赋值，将新cookie的expires 设置为一个过去的时间点或者max-age设置为0。但同样要注意，name/domain/path 这3个字段都相同的时候，cookie才会被覆盖。 后端服务器对cookie进行操作 从服务器端，发送cookie给客户端，是对应的Set-Cookie。包括了对应的cookie的名称，值，以及各个属性。而从客户端发送cookie给服务器的时候，是不发送cookie的各个属性的，而只是发送对应的名称和值。 设置 cookie：一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。服务端可以设置cookie 的所有选项：expires、domain、path、secure、HttpOnly protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Cookie cookie = new Cookie(\"name\", \"value\"); cookie.setComment(\"Web Host Name\"); // Cookie描述 cookie.setMaxAge(24 * 60 * 60); // Cookie有效时间 cookie.setPath(\"/\"); // Cookie有效路径 ... response.addCookie(cookie); } 读取Cookie protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Cookie[] cookies = request.getCookies(); // 处理输出中文乱码问题 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); for (Cookie cookie:cookies) { out.println(\"Cookie名 称：\"+cookie.getName()+\"\"); out.println(\"Cookie储 值：\"+cookie.getValue()+\"\"); out.println(\"Cookie备 注：\"+cookie.getComment()+\"\"); out.println(\"Cookie有效时间：\"+cookie.getMaxAge()+\"\"); out.println(\"Cookie有效路径：\"+cookie.getPath()+\"\"); out.println(\"Cookie有效域名：\"+cookie.getDomain()+\"\"); out.println(\"删除Cookie\"); out.println(\"--------------------------------------\"); } } 删除Cookie protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Cookie[] cookies = request.getCookies(); for (Cookie cookie: cookies) { cookie.setMaxAge(0); response.addCookie(cookie); } //或者 response.clearCookie('default_font') } Cookie怎么提高安全性？ cookie是容易修改和获取，即容易被利用。那么自然而然会想到安全性问题。以下四种方式，在后端服务器对cookie进行适当的处理，可以提高cookie的安全性： 设置cookie的httpOnly属性，指明该cookie只用来HTTP请求使用。这个时候前端或者浏览器是拿不到这个cookie的，也就是使用document.cookie是不会出现的。 设置cookie的secure属性，使得cookie只在安全协议(如：https)下传输。如果把https改成http，cookie无法跟随请求一起发送到server端，在发送cookie之前就已启用了加密传输协议https。 设置cookie的expires不要太长。如果必要，将其设置成跟随session的结束而结束。 expires：默认可以不指定expires时间，或者设置一个比当前时间要早的时间。 max-age：设置为0。 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。 通过加密（如：MD5加密）和安全传输技术（SSL），减少cookie被破解的可能性。 Cookie有什么优点缺点？ 优点： 不需要额外设置，浏览器发送请求时，自动带上cookie。 不需要服务器资源，直接存储在本地。 缺点： cookie会被附加在每个HTTP请求中，无形中增加了流量。 安全问题：在HTTP请求中的cookie是明文传递的、cookie可以被改写。 清理机制：IE和Opera会删除最近最少使用过的cookie，但是Firefox是随机决定要清除哪个cookie。(目前有些浏览器可以关闭自动清理) 所有超出该限制的cookies都会被截掉并且不会发送至服务器。 cookie大小的限制：大多数浏览器4096B的长度限制，为了兼容多种浏览器，最好将长度限制在4095B以内。 每个域的cookie总数是有限的，不同浏览器之间各有不同。 IE6以及更低版本限制每个域名最多20个cookie。 IE7之后的版本每个域名最多50个。 Firefox限制每个与最多50个cookie。 Safari和Chrome对于每个域的cookie数量限制没有硬性规定。 常见问题 Cookie发送不成功 原因一：浏览器禁用了cookie。 Chrome -> 在右上角“更多”图标 -> 设置 -> 隐私设置和安全性 -> 网站设置 -> Cookie 和网站数据 ie -> 工具 -> internet选项 -> 隐私 -> 高级 原因二: 跨域问题 。参考以下解决方法： 方法一： 前端对于跨域的 XMLHttpRequest请求，需要设置withCredentials属性为 true。 服务端的响应中header必须携带Access-Control-Allow-Credentials: true，否浏览器将不会把响应的内容返回给发送者。 服务端的响应中header必须携带Access-Control-Allow-Origin，指定允许跨域的域名。 规范中提到，如果 XMLHttpRequest请求设置了withCredentials属性，那么服务器不得设置 Access-Control-Allow-Origin的值为* ，否则浏览器将会抛出The value of the 'Access-Control-Allow-Origin' header in the response must not be the wildcard '*'错误。 方法二： Nginx反向代理解决前后端联调跨域问题 方法三：更多方法 原因三：页面使用了请求mockjs。(被坑过，记忆深刻) cookie的size、priority问题 在chrome中测试过，无法设置size值 。chrome中可以查看size的值，似乎是根据cookie的value值长度自动生成的。？？ priority是设置cookie优先级的，具体有哪些参数，优先级规则是什么，没有找到相应资料。？？ 参考链接 关于Cookie的一些思考和理解 session与cookie详解 cookie详解 深入解析Cookie技术 聊一聊 cookie 浏览器系列之 Cookie 和 SameSite 属性 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"frontend/02-如何理解HTTP响应的状态码.html":{"url":"frontend/02-如何理解HTTP响应的状态码.html","title":"如何理解HTTP响应的状态码","keywords":"","body":"如何理解HTTP响应的状态码 HTTP 响应状态代码指示特定 HTTP 请求是否已成功完成。状态代码由 section 10 of RFC 2616定义。响应分为五类： 1xx：信息 2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 一般故障排除提示 当使用Web浏览器测试Web服务器时，在更改服务器后刷新浏览器 检查服务器日志以获取有关服务器如何处理请求的更多详细信息。 例如，网络服务器，如Apache或Nginx的生成两个文件名为access.log和error.log ，可以为相关的信息进行扫描。 请记住：HTTP状态代码定义是由提供请求的应用程序实现的标准的一部分。 这意味着返回的实际状态代码取决于服务器软件如何处理特定错误 – 本指南通常应该指向正确的方向 一些常见的状态码为： 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 这一类型的状态码，代表请求已被接受，需要继续处理。这类响应只包含状态行和某些可选的响应头信息，并以空行结束。 由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 100（继续）：迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。 服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送Expect: 100-continue作为头部，并在发送正文之前接收100 Continue状态代码。 101 （切换协议）：该代码是响应客户端的 Upgrade标头发送的，并且指示服务器也正在切换的协议。 服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如WebSocket）以传送利用此类特性的资源。 102 Processing（WebDAV；RFC 2518）： WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。 103 Early Hints： 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。 2xx （成功） 表示请求已成功被服务器接收、理解、并接受。 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回。 成功的含义取决于HTTP方法： GET：资源已被提取并在消息正文中传输。 HEAD：实体标头位于消息正文中。 POST：描述动作结果的资源在消息体中传输。 TRACE：消息正文包含服务器收到的请求消息 201（已创建）：该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。 202（已接受）：服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。如：需要的资源无法及时创建。 203（非授权信息）（自HTTP / 1.1起）：服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容）：服务器成功处理了请求，没有返回任何内容。 205（重置内容）：服务器成功处理了请求，但没有返回任何内容。 但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 （部分内容）：服务器成功处理了部分 GET 请求。实现断点续传或者将一个大文档分解为多个下载段同时下载。如：视频播放时的数据加载请求。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 207 （多状态）：由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 208 (已报告) （WebDAV；RFC 5842）：在 DAV 里面使用: propstat响应元素以避免重复枚举多个绑定的内部成员到同一个集合。 226（IM Used）（RFC 3229）：服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。 3xx （重定向） 表示要完成请求，需要进一步操作。 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。 300（多种选择）：被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 （永久移除）：请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。 302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303（查看其他位置）：对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 （未修改）：表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。 304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 305（使用代理）：被请求的资源必须通过指定的代理才能被访问。 Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306（临时重定向）： 在最新版的规范中，306状态码已经不再被使用。 307（临时重定向）： 请求的资源现在临时从不同的URI 响应请求。 由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 308（永久重定向）：这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这意味着资源现在永久位于由 Location: HTTP Response 标头指定的另一个 URI。 这与 301 Moved Permanently HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 POST，则必须在第二个请求中使用 POST。 4xx（客户端错误）表示请求可能出错，妨碍了服务器的处理。 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。 如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。 400（错误请求）：由于明显的客户端错误，服务器不能或不会处理该请求。 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 请求参数有误。比如：传参的数据结构不对 请求格式有误。如：由于浏览器故障，导致请求格式错误 参数数据量太大 无效的请求消息或欺骗性路由请求 与该网站相关联的用户Cookie已损坏。 清除浏览器的缓存和Cookie可以解决此问题 恶意代码的请求由于人为错误手动形成HTTP请求时（例如，使用curl错误） 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。 注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。 402 （要求付费）：此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。 如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。 403（禁止）：服务器已经理解请求，但是拒绝执行它。 与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。 执行访问被禁止。 读访问被禁止。 写访问被禁止。 要求 SSL。 要求 SSL 128。 IP 地址被拒绝。 要求客户端证书。 站点访问被拒绝。 用户数过多。 配置无效。 密码更改。 拒绝访问映射表。 客户端证书被吊销。 拒绝目录列表。 超出客户端访问许可。 客户端证书不受信任或无效。 客户端证书已过期或尚未生效。 在当前的应用程序池中不能执行所请求的 URL。 不能为这个应用程序池中的客户端执行 CGI。 Passport 登录失败。 404（未找到）： 请求失败，请求所希望得到的资源未被在服务器上发现。 没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 资源的链接是否有打字错误？ 用户键入的网址有误吗？ 文件是否存在于服务器上的正确位置？ 资源是否已在服务器上移动或删除？ 服务器配置是否具有正确的文档根位置？ 拥有Web服务器工作进程的用户是否有权限遍历到请求的文件所在的目录？ （提示：目录需要访问读取和执行权限） 访问的资源是否是符号链接？ 如果是，请确保Web服务器配置为遵循符号链接 405（方法禁用）：请求行中指定的请求方法（post、get、put、delete等）不能被用于请求相应的资源。 该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406（（不接受） ）：请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407（（需要代理授权））：与401响应类似，只不过客户端必须在代理服务器上进行身份验证。 代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。 408（（请求超时） ）：请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409（冲突）：由于和被请求的资源的当前状态之间存在冲突，请求无法完成。 这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。如：多个同步更新之间的编辑冲突。 410（已删除）：被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。 这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。 411（需要有效长度）：服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412（前提条件失败）：服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413（请求实体过大）：服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。 此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414（请求的 URI 过长）：请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。 415（不支持的媒体类型） ：对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416（请求范围不符合要求） （RFC 7233）：如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头。 417（未满足期望值）：此响应代码意味着服务器无法满足 Expect 请求标头字段指示的期望值。 418 （I'm a teapot）（RFC 2324）：本操作码是在1998年作为IETF的传统愚人节笑话，在RFC 2324超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。 这个HTTP状态码在某些网站（包括Google.com）与项目（如Node.js、ASP.NET和Go语言）中用作彩蛋。 420（保持冷静）：Twitter Search与TrendsAPI在客户端被限速的情况下返回。 421（错误请求）（RFC 7540）：该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。 422 （无法处理的实体）（WebDAV；RFC 4918 ）：请求格式良好，但由于语义错误而无法遵循。 423 （锁定）（WebDAV；RFC 4918）：正在访问的资源被锁定。 424 （依赖）（WebDAV；RFC 4918）：由于先前的请求失败，所以此次请求失败。 425 （太早了）：服务器不愿意冒着风险去处理可能重播的请求。如：安全验证未完成。 426 （需要升级）（RFC 2817）：服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 428 （需要前提条件） (RFC 6585)：原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。 429 （请求过多） （RFC 6585）：用户在给定的时间内发送了太多请求（“限制请求速率”）。 431 （请求头过大）（RFC 6585）：服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。 444 (不响应)：Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。 450（被Windows家长控制系统阻止）：这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。 451（由于法律原因无法使用）：用户请求非法资源，例如：由政府审查的网页。 5xx（服务器错误） 表示服务器在尝试处理请求时发生内部错误。 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。 500（内部服务器错误）：通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。 这此错误最常见的原因是服务器配置错误（例如，一个畸形.htaccess文件）或缺失的软件包（如试图在没有安装正确PHP执行的PHP文件）。 501（尚未实施）：此请求方法不被服务器支持且无法被处理。只有GET和HEAD是要求服务器支持的，它们必定不会返回此错误代码。 502（错误网关）：这意味着服务器的网关或代理服务器，它没有收到来自实际应该履行请求的后端服务器的有效响应。 如果有问题的服务器是逆向代理服务器，例如负载均衡器，则需要检查以下几项： 后端服务器（HTTP请求转发到的）是正常的 正确配置逆向代理，指定适当的后端 后端服务器和逆向代理服务器之间的网络连接是正常的。 如果服务器可以在其他端口上通信，请确保防火墙允许它们之间的流量 如果Web应用程序配置为侦听套接字，请确保套接字存在于正确的位置，并且具有适当的权限 503（服务不可用）： 表示服务器超载或正在维护。 这个错误意味着服务应该在某个时候可用。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 Retry-After：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。 如果服务器未处于维护状态，则这可以指示服务器没有足够的CPU或内存资源来处理所有传入的请求，或者Web服务器需要配置为允许更多的用户，线程或进程 504（网关超时）：当服务器作为网关，不能及时得到响应时返回此错误代码。 服务器之间的网络连接很差 由于性能不佳，履行请求的后端服务器太慢 网关或代理服务器的超时持续时间太短 505 （HTTP 版本不受支持）：服务器不支持请求中所使用的HTTP协议版本。 506 （协商引起的异常）（RFC 2295）：对请求的透明内容协商导致循环引用。 507 （存储不足）（WebDAV；RFC 4918）：服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。 508 （循环检测）（WebDAV；RFC 5842）：服务器在处理请求时陷入死循环。 可代替 208状态码 510 （扩展不足）（RFC 2774）：获取资源所需要的策略并没有被满足，客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。 511 （网络身份验证要求） （RFC 6585）：客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。如：连接WiFi热点时的强制网络门户 参考链接 MDN HTTP 响应代码 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"frontend/代码规范/":{"url":"frontend/代码规范/","title":"代码规范","keywords":"","body":"README 代码规范 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-16 00:42:55 "},"frontend/代码规范/00-W3C标准.html":{"url":"frontend/代码规范/00-W3C标准.html","title":"W3C标准","keywords":"","body":"W3C代码标准规范 WEB标准不是某一个标准，而是一系列标准的集合。 网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。 结构化标准语言主要包括 XHTML 和 XML； 表现标准语言主要包括 CSS； 行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。 这些标准大部分由 W3C 起草和发布，也有一些是其他标准组织制订的标准，比如 ECMA（European Computer Manufacturers Association）的 ECMAScript 标准。 结构标准语言 XML（The Extensible Markup Language，可扩展标识语言） 目前推荐遵循的是 W3C 于2000年10月6日发布的 XML1.0。和 HTML 一样，XML 同样来源于 SGML，但 XML 是一种能定义其他语言的语言。XML 最初设计的目的是弥补 HTML 的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。关于 XML 的好处和技术规范细节这里就不多说了，网上有很多资料，也有很多书籍可以参考。　 　 XHTML （The Extensible HyperText Markup Language，可扩展标识语言） 目前推荐遵循的是 W3C 于2000年1月26日推荐 XML1.0。XML 虽然数据转换能力强大，完全可以替代HTML，但面对成千上万已有的站点，直接采用 XML 还为时过早。因此，我们在 HTML4.0 的基础上，用 XML 的规则对其进行扩展，得到了 XHTML。简单的说，建立 XHTML 的目的就是实现 HTML 向 XML 的过渡。　 　 表现标准语言 CSS是Cascading Style Sheets 层叠样式表的缩写。 目前推荐遵循的是 W3C 于1998年5月12日推荐CSS2。W3C 创建 CSS 标准的目的是以 CSS 取代 HTML 表格式布局、帧和其他表现的语言。纯 CSS 布局与结构式 XHTML 相结合能帮助设计师分离外观与结构，使站点的访问及维护更加容易。　 行为标准 DOM （Document Object Mode，文档对象模型） 根据 W3C DOM 规范，DOM 是一种与浏览器，平台，语言的接口，使得你可以访问页面其他的标准组件。简单理解，DOM 解决了Netscaped 的 Javascript 和 Microsoft的 Jscript 之间的冲突，给予 web 设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对像。　 ECMAScript ECMAScript 是 ECMA（European Computer Manufacturers Association）制定的标准脚本语言（JAVAScript）。目前推荐遵循的是 ECMAScript 262 怎样通过W3C标准的验证? 图片的 alt=\"\" 属性必须每张图片都加上，而且对齐属性用 CSS 来定义。 每个文档必须加上DTD声明。 !DOCTYPE html PUBLIC \"-//W3C//DTDXHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> 去掉后能通过验证，但有警告：No DOCTYPE found! Checking with default XHTML 1.0 Transitional Document Type。 RSS 的 XML 通过时其中的域名地址必须与检测的地址一致，否则会报错。 标签的链接属性加上 JAVASCRIPT 事件时必须为#空链,不能为 javascript:; 或 javascript:void(null); 同一个页面当中，同名的 ID 会产生冲突。所以以 ID 定义样式的必须改成类引用。 不可省略双引号或单引号。这个是指属性，标准是双引号~，但，单引号也能通过验证。 标签之间不可错位嵌套。 所有的标签都使用小写。 所有的标签中含有的属性必须有值(官方的说法)。 标签必须配对完成，单标签必须以/关闭。 JS 和 CSS 外部引入文件必须加上类型定义。 所有的样式全部写在外部文件。用类名定义。在使用的地方引用。 页面上的一些特殊字符必须用HTML代码来标识.如“&”写成“&“ 不能缺少 title标签 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-25 22:20:48 "},"frontend/代码规范/01-HTML.html":{"url":"frontend/代码规范/01-HTML.html","title":"HTML","keywords":"","body":"HTML代码规范 DOCTYPE 声明 HTML 文件必须加上 DOCTYPE声明，并统一使用 HTML5 的文档声明： 页面语言LANG Lang 属性的取值应该遵循互联网工程任务组–IETF（The Internet Engineering Task Force）制定的关于语言标签的文档。推荐使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值 CHARSET 因为 ISO-8859 中字符集大小是有限的，且在多语言环境中不兼容，所以 Unicode联盟开发了 Unicode标准。 Unicode标准覆盖了（几乎）所有的字符、标点符号和符号。 Unicode使文本的处理、存储和运输，独立于平台和语言。 HTML-5 中默认的字符编码是 UTF-8 请尽量统一写成标准的 UTF-8，不要写成 utf-8 或 utf8 或 UTF8。根据 IETF对UTF-8的定义，其编码标准的写法是 UTF-8；而 UTF8或 utf8的写法只是出现在某些编程系统中 HTML标签闭合 HTML元素共有以下5种： 空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr 原始文本元素：script、style RCDATA元素：textarea、title 外来元素：来自 MathML 命名空间和 SVG 命名空间的元素。 常规元素：其他 HTML 允许的元素都称为常规元素。 为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定： 所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。 空元素标签都不加 “/” 字符 HTML代码风格 HTML 标签名、类名、标签属性和大部分属性值统一用小写； HTML 文本、CDATA、JavaScript、meta 标签某些属性等内容可大小写混合； 不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含； 元素属性值使用双引号语法、元素属性值可以写上的都写上。属性顺序： class id name data-* src, for, type, href, value , max-length, max, min, pattern placeholder, title, alt aria-*, role required, readonly, disabled 特殊字符引用: HTML 中不能使用小于号 “” 特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 代码缩进: 使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 两个空格： 使用两个空格可以一眼就知道是两个空格而不是一个制表符（大部分编辑器默认一个制表符占四个空格的位置）。所以两个空格更容易保持一致性。 能和其他语言统一。比如写 JSON、Python、YAML 时就不用切换习惯了 四个空格：更具有层次感，便于观察代码的逻辑结构。 代码嵌套: 元素嵌套规范，每个块状元素独立一行，内联元素可选。段落元素与标题元素只能嵌套内联元素。减少标签数量，需要尽量避免多余的父节点。 列表中的条目必须总是放置于、或 中，永远不要用一组 或 来表示。 注释规范 单行注释:一般用于简单的描述，如某些状态描述、属性描述等。注释位于要注释代码的上面，单独占一行 模块注释:一般用于描述模块的名称以及模块开始与结束的位置。 HTML5 标准模版 HTML5标准模版 移动端 HTML5 模版 PC 端 HTML5 模版 PC端HTML模版 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-25 22:25:43 "},"frontend/代码规范/02-CSS.html":{"url":"frontend/代码规范/02-CSS.html","title":"CSS","keywords":"","body":"CSS代码规范 @charset 样式文件必须写上 @charset 规则，并且一定要在样式文件的第一行首个字符位置开始写，编码名用 UTF-8 。 @charset \"UTF-8\"; UTF-8编码：为世界统一编码，可以兼容全世界的操作系统，不会出现乱码情况。缺点是体积稍大点。 gb2312编码：国外的浏览者可能会出现乱码，获提示安装语言包。一般，网站提供给全球看的一般用UTF-8，仅仅针对国内的用gb2312 就可以了。体积稍小点，因为程序产生的网页文本使用 ANSI 编码格式，会比 UTF-8 文本编码节省一些体积，访问速度会稍微快一点点。 使用UTF-8编码有2个要注意： 网页的 meta 必须有这句：。 网页的文本格式必须保存为 UTF-8 格式。 代码风格 class用\"_\"连接，id用驼峰命名。 使用展开格式书写样式，即一个属性一行，每个属性声明末尾都要加分号。 选择器：尽量少用通用选择器 *。 不使用 ID 选择器。 不使用无具体语义定义的标签选择器。 代码缩进：统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）。 左括号与类名之间一个空格，冒号与属性值之间一个空格。 逗号分隔的取值，逗号之后一个空格。 为单个css选择器或新申明开启新行。 尽可能使用短的十六进制数值，例如使用 #fff 替代 #ffffff。 属性值十六进制数值能用简写的尽量用简写。 不要为 0 指明单位。 去掉小数点前面的0。 css属性值需要用到引号时，统一使用单引号。 图片引入不需要引号。 属性书写顺序 布局定位属性：display / position / float / clear / visibility / overflow 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient … 浏览器私有前缀在前，标准前缀在后 { -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px; } 属性简写 background: [background-color] [background-image] [background-repeat] [background-attachment] [background-position] / [ background-size] [background-origin] [background-clip]; font: [font-style] [font-variant] [font-weight] [font-size]/[line-height] [font-family]; transition: property duration timing-function delay; animation: name duration timing-function delay iteration-count direction; © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-25 22:27:18 "},"frontend/代码规范/03-JS.html":{"url":"frontend/代码规范/03-JS.html","title":"JS","keywords":"","body":"JS代码规范 尽量使用 ES6 语法 声明变量时，请使用 const、let 关键字 使用拓展运算符 ... 复制数组、对象 当需要使用对象的多个属性时，请使用解构赋值 使用箭头函数 最外层统一使用单引号；程序化生成字符串时，请使用模板字符串 (``) 不要使用 arguments，可以选择使用 ... 使用标准的 ES6 模块语法 import 和 export。不要使用 import 的通配符 *，这样可以确保你只有一个默认的 export 请使用对象方法的简写方式、对象属性值的简写方式 const item = { job，//而非job: job, addValue(val) { //而非addValue: function (val) { return item.value + val } } 请使用字面量值创建对象。用const a = {} 而非 const a = new Object{} 别使用保留字作为对象的键值，这样在 IE8 下不会运行 不要在非函数代码块中声明函数。如：不在if模块中声明函数 每个语句的末尾不使用分号 对上下文 this 的引用只能使用 _this|that|self 其中一个来命名 不加空格 对象的属性名后 前缀一元运算符后 后缀一元运算符前 函数调用括号前 无论是函数声明还是函数表达式，'('前不要空格 数组的'['后和']'前 对象的'{'后和'}'前 运算符'('后和')'前 加空格 二元运算符前后 三元运算符 ?: 前后 代码块 { 前 下列关键字前：else, while, catch, finally 下列关键字后：if, else, for, while, do, switch, case, try,catch, finally, with, return, typeof 单行注释'//'后（若单行注释和代码同行，则'//'前也需要），多行注释'*'后 对象的属性值前 for循环，分号后留有一个空格，前置条件如果有多个，逗号后留一个空格 无论是函数声明还是函数表达式，'{'前一定要有空格 函数的参数之间 空行 变量声明后（当变量声明在代码块的最后一行时，则无需空行） 注释前（当注释在代码块的第一行时，则无需空行） 代码块后（在函数调用、数组、对象中则无需空行） 文件最后保留一个空行 禁止使用链式赋值；声明变量时，一个声明只能有一个变量 常量采用大写字母，下划线连接的方式 完全避免 == != 的使用， 用严格比较条件 === !== JS命名规范 构造函数（类）命名 首字母大写，驼峰式命名 JS 中没有类，但是可以用 new 调用构造函数：var man = new Person() 普通变量命名 驼峰式命名：第一个单词首字母小写，后面其他单词首字母大写。 匈牙利命名：前缀字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，单词第一个字母大写。 提示：虽然 JavaScript 变量表面上没有类型，但是 JavaScript 内部还是会为变量赋予相应的类型 JavaScript变量起名类型 变量命名前缀 举例 Array 数组 a aList，aGroup Boolean 逻辑 b bChecked，bHasLogin Function 函数 f fGetHtml，fInit Integer 数字 n nPage，nTotal Object 对象 o oButton，oDate Regular Expression 正则 r rDomain，rEmail String 字符 s sName，sHtml 函数命名 普通函数：fn + 动词 + 名词形式。如：fnGetVersion() 内部函数：_fnn + 动词 + 名词形式，内部函数必需在函数最后定义。如： _fnGetNumber 对象方法：fn + 对象类名 + 动词 + 名词形式。如：fnAddressGetEmail() 事件响应函数：fn + 触发事件对象名 + 事件名或者模块名。如：fnDivClick() 函数方法常用的动词： get 获取/set 设置, add 增加/remove 删除 create 创建/destory 移除 start 启动/stop 停止 open 打开/close 关闭, read 读取/write 写入 load 载入/save 保存, create 创建/destroy 销毁 begin 开始/end 结束, backup 备份/restore 恢复 import 导入/export 导出, split 分割/merge 合并 inject 注入/extract 提取, attach 附着/detach 脱离 bind 绑定/separate 分离, view 查看/browse 浏览 edit 编辑/modify 修改, select 选取/mark 标记 copy 复制/paste 粘贴, undo 撤销/redo 重做 insert 插入/delete 移除, add 加入/append 添加 clean 清理/clear 清除, index 索引/sort 排序 find 查找/search 搜索, increase 增加/decrease 减少 play 播放/pause 暂停, launch 启动/run 运行 compile 编译/execute 执行, debug 调试/trace 跟踪 observe 观察/listen 监听, build 构建/publish 发布 input 输入/output 输出, encode 编码/decode 解码 encrypt 加密/decrypt 解密, compress 压缩/decompress 解压缩 pack 打包/unpack 解包, parse 解析/emit 生成 connect 连接/disconnect 断开, send 发送/receive 接收 download 下载/upload 上传, refresh 刷新/synchronize 同步 update 更新/revert 复原, lock 锁定/unlock 解锁 check out 签出/check in 签入, submit 提交/commit 交付 push 推/pull 拉, expand 展开/collapse 折叠 begin 起始/end 结束, start 开始/finish 完成 enter 进入/exit 退出, abort 放弃/quit 离开 obsolete 废弃/depreciate 废旧, collect 收集/aggregate 聚集 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-25 22:30:41 "},"frontend/代码规范/04-其他.html":{"url":"frontend/代码规范/04-其他.html","title":"其他","keywords":"","body":"其他前端规范 四种基本的编程命名规范 驼峰式命名：第一个单词首字母小写，后面其他单词首字母大写。 匈牙利命名：前缀字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，单词第一个字母大写。 帕斯卡命名法：又叫大驼峰式命名法。每个单词的第一个字母都大写。 下划线命名法：单词与单词之间通过下划线连接即可 命名规范 项目命名：以字母开头，全部采用小写方式， 以中划线分隔。 比如： my-project-name 图片命名：项目名（可选） + 模块名（可选） + 图片功能（必选）+ 图片精度(可选)，以中划线分隔 图片功能：icon|logo|btn|bg|cont 模块名称： list|info|avatar 图片精度： @1x | @2x | @3x HTML/CSS文件命名：以字母开头，全部采用小写方式， 以中划线分隔 ClassName命名：以字母开头，全部采用小写方式， 以下划线分隔 ClassName的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线 “_” 连接 在子孙模块数量可预测的情况下，严格继承祖先模块的命名前缀。当子孙模块超过4级或以上的时候，可以考虑在祖先模块内具有识辨性的独立缩写作为新的子孙模块 常用命名推荐 devideByType name 文字 description、info、information、details、feature、msg、message、txt、text、tips、title、 图片 avatar、logo、arrow、thumbnail 标签 bar、btn、branding、links、more、nav、navigation、pop、popup、nub、promotion、subscribe、summary、crumb、breadcrumbs、category、col、column 功能类 clearfix、copyright、comment、forum、help、login、logout、menu、pagination、output、preview、progress、reg、register、save、search、share、show、sort、submit 容器 container、wrap、wrapper、module 内容 content、slide、main、body、section 状态 current、disabled、active、error、fail、default、hightlight、fewer、hide、off、on、selected、checked、success 层级 primary、secondary、sub 序列 even、odd、first、last、previous、next 常用图片格式 常见的图片格式有 GIF、PNG8、PNG24、JPEG、WEBP，根据图片格式的特性和场景需要选取适合的图片格式。 GIF 体积小：优秀的压缩算法使其在一定程度上保证图像质量 动画：可插入多帧，从而实现动画效果。 透明：可设置透明色以产生对象浮现于背景之上的效果。 色彩失真：由于采用了8位压缩，最多只能处理256种颜色，故不宜应用于真彩色图片。 在兼容性允许的情况下考虑，可以在想要动图效果时使用视频，通过静音（muted）的 video 来代替 GIF。相同的效果下，GIF 比视频（MPEG-4）大 5～20 倍。 PNG 体积小：无损压缩，支持256色调色板技术。 真彩色：最高支持48位真彩色图像以及16位灰度图像。 透明：支持Alpha通道的透明/半透明特性。 可预览：渐近显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌。 其他：支持图像亮度的Gamma校准信息、支持存储附加文本信息（图像名称、作者、版权、创作时间、注释）、使用CRC防止文件出错、最新的PNG标准允许在一个文件内存储多幅图像。 JPEG 适用于储存24位元全采影像 采取的压缩方式通常为有损压缩 不支持透明或动画 压缩比越高影像耗损越大，失真越严重 压缩比在10左右肉眼无法辨出压缩图与原图的差别 WEBP 同时提供有损压缩和无损压缩两种图片文件格式 文件体积小：在有损与无损压缩上，它的表现都会优于传统（JPEG/PNG）格式。WebP 无损压缩比 PNG 的体积小 26%，webP 的有损压缩比同质量的 JPEG 格式体积小 25-34%。同时 WebP 也支持透明度。 浏览器兼容差：目前只支持客户端 Chrome 和 Opera 浏览器以及安卓原生浏览器(Andriod 4.0+) 使用什么格式图片合适？ 内容图片 内容图片颜色较为丰富，文件体积较大 优先考虑 ：Webp > JPEG > PNG(PNG8 色位太低，PNG24 压缩率低，文件体积大) 背景图 背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片 优先考虑：WebP > PNG 、JPEG > GIT PNG8 格式：图像颜色比较简单的，如纯色块线条图标 PNG24 格式：图像颜丰富而且图片文件不太大的（40KB 以下）或有半透明效果的 JPEG 格式：图像颜色丰富而且文件比较大的（40KB - 200KB） 使用多大图片？ 上线的图片都应该经过压缩处理，压缩后的图片不应该出现肉眼可感知的失真区域 60质量的JPEG格式图片与质量大于60的相比，肉眼已看不出明显的区别，因此保存 JPEG 图的时候，质量一般控制在60，若保真度要求高的图片可适量提高到 80，图片大小控制在 200KB 以内 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"html探索系列/00-HTML基础知识.html":{"url":"html探索系列/00-HTML基础知识.html","title":"HTML基础知识","keywords":"","body":"HTML基础知识 1. Web标准的三个规范 结构(Structure) HTML：HTML英语意思是：Hypertext Marked Language，即超文本标记语言,使用HTML语言描述的文件，需要通过 WWW 浏览器显示出效果。是一种最为基础的语言。所谓超文本，因为它可以加入图片、声音、动画、影视等内容，因为它可以从一个文件跳转到另一个文件，与世界各地主机的文件连接。所谓标记，就是它采用了一系列的指令符号来控制输出的效果，这些指令符号用“”来表示。 XHTML：XHTML 是 HTML 向 XML 的过渡语言，删除了部分表现层的标签，标准要求提高，有严谨的结构，所有标签必须关闭。如果是单独不成对的标签，在标签最后加一个\"/\"来关闭它。 XML：XML（eXtensible Markup Language）即可扩展标记语言，最初设计的目的是弥补 HTML 的不足，以强大的扩展性满足网络信息发布的需要，后来逐渐用于网络数据的转换和描述。XML 是一种简单的数据存储语言，使用一系列简单的标记描述数据，而这些标记可以用方便的方式建立，虽然 XML 占用的空间比二进制数据要占用更多的空间，但 XML 极其简单易于掌握和使用。 表现(Behaivor) 表现标准语言主要包括 CSS（Cascading Style Sheets）层叠式样式表，通过 CSS 样式表，W3C 创建 CSS 标准的目的是以 CSS 取代HTML 表格式布局、帧和其他表现的语言，通过 CSS 样式可以使页面的结构标签更具美感、网页外观更加美观。 行为(Presentation) 行为是指页面和用户具有一定的交互，同时页面结构或者表现发生变化。标准主要包括：ECMAScript(核心)，DOM（文档对象模型），BOM（浏览器对象模型）。 ECMAScript(核心)： ECMAScript 是一个语言标准，javascript 则是基于这个标准实现的脚本语言。 ECMAScript 是一种可以在宿主环境中执行计算并能操作可计算对象的基于对象的程序设计语言。ECMAScript 最先被设计成一种 Web 脚本语言，用来支持 Web 页面的动态表现以及为基于 Web 的客户机—服务器架构提供服务器端的计算能力。但作为一种脚本语言， ECMAScript 具备同其他脚本语言一样的性质，即“用来操纵、定制一个已存在系统所提供的功能，以及对其进行自动化”。 DOM（文档对象模型）： DOM全称 Document Object Model，即文档对象模型，它允许脚本(js)控制 Web 页面、窗口和文档。 DOM 标准分为 ：核心DOM，针对任何结构化文档的标准模型；XML DOM，针对 XML 文档的标准模型；HTML DOM，针对 HTML 文档的标准模型。 BOM（浏览器对象模型）: BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 常见的BOM对象有： window：代表整个浏览器窗口（window是BOM中的一个对象，并且是顶级的对象）； Navigator ：代表浏览器当前的信息，通过 Navigator 我们可以获取用户当前使用的是什么浏览器； Location： 代表浏览器当前的地址信息，通过 Location 我们可以获取或者设置当前的地址信息； History：代表浏览器的历史信息，通过 History 我们可以实现上一步/刷新/下一步操作（出于对用户的隐私考虑，我们只能拿到当前的浏览记录，不能拿到所有的历史记录）； Screen：代表用户的屏幕信息。 2. Web标准之可访问性、可用性、可维护性 可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力 可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性 可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。 3. web标准的优点： 代码的效率：在HTML文件中使用最精简的代码，而把样式和页面布局信息包含进 CSS 文件中；则放在服务器上的文件越小，下载文件需要的时间就越短。 易于维护：页面的样式和布局信息保存在单独的 CSS 文件中，如果你想改变站点的外观时，仅需要在单独的 CSS 文件中做出更改可。整站统一 css 则可带来巨大的便利。 可访问性：上网用户中那些视力受损的人，通过屏幕阅读器使用键盘命令将网页的内容读给他们听。以语义化的HTML（结构和表现相分离的HTML）编写的网页文件，就可以让此类用户更容易导航，且网页文件中的重要信息也更有可能被这些用户找到。 设备兼容性：纯HTML，无附加样式信息，可以针对具有不同特点（如屏幕尺寸等）的设备而被重新格式化，只需要引用一套另外的样式表即可。同时，CSS 本身也可以让你为不同的呈现方式和媒体类型（如在屏幕上阅读网页，打印网页，在移动设备上阅读网页等）规定不同的样式表。 网络爬虫/搜索引擎：搜索引擎使用“爬虫”，解析你的网页。语义化的HTML能更准确更快速的被解析，从而知道哪些才是重要的内容，那么你的网页在搜索结果中的排名就会大受影响 4. 渐进增强和优雅降级的定义 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。 5. 元素的 alt 和 title 属性有什么区别？ alt 属性： 规定在图像无法显示时的替代文本。 用于在图像无法显示或者用户禁用图像显示时，代替图像显示在浏览器中的内容。alt 属性只能用在 img、area、input 元素中（包括 applet 元素）。对于 input 元素，alt 属性意在用来替换提交按钮的图片。如： title 属性： 规定关于元素的额外信息。这些信息通常会在鼠标移到元素上时显示一段工具提示文本。 title 属性常与 form、a 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 abbr、acronym 元素的必需属性。当然 title 属性是比较广泛使用的，可以用在除了 base、basefont、head、html、meta、param、script、title 之外的所有标签。但是并不是必须的。 title 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。这样就使得访问者知道那些链接将会带他们到什么地方，他们就不会加载一个可能完全不感兴趣的页面。 另外一个潜在的应用就是为图像提供额外的说明信息，比如日期或者其他非本质的信息。 当用户把鼠标移动到 img 元素上时，Internet Explorer 会显示出 alt 属性的值。这种行为并不正确。所有其他的浏览器正在向规范靠拢，只要当图像无法显示时，才会显示出替代文本。 6. src、href、URL的区别 src： source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置。 在请求 src 资源时会将其指向的资源下载并应用到文档内。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕。如script, img, frame。用作 \"拿取\"。 href： Hypertext Reference 的缩写，指向网络资源所在位置。 建立资源与当前元素（锚点）或当前文档（链接）之间的链接。浏览器可以识别文档，就会并行下载资源并且不会停止对当前文档的处理。如link, a等标签。用作 \"连结前往\"。 URL： Uniform Resource Locator 的缩写，表示统一资源定位符，是互联网上标准资源的地址。 互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。通用的 \"连结\" 的专业代名词，在 HTML 语法里几乎不会使用。 7. URL后面带\"/\"与不带\"/\"有什么区别? URL 带 \"/\" 与不带 \"/\" 是两个不同的概念。不带 \"/\" 就是一个文件，带 \"/\" 就是一个目录。对于 SEO 优化而言，带斜杠的链接是非常有必要的。 Domain/abc 表示的是根目录下的 abc 文件，而 Domain/abc/ 指的是 abc 目录下的 default 文件（一般是指 index 文件，服务器可自定义）。 当搜索引擎蜘蛛爬取 Domain/abc 时，首先是到根目录下去读取 abc 文件，找不到 abc 文件后会自动的读取根目录下 abc 目录下的`default文件 而当搜索引擎蜘蛛爬取 Domain/abc/ 时，是直接到根目录下 abc 目录直接读取该目录下的 default 文件。在同样资源的情况下，能节省读取时间，对 SEO 优化是非常必要的。 8. 如何清理Chrome的favicon缓存？ cd /Users/$USERNAME/Library/Application\\ Support/Google/Chrome/Default rm Favicons Favicons-journal #重启chrome 1. Label 的作用是什么？是怎么用的？ label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 Number: 2. HTML5 的 form 的自动完成功能是什么？ autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。 自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。 autocomplete 属性适用于 form，以及下面的 input 类型：text, search, url, telephone, email, password, datepickers, range、color。 3. title 与 h1 的区别？ title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。 4. head 标签中必不少的是？ head 标签用于定义文档的头部，它是所有头部元素的容器。head 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数 据都不会真正作为内容显示给读者。 下面这些标签可用在 head 部分：base、link、meta、script、style、title。 title 定义文档的标题，它是 head 部分中唯一必需的元素。 5. DOMContentLoaded 事件和 Load 事件的区别？ 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。 Load 事件是当所有资源加载完成后触发的。 7. Canvas 和 SVG 有什么区别？ Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。 SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。 8. attribute 和 property 的区别是什么？ attribute 是 dom 元素在文档中作为 html 标签拥有的属性； property 就是 dom 元素在 js 中作为对象拥有的属性。 对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。 9. disabled 和 readonly 的区别？ readonly： 表示元素为只读； 只能用于 input(text/passward)、textarea 元素；只是使文本框不能输入，外框没有变化； disabled： 表示禁用元素；可用于所有表单元素；会使文本框变灰。 将表单以 POST 或 GET 的方式提交的话，使用了 disabled 后，这个元素的值不会被传递出去，而 readonly 会将该值传递出去。 但，无论元素设置的是 readonly 还是 disabled 属性，通过 JS 脚本都能更改元素的 value。 10. Flash、Ajax 各自的优缺点？（??lizhao） Flash： 优点：适合处理多媒体、矢量图形，兼容性，客户端资源调度；缺点：对CSS、处理文本上不足，不容易被搜索，flash 文件通常会很大，用户第一次使用的时候需要忍耐较长的等待时间 ，性能较差。 Ajax：对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM。 11. 网页验证码是干嘛的，是为了解决什么安全问题？ 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水； 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-16 01:26:59 "},"html探索系列/01-HTML元素的宽高及位置详解.html":{"url":"html探索系列/01-HTML元素的宽高及位置详解.html","title":"HTML元素的宽高及位置详解","keywords":"","body":"HTML元素的宽高度及位置详解 元素的宽度 window.innerWidth //除去菜单栏的窗口宽度。安卓、ios都认别 window.innerHeight //除去菜单栏的窗口高度。安卓、ios都认别 window.outerWidth //包括菜单栏的窗口宽度。安卓手机识别，ios不认别。 window.outerHeight //包括菜单栏的窗口宽度。安卓手机识别，ios不认别。 window.screen.height //屏幕的高度 window.screen.width //屏幕的宽度 window.screen.availHeight //屏幕的可利用高度 window.screen.availWidth //屏幕的可利用宽度 //screen.width/height，屏幕宽度/高度(即：屏幕分辩率。比如1920 * 1080） //screen.availWidth/availHeight，屏幕的可利用宽度/高度(即：屏幕分辩率 - (工具栏 + mac的dock等) window.screenTop //浏览器距离屏幕的高度 window.screenLeft //浏览器距离屏幕的宽度 window.scrollX //属性返回页面的水平滚动距离 window.scrollY //属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。 window.pageXOffset //window.scrollX别名 window.pageYOffset //window.scrollY别名 document.body.clientWidth //指元素的自身宽度（包括padding） document.body.clientHeight //指元素的自身的高度（包括padding） document.body.clientLeft //子级div内容位置到父级内容区域的宽度距离(即border值) document.body.clientTop //子级div内容位置到父级内容区域的高度距离(即border值) document.body.offsetWidth //指定元素的宽度（包括padding，border和内容） document.body.offsetHeight //指定元素的高度（包括padding，border和内容） document.body.offsetTop //距离父级元素的高度 document.body.offsetLeft //距离父级元素的宽度 document.body.scrollWidth //获取的是文档的宽度（当指定的宽度小于浏览器窗口的时候，为浏览器的宽度） document.body.scrollHeight //获取的是文档的高度（当指定的高度小于浏览器窗口的时候，为浏览器的高度） document.body.scrollTop //文档被滚动上去的时候（即滚动条往上滚动的距离） document.body.scrollLeft //文档被滚动右去的时候（即滚动条往右滚动的距离） document.documentElement.scrollWidth //获取的是文档的宽度（当指定的宽度小于浏览器窗口的时候，为浏览器的宽度） document.documentElement.scrollHeight // document.documentElement.scrollTop //垂直方向滚动的值 document.documentElement.scrollLeft //clientX，clientY是事件中的概念 event.clientX //鼠标点击时候距离可视区的左侧坐标 event.clientY //鼠标点击时候距离可视区的上侧坐标 event.clientX + document.documentElement.scrollLeft //鼠标点击时候相对文档左侧的水平距离 document.body.scrollTop与document.documentElement.scrollTop两者有个特点，就是同时只会有一个值生效。比如document.body.scrollTop能取到值的时候，document.documentElement.scrollTop就会始终为0；反之亦然。所以，如果要得到网页的真正的scrollTop值，可以这样： document.body.scrollTop + document.documentElement.scrollTop。 offset：指定元素的border+padding+内容的宽度和高度 IE6/7中: offsetLeft = (offsetParent的padding-left)+(当前元素的margin-left)IE8以上: offsetLeft = (offsetParent的margin-left)+(当前元素的margin-left)火狐中: offsetLeft = (offsetParent的margin-left)+(当前元素的margin-left)+(offsetParent的padding-left) client: 指定元素的宽度和高度 即内容+padding 如果没有滚动条，即元素本身设定的宽度如果出现滚动条，滚动条会遮盖元素宽高，那么，该属性就是其本来宽高减去滚动条的宽度读取元素border的宽度和高度（子级内容区域到父级内容区域的距离）: document.body.clientLeft、document.body.clientTop scroll： 元素的宽度（client）+滚动部分?? 文档渲染模式 文档的渲染模式有\"混杂模式\"和\"标准模式\"。还有另外一种渲染模式, Gecko的\"准标准模式\", 该模式和标准规范模式的区别仅为表格单元内的图片布局方式不同. 且该模式的类型字符串仍为: \"CSS1Compat\". document.compatMode用来判断当前浏览器采用的渲染方式。官方解释：BackCompat：标准兼容模式关闭。CSS1Compat：标准兼容模式开启。 当document.compatMode等于BackCompat时，浏览器客户区宽度是document.body.clientWidth； 当document.compatMode等于CSS1Compat时，浏览器客户区宽度是document.documentElement.clientWidth。 documentElement 对应的是 html 标签，而 body 对应的是 body 标签。 浏览器窗口可视区域兼容性写法 浏览器窗口的大小，则是指在浏览器窗口中看到的那部分网页面积，又叫做viewport（视口）。 IE8及IE8以下不兼容： window.innerWidth/window.innerHeight 标准模式下：document.documentElement.clientWidth/document.documentElement.clientHeight 怪异模式下：document.body.clientWidth/document.body.clientHeight function getViewport(){ if (document.compatMode == \"BackCompat\"){ return { width: document.body.clientWidth, height: document.body.clientHeight } } else { return { width: document.documentElement.clientWidth, height: document.documentElement.clientHeight } } } 一个准确获取网页客户区的宽高、滚动条宽高、滚动条Left和Top的代码（兼容目前流行的全部浏览器，包括：IE、Firefox、Safari、Opera、Chrome）： if (document.compatMode == \"BackCompat\") { cWidth = document.body.clientWidth; cHeight = document.body.clientHeight; sWidth = document.body.scrollWidth; sHeight = document.body.scrollHeight; sLeft = document.body.scrollLeft; sTop = document.body.scrollTop; } else { //document.compatMode == \"CSS1Compat\" cWidth = document.documentElement.clientWidth; cHeight = document.documentElement.clientHeight; sWidth = document.documentElement.scrollWidth; sHeight = document.documentElement.scrollHeight; sLeft = document.documentElement.scrollLeft == 0 ? document.body.scrollLeft : document.documentElement.scrollLeft; sTop = document.documentElement.scrollTop == 0 ? document.body.scrollTop : document.documentElement.scrollTop; } 必须在页面加载完成后才能运行，否则document对象还没生成，浏览器会报错。 大多数情况下，都是document.documentElement.clientWidth返回正确值。但是，在IE6的quirks模式中，document.body.clientWidth返回正确的值，因此加入了对文档模式的判断 clientWidth和clientHeight都是只读属性，不能对它们赋值。 网页的大小 首先，要明确两个基本概念。 一张网页的全部面积，就是它的大小。通常情况下，网页的大小由内容和CSS样式表决定。 很显然，如果网页的内容能够在浏览器窗口中全部显示（也就是不出现滚动条），那么网页的大小和浏览器窗口的大小是相等的。如果不能全部显示，则滚动浏览器窗口，可以显示出网页的各个部分。 function getPagearea(){ if (document.compatMode == \"BackCompat\"){ return { width: Math.max(document.body.scrollWidth, document.body.clientWidth), height: Math.max(document.body.scrollHeight, document.body.clientHeight) 　　} } else { return { width: Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth), height: Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight) } } } 网页内容能够在浏览器窗口中全部显示，不出现滚动条，那么网页的clientWidth和scrollWidth应该相等。但是实际上，不同浏览器有不同的处理，这两个值未必相等。所以，我们需要取它们之中较大的那个值。 网页元素的位置 获取网页元素的绝对位置 网页元素的绝对位置，指该元素的左上角相对于整张网页左上角的坐标。这个绝对位置要通过计算才能得到。每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器（offsetParent对象）左上角的距离。所以，只需要将这两个值进行累加，就可以得到该元素的绝对坐标。 function getElementLeft(element) { var actualLeft = element.offsetLeft var current = element.offsetParent while (current !== null) { 　　actualLeft += current.offsetLeft 　　current = current.offsetParent } return actualLeft } function getElementTop(element) { var actualTop = element.offsetTop var current = element.offsetParent while (current !== null) { 　　actualTop += current.offsetTop 　　current = current.offsetParent } return actualTop } 获取网页元素的相对位置 网页元素的相对位置，指该元素左上角相对于浏览器窗口左上角的坐标。有了绝对位置以后，获得相对位置就很容易了，只要将绝对坐标减去页面的滚动条滚动的距离就可以了。滚动条滚动的垂直距离，是document对象的scrollTop属性；滚动条滚动的水平距离是document对象的scrollLeft属性。 function getElementViewLeft(element) { var actualLeft = element.offsetLeft var current = element.offsetParent while (current !== null) { actualLeft += current.offsetLeft current = current.offsetParent } var elementScrollLeft = document.compatMode == \"BackCompat\" ? document.body.scrollLeft : document.documentElement.scrollLeft return actualLeft - elementScrollLeft } function getElementViewTop(element) { var actualTop = element.offsetTop var current = element.offsetParent while (current !== null) { actualTop += current. offsetTop current = current.offsetParent } var elementScrollTop = document.compatMode == \"BackCompat\" ? document.body.scrollTop :document.documentElement.scrollTop return actualTop - elementScrollTop } scrollTop和scrollLeft属性是可以赋值的，并且会立即自动滚动网页到相应位置，因此可以利用它们改变网页元素的相对位置。另外，element.scrollIntoView()方法也有类似作用，可以使网页元素出现在浏览器窗口的左上角。 获取元素位置的快速方法 除了上面的函数以外，还有一种快速方法，可以立刻获得网页元素的位置。那就是使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。 相对位置: var X = this.getBoundingClientRect().left var Y = this.getBoundingClientRect().top 绝对位置(相对位置+滚动距离): var X = this.getBoundingClientRect().left + document.documentElement.scrollLeft + document.body.scrollLeft var Y = this.getBoundingClientRect().top + document.documentElement.scrollTop + document.body.scrollTop 目前，IE、Firefox 3.0+、Opera 9.5+都支持该方法，而Firefox 2.x、Safari、Chrome、Konqueror不支持。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"html探索系列/02-video元素的使用和常见问题总结.html":{"url":"html探索系列/02-video元素的使用和常见问题总结.html","title":"Video元素的使用和常见问题总结","keywords":"","body":"video元素的使用和常见问题总结 HTML元素 用于在HTML或者XHTML文档中嵌入媒体播放器，用于支持文档内的视频播放。你也可以将 标签用于音频内容，但是audio元素可能在用户体验上更合适。 以下是一个局域播放的示例，允许html元素在视频上方： --> Your browser doesn't support HTML5 video. Here is a link to the video instead. 查看DEMO 标签的内容是针对浏览器不支持此元素时候的降级处理。浏览器并不是都支持相同的视频格式，所以你可以在 元素里提供多个视频源，然后浏览器将会使用它所支持的第一个源。 标签它允许指定时序文本字幕（或者基于时间的数据），例如自动处理字幕。 其他使用注意事项： 如果你没有指定controls属性，那么视频不会展示浏览器自带的控件，你也可以用 JavaScript和 HTMLMediaElement API来创建你自己的控件。 HTMLMediaElement会激活许多不同的事件，以便于让你可以控制视频（和音频）内容。 你可以用CSS属性 object-position 来调整视频在元素内部的位置，它可以控制视频尺寸适应于元素外框的方式。 如果想在视频里展示字幕或者标题，你可以在 元素和WebVTT格式的基础上使用 JavaScript 来实现。 video的属性 autoplay：布尔属性；指定后，视频会马上自动开始播放，不需要手动调用play()方法。 自动播放受浏览器政策限制，不同浏览器的表现不一样。移动端的app，可以设置参数来控制是否允许自动播放。 autobuffer：布尔属性；指定后，视频会自动开始缓存，即使没有设置自动播放。该属性适用于视频被认为可能会播放（比如，用户导航到专门播放视频的页面，而不是那种嵌入视频还有其它内容的页面）。视频会一直缓存到媒体缓存满。 controls：加上这个属性，Gecko 会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。 controlslist： 当浏览器显示自己的控件集(例如，当指定了Controls属性时)，Controlslist属性将帮助浏览器选择在媒体元素上显示的控件。允许接受的值有nodownload,nofullscreen和noremoteplayback crossorigin：该枚举属性指明抓取相关图片是否必须用到CORS（跨域资源共享）。 支持CORS的资源 可在元素中被重用，而不会被污染。允许的值如下： anonymous 跨域请求（即，使用 Origin: 的HTTP头）会被执行。但是不发送凭证（即，不发送cookie， X.509 证书或者 HTTP Basic 授权）。如果服务器不提供证书给源站点 (不设置Access-Control-Allow-Origin: HTTP头)，图片会被 污染 并且它的使用会受限。 use-credentials 跨域请求A cross-origin request (i.e. with Origin: HTTP header)会被执行，且凭证会被发送 (即， 发送一个 cookie, 一个证书和HTTP Basic授权会被执行)。如果服务器不提供证书给源站点 (通过Access-Control-Allow-Credentials: HTTP头)，图像会被污染且它的使用会受限。 不加这个属性时，抓取资源不会走CORS请求(即，不会发送 Origin: HTTP 头)，保证其在元素中使用时不会被污染。如果指定非法值，会被当作指定了枚举关键字 anonymous一样使用。 currentTime： 读取CurentTime返回一个双精度浮点值，指示以秒为单位的媒体的当前播放位置。如果video尚未开始播放，则会在开始播放后返回偏移量。通过CurentTime将当前播放位置设置为给定时间，会在加载媒体时将媒体查找到该位置（从指定的位置开始播放）。 媒体正在播放的情况下，如果媒体缓冲区的数据已经过期（视频已经播放完），则user agent有可能无法正常拿到数据。有些媒体可能有一个不以0秒开始的媒体时间线（不是从头开始播放的），因此应该将currentTime的时间设置在其数据失效之前。getStartDate()这个方法可以用来确定媒体时间线起始的坐标。 document.querySelector('video').currentTime = 100 实测，By lizhao，2020.06.07： 1.直接在元素写currentTime属性，有兼容问题，有些浏览器可以无效，如：chrome\\安卓微信。 2.只有视频开始播放后设置的currentTime才有效。 3.不能canplay事件中使用：会陷入死循环。 disablePictureInPicture：防止浏览器建议图片中的上下文菜单或在某些情况下自动请求图片中的图片。 disableRemotePlayback：一个布尔属性，用于禁用使用有线连接的设备(HDMI、DVI等)的远程播放功能。无线技术(Miracast、Chromecast、DLNA、AirPlay等)。 duration（只读）：一个双精度浮点值，它指示媒体的持续时间(总长度)，以秒为单位，在媒体的时间线上。如果元素上没有媒体，或者媒体无效，则返回的值为NaN。如果媒体没有已知终点(例如时间未知的实时流、网络广播、来自WebRTC的媒体等等)，那么这个值就是Infinity。 document.querySelector('video').duration height：视频展示区域的高度，单位是CSS像素。 intrinsicsize： 此属性将覆盖媒体元素的实际固有大小。具体来说，图像将在这些尺寸处进行光栅化，图像上的naturalWidth / naturalHeight 将返回在此属性中指定的值。在视频元素上，视频将以此大小进行光栅化，而视频 上的videoWidth / videoHeight将返回固有大小值。 请确保启用Experimental Web Platform features标志。chrome中输入chrome://flags/，搜索该标志并设置为enabled。 注：chrome中实测无效。By lizhao，2020/05/29。 loop：布尔属性，设置循环播放。指定后，会在视频结尾的地方，自动返回视频开始的地方，重新播放。 muted：布尔属性，指明了视频里的音频的默认设置。设置后，音频会初始化为静音。默认值是false，意味着视频播放的时候音频也会播放 。 document.querySelector('video').muted = true 直接在video写muted属性，有兼容问题 playsinline： 一个布尔属性，标志视频播放时局域播放，不脱离文档流 。请注意，没有此属性并不意味着视频始终是全屏播放的。 playsinline是标准写法 webkit-playsinline在iOS 10 之前的写法，它的浏览器厂商前缀在iOS 10 中被移除。但是目前 iOS微信还不支持去掉前缀的写法。 x5-playsinline是X5内核的写法（微信、QQ浏览器等腾讯产品的内核） playsinline属性比较特别， 需要嵌入网页的APP，比如wechat中UIwebview的allowsInlineMediaPlayback = YES、webview.allowsInlineMediaPlayback = YES，才能生效。 换句话说，如果APP不设置，你页面中加了这标签也无效，这也就是为什么安卓手机WeChat播放视频总是全屏，因为APP不支持playsinline，而ISO的WeChat却支持。 在iOS 10 Safari中，通过可以让视频内联播放。设置了 playsinline属性的视频在播放时不会自动全屏，但用户可以点击全屏按钮来手动全屏；没有设置 playsinline的视频会在播放时自动全屏。无论是否设置 playsinline属性，退出全屏后视频都会继续播放。 注意：如果是想做全屏直播或者全屏H5体验的用户，IOS需要设置删除 webkit-playsinline 标签，因为你设置 false 是不支持的 ，安卓则不需要，因为默认全屏。但这时候全屏是有播放控件的，无论你有没有设置control。 played：返回 TimeRanges对象。TimeRanges对象表示用户已经播放或看到的视频范围。 已播范围指的是被播放视频的时间范围。如果用户在视频中跳跃，则会获得多个播放范围。 document.querySelector('video').played.length //已播放的范围个数 document.querySelector('video').played.start(0) //第一段的开始时间 document.querySelector('video').played.end(0) //第一段的结束时间 preload： 该枚举属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么。可能是下列值之一： none: 提示作者认为用户不需要查看该视频，服务器也想要最小化访问流量；换句话说就是提示浏览器该视频不需要缓存。 metadata: 提示尽管作者认为用户不需要查看该视频，不过抓取元数据（比如：长度）还是很合理的。 auto: 用户需要这个视频优先加载；换句话说就是提示：如果需要的话，可以下载整个视频，即使用户并不一定会用它。 空字符串：也就代指 auto 值。 假如不设置，默认值就是浏览器定义的了 （即，不同浏览器会选择自己的默认值），即使规范建议设置为 metadata。 使用备注： autoplay 属性优先于 preload。假如用户想自动播放视频，那么很明显浏览器需要下载视频。同时设置autoplay 和 preload属性在规范里是允许的。 规范没有强制浏览器去遵循该属性的值；这仅仅只是个提示。 poster：一个海报帧的URL，用于在用户播放或者跳帧之前展示。如果属性未指定，那么在第一帧可用之前什么都不会展示；之后第一帧就像海报帧一样展示。 poster，在不同环境下有兼容问题 readyState：返回音频/视频的当前就绪状态。就绪状态指示音频/视频是否已准备好播放。表示音频/视频元素的就绪状态： HAVE_NOTHING 0 没有关于音频/视频是否就绪的信息 HAVE_METADATA 1 音频/视频已初始化 HAVE_CURRENT_DATA 2 数据已经可以播放(当前位置已经加载) 但没有数据能播放下一帧的内容 HAVE_FUTURE_DATA 3 当前及至少下一帧的数据是可用的(换句话来说至少有两帧的数据) HAVE_ENOUGH_DATA 4 可用数据足以开始播放-如果网速得到保障 那么视频可以一直播放到底 seeking：返回用户目前是否在音频/视频中寻址。寻址中（Seeking）指的是用户在音频/视频中移动/跳跃到新的位置。 src：要嵌到页面的视频的URL。可选；你也可以使用video块内的元素来指定需要嵌到页面的视频。 volume： 设置或返回音频/视频的音量 width：视频显示区域的宽度，单位是CSS像素。 以下为非标准属性： x-webkit-airplay：IOS webkit属性，支持Airplay的设备（如：音箱、Apple TV)播放。这个属性应该是使此视频支持ios的AirPlay功能。通过AirPlay可以把当前的视频投放到支持此技术的其他设备上。 x5-video-player-type： 功能：启用同层H5播放器。 可选值：h5-page 特点：在视频全屏的时候（即不加x5-playsinline=\"true\"属性），页面中元素可以呈现在视频层上，也是WeChat安卓版特有的属性 x5-video-orientation： 功能：声明播放器支持的方向 可选值： landscape横屏, portraint竖屏 默认值：portraint //横屏 //竖屏 //跟随手机自动旋转 注： 此属性只在声明了x5-video-player-type=”h5”情况下生效 x5-video-player-fullscreen： 功能：视频播放时将会进入到全屏模式。 可选值：true支持全屏播放，false不支持全屏播放 默认值：false 如果不申明此属性，页面得到视口区域为原始视口大小(视频未播放前)，比如在微信里，会有一个常驻的标题栏，如果不声明此属性，这个标题栏高度不会给页面，播放时会平均分为两块（上下黑块） 注： 声明此属性，需要页面自己重新适配新的视口大小变化。可以通过监听resize 事件来实现 video的方法 addTextTrack：向音频/视频添加新的文本轨道。 注：所有主流浏览器都不支持 addTextTrack()方法。 document.querySelector('video').addTextTrack(kind,label,language) canPlayType：检测浏览器是否能播放指定的音频/视频类型，返回String。如下： probably：浏览器最可能支持该音频/视频类型 maybe：浏览器也许支持该音频/视频类型 \"\" ： （空字符串）浏览器不支持该音频/视频类型 document.querySelector('video').canPlayType('video/mp4') load：重新加载音频/视频元素 document.querySelector('video').load() play：开始播放音频/视频 document.querySelector('video').play() pause：暂停当前播放的音频/视频 document.querySelector('video').pause() video的事件 事件名称 描述 abort 在播放被终止时触发。例如：当播放中的视频重新开始播放。 canplay 在媒体数据已经有足够的数据（至少播放数帧）可供播放时触发。 canplaythrough 表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。注意：手动设置currentTime会使得firefox触发一次canplaythrough事件，其他浏览器或许不会如此。 durationchange 表明媒体的长度发生了改变。例如：在媒体已被加载足够的长度从而得知总长度时会触发这个事件。 emptied 媒体被清空（初始化）时触发。 ended 播放结束时触发。 error 在发生错误时触发。元素的error属性会包含更多信息。参阅 HTMLMediaElement.error 获得详细信息。 loadeddata 媒体的第一帧已经加载完毕。 loadedmetadata 媒体的元数据已经加载完毕，现在所有的属性包含了它们应有的有效信息。 loadstart 在媒体开始加载时触发。 mozaudioavailable 当音频数据缓存并交给音频层处理时 pause 播放暂停时触发。 play 在媒体回放被暂停后再次开始时触发。即：在一次暂停事件后恢复媒体回放。 playing 在媒体开始播放时触发（不论是初次播放、在暂停后恢复、或是在结束后重新开始）。 progress 告知媒体相关部分的下载进度时周期性地触发。有关媒体当前已下载总计的信息可以在元素的buffered属性中获取到。 ratechange 在回放速率变化时触发。 seeked 在跳跃操作完成时触发。 seeking 在跳跃操作开始时触发。 stalled 在尝试获取媒体数据，但数据不可用时触发。 suspend 在媒体资源加载终止时触发，这可能是因为下载已完成或因为其他原因暂停。 timeupdate 元素的currentTime属性表示的时间已经改变。 volumechange 在音频音量改变时触发（既可以是volume属性改变，也可以是muted属性改变）。 waiting 在一个待执行的操作（如回放）因等待另一个操作（如跳跃或下载）被延迟时触发。 source HTML元素为、、元素指定多个媒体资源。 这是一个空元素。它通常用于以不同浏览器支持的多种格式提供相同的媒体内容。 track HTML元素 被当作媒体元素—和的子元素来使用。它允许指定时序文本字幕（或者基于时间的数据），例如自动处理字幕。字幕格式有 WebVTT格式（.vtt格式文件）— Web 视频文本字幕格式，以及指时序文本标记语言（TTML）格式。 default属性：该属性定义了该track应该启用，除非用户首选项指定了更合适一个track。每个媒体元素里面只有一个 track 元素可以有这个属性。 kind属性： 定义了 text track 应该如何使用。如果省略了该属性，默认的 kind 值就是 subtitles。 subtitles。字幕给观影者看不懂的内容提供了翻译。比如英文电影里非英文的对话框或者文字。字幕可能包含额外的内容，通常有附加的背景信息。比如在电影星球大战开头的文字，或者某个场景的日期，时间，还有地点。 captions。隐藏式字幕提供了音频的转录甚至是翻译。可能包含重要的非言语的信息，比如音乐提示或者音效。可以指定提示音的源文件 (e.g. music, text, character)。适用于耳聋的用户或者当调成静音的时候。 descriptions。视频内容的文本描述。适用于失明用户或者当视频不可见的场景。 chapters。章节标题。用于用户浏览媒体资源的时候。 metadata。脚本使用的track。 对用户不可见。 label属性：当列出可用的text tracks时，给浏览器使用的text track的标题，这种标题是用户可读的。 src属性：track的地址。必须是合法的URL。该属性必须定义。 srclang属性： track文本数据的语言。它必须是合法的 BCP 47 语言标签。如果 kind 属性被设为 subtitles, 那么srclang 必须定义。如 zh中文 zh-cmn 中文普通话 zh-Hans （简体字） zh-yue（广东话） zh-Hant-HK （香港使用繁体中文） zh-cmn-Hans 中文普通话简体 en （英语） en-GB （英式英语） 一个media 元素的任意两个 track 子元素不能有相同的 kind, srclang, 和 label属性。 注意：元素是 HTML5 中的新元素。需注意其兼容性 WebVTT Web 视频文本轨格式（WebVTT） Web视频文本跟踪格式 (WebVTT) 是一种使用元素显示定时文本轨道（如字幕或标题）的格式。 WebVTT文件的主要用途是将文本叠加添加到。 WebVTT是一种基于文本的格式，必须使用UTF-8进行编码。 在可以使用空格的地方，您也可以使用制表符。 还有一个小的API可用于表示和管理这些轨道以及在正确的时间执行文本回放所需的数据。 WebVTT 文件的 MIME 类型为 text/vtt。 一个 WebVTT 文件（.vtt） 包含任意条带时间的提示性内容（cue）（可理解为一条或多条字幕），可以是单行或多行，如下所示： WEBVTT 美人谷 00:02.000 --> 00:05.000 美人谷 - 阿兰 00:07.950 --> 00:15.760 词：毛慧 曲：阿兰/毛慧 编曲：叶月/王晨 制作人：毛慧 录音：张生磊（记忆时刻录音棚） 00:38.130 --> 00:44.180 越过山河的神秘 幕自然的洗礼 看见山川出云泽被着大地 ... 可以修改字幕样式： /*写在css文件中*/ video::cue { background-image: linear-gradient(to bottom, dimgray, lightgray); color: papayawhip; } video::cue(b) { /*表示.vtt中，标签内文本的样式*/ color: peachpuff; } /*写在.vtt文件中*/ ... STYLE ::cue { background-image: linear-gradient(to bottom, dimgray, lightgray); color: papayawhip; } 00:38.130 --> 00:44.180 越过山河的神秘 幕自然的洗礼 看见山川出云泽被着大地 ... 自动播放 早期的安卓和IOS都需要用户手势才能自动播放，后期逐渐放宽的自动播放的策略，逐渐开始支持自动播放，当然在不同的机型和对应的浏览器上，展示略有差异，这个没有完全清楚所有机型展示情况。 检测当前的浏览器是否能支持自动播放： let promise = document.querySelector('video').play(); if (promise !== undefined) { promise.then(() => { // video can play }).catch(err => { // video cannot play }) } 移动端应用中内嵌的浏览器（如：wkWebView），有参数控制是否允许自动播放。因此，不同的应用下，展示情况略有差异。比如：钉钉可以支持，但是微信就禁止。 微信提供了内置的事件来支持自动播放： //实测：iPhone 11 Pro的微信可以自动播放；小米10的微信无法自动播放。By lizhao，2020/06/07 //必须加载JSAPI的JS文件。如：http://res.wx.qq.com/open/js/jweixin-1.2.0.js document.addEventListener(\"WeixinJSBridgeReady\", function (){ document.querySelector('video').play(); }, false) Chrome自动播放 实测：By lizhao，2020/05/30 使用muted属性后，可以自动播放。 Android自动播放 小米10实测：By lizhao，2020/05/30 UC浏览器、微信不支持自动播放（无论是否设置muted属性），video设置 autoplay属性和JS调用play()方法都一样无效。QQ浏览器支持自动播放（无论是否设置muted属性） IOS自动播放政策 IOS 8自动播放政策 允许使用 preload=\"metadata\"来预加载视频 Meta信息，但无法自动播放，也无法内联播放，只能在【用户主动操作】后才能播放，且播放时必须全屏。 至于「用户主动操作」具体指的是哪些行为，苹果官方有详细的说明： 点击视频播放按钮； 触发 touchend、click、doubleclick 、 keydown 事件，且在事件处理函数中直接调用 video.play()方法。 显然，button.addEventListener('click', () => { video.play(); })满足要求；而 video.addEventListener('canplaythrough', () => { video.play(); })不满足要求； 值得注意的是：上面讨论的是 IOS自带 Safari的视频播放政策。对于IOS APP 而言，开发者在给 webview设置 mediaPlaybackRequiresUserAction和 allowsInlineMediaPlayback属性之后，页面中的 标签就可以通过 autoplay和webkit-playsinline 属性来启用自动播放和内联播放功能。 IOS 10自动播放政策 随着视频的进一步普及，在IOS 10 中，苹果终于进一步放松了 Safari视频播放政策。IOS 10 Safari允许自动播放以下两种视频： 无音轨视频； 无声音视频（设置了 muted 属性）； 对于这两种类型的视频，可以通过或video.play()两种方式来自动播放，无需用户主动操作。但是，如果它们在播放时变得有声音（获取了音轨，或者 muted 属性被取消），Safari 会暂停播放。 通过 自动播放的视频元素还需要满足一个条件：在可视区域内。同样，如果它们在播放时因为页面滚动等原因导致不可见，Safari也会暂停播放。 全屏/局域播放 全屏和局域播放的区别主要在于： 全屏播放：一般是调用系统的native播放器来打开全屏观看，覆盖在webview之上，即，播放界面位于所有页面元素的上方，并且控制条无法隐藏。Android和IOS，在微信环境下打开，默认都是全屏播放。 局域播放：视频是在文档内播放的，即，可以在视频上方显示html元素。video不加controls属性，可以隐藏控制条（实测：微信内置浏览器、QQ浏览器、UC浏览器。By lizhao，2020/05/30）。 IOS全屏处理： 全屏播放：IOS默认打开的是全屏模式。 局域播放：video设置 webkit-playsinline='true'属性。 Android全屏处理： 全屏播放：微信默认全屏播放，QQ、UC浏览器默认局域播放。 小米10实测：By lizhao，2020/05/30 微信、QQ浏览器，横屏的全屏状态下，点击【旋转】，回到竖屏状态，页面样式有问题；UC浏览器旋转正常。 局域播放：video设置x5-playsinline=\"true\"。 同层播放：video设置x5-video-player-type：h5-page。 同层全屏播放：video不设置x5-playsinline属性，设置x5-video-player-type：h5-page。 同层全屏形态下的控件前端可以自定义，native形态不支持自定义。native形态播放器是处于顶层的独立view会遮盖视频区域的其它元素。 伪全屏：采用局域播放状态，即video标签设置playsinline（注意兼容问题，具体可查看上文playsinline属性），通过设置样式和布局将视频内容撑满屏幕。应用场景：视频播放区域占满手机屏幕，视频上方需要显示弹幕、评论区等。 CSS实现控制条隐藏：在video外层套一个div，height设置固定值，并且设置overflow:hidden，video的高度设置为大于外层的高度，就能把控制条顶到视窗外。注意：这个时候对于video可能会造成放大，视频要留有一定的安全区，防止遮挡主体内容。 video播放的控制 video元素有提供多个行为事件供开发者控制视频播放，兼容性比较好的有 onended 、 ontimeupdate、onplay、onplaying等，有些事件在不同浏览器不同设备上的的表现情况并不一致，不同的系统，设备，浏览器显示的特性还是很不一样的，还是看业务场景需要兼容到什么样，尽量不要大量处理这些事件，不然用户去浏览的时候，兼容问题较多。 进入全屏的事件： //腾讯浏览器：进入/退出全屏事件（支持版本: TBS中从>=036900开始支持，QB中是>=7.2开始支持）： video.addEventListener(\"x5videoenterfullscreen\", () => { console.log(\"进入全屏通知\"); }) video.addEventListener(\"x5videoexitfullscreen\", () => { console.log(\"退出全屏通知\"); }) //IOS 微信：进入/退出全屏的事件： video.addEventListener(\"webkitbeginfullscreen\", () => { console.log(\"进入全屏通知\"); }) video.addEventListener(\"webkitendfullscreen\", () => { console.log(\"退出全屏通知\"); }) // 监听暂停事件 video.addEventListener('pause', () => { console.log('暂停了') }) // 监听停止事件 video.addEventListener('ended', () => { console.log('停止了') }) 事件在不同环境的表现： vent pc侧 IOS Android loadstart 文件加载，video初始化，未加载任何数据 一致 一致 stalled 视频没有播放，没有取回任何媒介数据：一般是由于网络状况不佳，导致视频下载中断 一致 可能在play()事件触发前 play 触发后，状态是开始播放，但视频并未真正开始播放 一致 一致 waiting play()事件触发后，等待数据 一致 一致 durationchange 获取到视频长度，duration属性能获得真实视频长度 一致 可能在play()事件触发前，可能没有获取到真实的视频长度：可能触发多次， 只有最后一次才能获取到真实的duration，之前的值有可能为0或者1 loadedmetadata play()事件触发后，获取到元数据 一致 play()事件触发前，没有获取到真实的元数据 loadeddata play()事件触发后，获取到媒介数据 一致 play()事件触发前，没有获取到真实的媒介数据 canplay 可以播放，但视频可能还未真正开始播放，并且中途可能因为加载而暂停 一致 一致 playing 视频开始播放 一致 可能还未真正开始播放，并且可能还未获取到视频长度 canplaythrough 视频开始播放后，可以流畅播放 一致 数据可能还没有开始加载，视频可能还未开始播放， 视频仍然会卡住 timeupdate 视频播放后，更新播放进度， 会有明确的进度变化，可以获取到currentTime 一致 第一次可能会有误差，如果 timeupdate事件的currentTime发生变化，代表视频一定开始播放 progress 视频播放后，持续下载， 可以获取到当前的缓存buffer，并且全部下载完毕后不再触发 一致 第一次可能会有误差， 全部下载完毕后依然继续触发 suspend 缓冲中，视频可能卡顿也可能在流畅播放中，全部缓存完毕后不再触发。视频还未真实播放前，pause()事件会触发suspend 一致 一致 pause 可能是响应pause()事件暂停，或者是切出页面自动暂停 一致 一致 seeking 拖动进度条时，寻找播放位置。或者播放完毕，寻找下一个视频 一致 一致 seeked 拖动进度条时，定位到播放位置。或者开始播放下一个视频，或者是从头开始循环播放 一致 一致 error 错误，无法定位错误原因，无法通过paly()事件继续播放 一致 一致 关于X5内核的一些问题 微信内置浏览器的内核： Android：微信6.1版本以上都是使用的QQ浏览器的X5内核。5.4-6.1之间的版本，若用户安装了QQ浏览器就是使用的X5内核，若用户未安装浏览器，使用的是系统内核。 IOS：采用WKWebview或UIWebview内核，从IOS8开始支持WKWebview。 最简单的检测X5内核方法：打开一个网页，然后下拉。页面顶部有【QQ浏览器X5内核提供技术支持】，表明用的是X5内核；没有表示非X5内核。 关闭/禁用/安装X5内核： 微信端打开 http://debugtbs.qq.com，进入X5内核的调试页面。 若未安装X5内核，此链接打不开。已安装，可点击左上方【查看版本号】，如果内核版本信息显示为0的话，就表示X5内核已经被关闭了。 点击【安装线上内核】，在下载或者安装过程中强行关闭微信，就可以禁用X5内核了。 安装X5内核：可以打开https://debugmm.qq.com/?forcex5=true安装 关闭X5内核不会导致微信出问题，甚至会让微信整体更加流畅，因为微信某些原生框架也是需要借助Webview来实现的。 X5内核的视频播放形态： 全屏播放 X5内核视频默认播放形态，用户点击视频区域后开始进入全屏播放，视频区域内的所有事件行为会由X5内核视频组件全权托管。视频层级最高，会遮挡所在区域所有html元素。（仅使用于安卓微信、手机QQ等非安卓QQ浏览器的X5内核场景） 页面内播放 X5内核视频在用户点击后默认会进入全屏播放，前端可以设置video的x5-playsinline属性来将视频限定于网页内部播放 同层页面内播放 同层页面内播放是标准的视频播放形态，在video标签中添加x5-video-player-type：h5-page属性来控制网页内部同层播放，可以在视频上方显示html元素。 X5内核的一些特性： X5内核竖屏播放视频时，横置手机会自动切到横屏全屏播放，但再竖屏时，视频无法切回来。这个是产品策略，需要用户点击全屏上的返回按钮后返回到竖屏。 X5内核不支持多个视频同时播放、不技持视频与音频同时播放 同层全屏形态时不会盖住网页上的html元素；native形态播放器是处于顶层的独立view会遮盖视频区域的其它元素。 x5内核video的currentTime，只有视频开始播放后设置才有效 X5内核的视频播放不支持字幕功能 音视频同步播放 需求背景：同一视频面向不同客户时，根据具体的客户信息，将音轨中的一段内容替换（比如：音轨中的【先生，您好】，替换成具体姓氏【李先生，你好】）。 实现思路： 思路一：服务端根据不同的客户信息，直接处理视频中的音轨。（不可行） 原因：处理速度太慢。以40M的视频为例，视轨、音轨分离 -> 修改音轨 -> 合成视轨、音轨 -> 上传合成后的视频文件，整个流程跑完，大概3分钟。 思路二：将视频拆分成一个没有声音的视频文件和一个音频文件，服务端只对音频文件处理；前端同时播放一个视频和一个音频，并保持两者同步。（可行，需要解决的问题如下） 问题一：安卓微信中不支持同时播放一个视频和一个音频 这是X5内核的限制。目前大多安卓机的微信浏览器采用的是X5内核（可以禁用微信X5内核，但，很显然，我们不可能要求客户这么做。。。）。 解决方法调研： 视频折分成多个小视频，前端串行播放（体验不好） 实现思路：视频折分成多个小视频，服务端只需要处理其中一个小视频，处理速度可以控制在合理范围。 问题：多段视频串行播放，在播放下一个视频时，会有停顿（停在前一视频的海报画面，等待下一视频加载）；播放进度控制问题。 canvas播放视频（不可行） 实现思路：用canvas播放视频代替video元素。 问题：canvas播放视频是通过页面重绘事件或者定时器，不停的抓取video每帧的画面，即，它是依赖video元素的。 适用场景：用于对video的画面进行一此处理，如同步模糊背景、视频截图、灰色视频。 Web audio API播放音频（可行，下一节将详细介绍） 实现思路：用Web audio API代替audio元素。 其他标签代替video、audio （不可行） 实现思路：embed或object代替video、audio元素。embed和object都是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像Java小程序和Flash，PDF这样的插件技术，甚至像视频，SVG和图像的内容！ 问题：embed、object播放视频或音频，类似在页面中嵌入一个包含video或audio元素的iframe。 无法避开不支持音频、视频同时播放的问题 音频控制不方便 播放会出现控制界面。android可以小窗口播放，IOS会占满全屏。 有些属性不可用。比如：embed的starttime 小程序 （暂未调研） 实现思路：取决于小程序是否放开不能同时播放视频和音视的限制。 问题二：视频和音视的同步播放 主要在于三点： 一：视频和音视同时开始播放 视频和音频的加载所需时间不一样，需要等两者都可以播放了，才能真正开始播放。 实现：在canplay事件标识视频、音频是否可播，再通过定时器轮询，监听两者都可播放时，再触发播放。 注意：部分机型，需要【用户主动操作】才能播放视频，直接在定时器中调用play()方法可能无效。解决方法是：在点击时，先触发一次播放，再在定时器中加暂停或播放的判断。 二：拖动进度条后，保持视频和音视同步 拖动进度条后，改变currentTime的值，也会引起视频和音频的加载所需时间不一样的问题，而此时无法通过canplay事件解决，因为IOS在currentTime改变后不会触发canplay事件。 这时，我们可以用seeked事件监听视频、音频是否加载完成。 canplay、seeked事件的兼容情况（实测：一台IOS机、一台android机）： 事件 IOS app IOS WeChat android app android wechat canplay（开始播放） 触发 触发 触发 触发 canplay（改currentTime后） 不触发 不触发 触发 触发 seeked 触发 触发 触发 触发 三：视频和音视不同步，纠正时差 正常来说，第一次播放、拖动进度条后的播放都是两者加载完成后同时播放的，视、音频应该不会出现时差。然而，现实是残酷的，部分机型还是出现了时差，有时还可能偏差几十秒（具体原因未知）。 这时，我们需要一个定时器实时监听两者的时差。当两者时差超过某个阈值时（如：0.5s），纠正音频的currentTime值。 问题三：无音轨视频文件的问题 部分IOS手机播放无音轨视频，需要等待很长时间才会开始播放（android、pc chrome无此问题）。 以40M的视频为例：无音轨的视频，必需等视频加载30多M（约20~30秒，跟网速有关）后，才开始播放；而同一视频，保留音轨（不需要声音，可以将音量调为0），加载1M~2M就可以开始播放。原因未知 Web Audio API 安卓微信（采用X5内核）不支持同时播放一个视频和一个音频，即，video、audio不能同时播放。调研发现，web audio api可以控制音频，可以替代audio，且它与video可以同时播放。 简单示例 const URL = 'path/music.mp3' const audioContext = new (window.AudioContext || window.webkitAudioContext)() //加载音频文件 const getBuffer = function (url) { const request = new XMLHttpRequest(); return new Promise((resolve, reject) => { request.open('GET', url, true); request.responseType = 'arraybuffer'; request.onload = () => { audioContext.decodeAudioData(request.response, buffer => buffer ? resolve(buffer) : reject('decoding error')); }; request.onerror = error => reject(error); request.send(); }); }; const playAudio = function (buffer) { const source = audioContext.createBufferSource(); source.buffer = buffer; source.connect(audioContext.destination); source.start(); }; const buffer = await getBuffer(URL); buffer && playAudio(buffer) 一些问题： currentTime：不是当前音频播放的时间节点，而是当前时间 - 音频上下文创建时间点的时长。 如何修改音量、设置静音？？（按标准文档中的方法试了，有问题） 有些浏览器限制，页面最多只能同时存在6个音频上下文，即最多可以new AudioContext()6次。可用音频上下文的close()方法，及时关闭无用的音频上下文。 https://github.com/otalk/hark/issues/38 部分机型（如：乐视 android 6.0），app端无法正常播放（微信端正常）。原因是：decodeAudioData方法无法解码音频数据。 部分机型（如：vivo X7 android 5.1.1），不支持Howler插件。 Howler是一款web audio api的封装插件。 兼容问题 视频、音频的播放\\暂停行为 切出应用 -> 再切换回来、锁屏 -> 解屏，video、audio、web audio api的播放/暂停行为不一致，体现在不同系统（IOS、Android）、不同应用（微信、保险师）中，如： 切出微信时，video会自动停止播放，而audio仍在播放。当然，并不是所有机型都如此，Android中腾讯X5浏览器处理的就比较完善，在切出后台时，video、audio会停止播放并且切回页面后自动续播。 切换出应用，部分机型中web audio api不会停止播放，即使在visibilitychange事件，调用stop方法也无法停止。 切换回应用，部分机型（如：华为 P30 android 9）中，video自动续播，web audio api不会。 解决方法： 对于切出微信，audio不停止播放的问题，可以在visibilitychange事件中，调用pause方法来暂停。 浏览器标签页被隐藏或显示的时候会触发 visibilitychange事件，可以通过Document.visibilityState 只读属性来获取当前标签页在浏览器中的激活状态： document.addEventListener(\"visibilitychange\", e => { //用户离开了当前页面 if (document.visibilityState === 'hidden') { video.pause() } // 用户打开或回到页面 if (document.visibilityState === 'visible') {} //或者 if (e.target.hidden) {} }) 另外，对于切换回应用，video、audio、web audio api的播放/暂停行为不一致，可以考虑在visibilitychange事件中，document.visibilityState === 'visible'时，刷新页面或更新音、视频模块。 其他属性、事件的兼容问题 canplay、canplaythrought事件 IOS在加载时不会触发这两个方法，即使preload=\"auto\"也没用，需要播放后才会触发。readyState也是播放后，才能取到值的。而Android、PC端Chrome是会在加载阶段就触发这两个事件。 修改video的currentTime值，android会触发canplay事件，但IOS不会。 loadedmetadata事件 安卓微信（华为 meta 8）：取回的duration\\videoWidth\\videoHeight值为0。 解决方法：在timeupdateg事件中获取duration\\videoWidth\\videoHeight值 muted属性 部分安卓机（如：华为 meta 8）的微信中：video标签中写了muted属性后，通示Js切换muted的值，无效。 解决方法：video标签不设置muted属性，在页面初始化时，用Js对muted赋值。 volume属性 IOS中无法通过volume属性修改视频音量，直接写在video标签或者js修改都不行。 poster属性 在不同设备上表现不同，浏览器没问题，但是微信浏览器和IOS可能会显示空白。 解决方案一 ：自定义一个div，将封面放在div中，然后div盖在video的上面。 解决方案二：通过canvas截取视频第一帧作为默认显示的图片。 function cut () { let canvas = document.createElement(\"canvas\"); canvas.width = video.videoWidth * scale; canvas.height = video.videoHeight * scale; canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height); let img = document.createElement(\"img\"); img.src = canvas.toDataURL(\"image/png\"); Dom.appendChild(img); }; video.addEventListener('loadeddata',cut) 安卓手机的一些问题： 视频播放结束后，可能会有广告弹出 解决方法：在视频播放完成事件中添加，先播放视频再暂停视频即可 let isiOS = !!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/) let video = document.getElementById('video'); video.addEventListener('ended', () => { if (!isiOS) { video.play(); setTimeout(() => { video.pause(); }, 100) } } Android微信端（如：小米 10），局域播放状态下，有【全屏】按钮 这个是X5做了video劫持的结果，目前解决方法（网上搜索答案）： 成为腾讯的合作伙伴 将视频的 width撑大，如：width: 120%；然后再用 object-position 将画面通过计算居中显示，两边裁剪 参考链接 MDN video 视频H5 video标签最佳实践 iOS 10 Safari 视频播放新政策 video标签在不同平台上的事件表现差异分析 video在安卓与ios实际应用中遇到的问题及解决 腾讯-H5同层播放器接入规范 腾讯-X5内核视频之问答汇总 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:15:10 "},"html探索系列/_关于html.html":{"url":"html探索系列/_关于html.html","title":" 关于Html","keywords":"","body":"关于html 什么是HTML？ HTML（英语：Hyper Text Markup Language，简称：HTML ）也叫作超文本标记语言，是一种使用结构化 Web 网页及其内容的标记语言。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/00-JS基础知识.html":{"url":"js探索系列/00-JS基础知识.html","title":"JS基础知识","keywords":"","body":"JS基础知识 控制页面滚动 H5 页面上的滚动，可分为窗口滚动和元素（加了overflow: scroll | auto）滚动。 JavaScript 有以下方法和属性可以控制页面滚动： 常用的滚动方法 scrollTo 使界面滚动到给定元素的指定坐标位置。 scrollTo(x-coord, y-coord) scrollTo(options) scroll 使界面滚动到给定元素的指定坐标位置。window.scrollTo 实际上和该方法是相同的。 window.scroll(x-coord, y-coord) window.scroll(options) scrollBy 使页面相对当前的位置滚动多少距离。 window.scrollBy(x-coord, y-coord) window.scrollBy(options) x-coord 是期望滚动到位置水平轴上距元素左上角的像素 y-coord 是期望滚动到位置竖直轴上距元素左上角的像素 options 是一个 ScrollToOptions 对象。 top：指定 window 或元素 Y 轴方向滚动的像素数。 left：指定 window 或元素 X 轴方向滚动的像素数。 behavior：指定滚动是否应该平滑进行，还是立即跳到指定位置。取值：smooth (平滑滚动) | instant (瞬间滚动) | auto。默认值 auto，效果等同于 instant。 scrollIntoView 让当前的元素滚动到浏览器窗口的可视区域内。 element.scrollIntoView(); // 等同于element.scrollIntoView(true) element.scrollIntoView(alignToTop); // Boolean型参数 element.scrollIntoView(scrollIntoViewOptions); // Object型参数 alignToTop：一个 Boolean 值。true 表示元素的顶端将和其所在滚动区的可视区域的顶端对齐；false 表示元素的底端将和其所在滚动区的可视区域的底端对齐。 scrollIntoViewOptions：一个包含下列属性的对象： behavior：定义动画过渡效果。取值：auto | smooth。默认为 auto。 block：定义垂直方向的对齐。取值：start | center | end | nearest。默认为 start。 inline：定义水平方向的对齐。取值：start | center | end | nearest。默认为 nearest。 这是一个实验中的功能 此功能某些浏览器尚在开发。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 常用的滚动属性 scrollLeft 读取或设置元素滚动条到元素左边的距离。 Element.scrollLeft 注意：如果这个元素的内容排列方向 direction 是rtl (right-to-left) ，那么滚动条会位于最右侧（内容开始处），并且scrollLeft值为0。此时，当你从右到左拖动滚动条时，scrollLeft会从0变为负数。 scrollLeft 可以是任意整数，然而： 如果元素不能滚动（比如：元素没有溢出），那么scrollLeft 的值是0。 如果给scrollLeft 设置的值小于0，那么scrollLeft 的值将变为0。 如果给scrollLeft 设置的值大于元素内容最大宽度，那么scrollLeft 的值将被设为元素最大宽度。 scrollTop 获取或设置一个元素的内容垂直滚动的像素数。 Element.scrollTop 一个元素的 scrollTop 值是这个元素的内容顶部（卷起来的）到它的视口可见内容（的顶部）的距离的度量。 其他与 scrollLeft 类似。 其他方法 window.scrollByLines()： 按给定的行数滚动文档。注：目前仅Firefox浏览器支持。 window.scrollByPages()： 在当前文档页面按照指定的页数翻页。注：目前仅Firefox浏览器支持。 注意问题 低版本 IE 浏览器可能不支持 scrollTo()、scrollBy() 等方法。 scrollTo()、scrollBy()、scrollBy() 都可以用于 window 和 element 控制滚动。 但部分手机（比如：华为 麦芒4，系统版本：6.0.1），不支持 element.scrollTo()。可以使用 element.scrollLeft 属性。 window 对象没有 scrollTop 、scrollLeft 属性，但可以用 document.documentElement.scrollTop、document.documentElement.scrollLeft 实现窗口滚动。 蒙层底部页面跟随滚动 弹窗是一种常见的交互方式，而蒙层是弹窗必不可少的元素，用于隔断页面与弹窗区块，暂时阻断页面的交互。但是，在蒙层元素中滑动的时候，滑到内容的尽头时，再继续滑动，蒙层底部的页面会开始滚动，显然这不是我们想要的效果，因此需要阻止这种行为。 解决方案一 打开蒙层时，给body添加样式： /*在某些机型下，你可能还需要给根节点添加此样式。关闭蒙层时，移除些样式*/ body { height: 100%; overflow: hidden; } 优点：简单方便，只需添加css样式，没有复杂的逻辑。 缺点：兼容性不好，适用于pc，移动端就尴尬了。部分安卓机型以及safari中，无法无法阻止底部页面滚动。 解决方案二 就是利用移动端的touch事件，来阻止默认行为（这里可以理解为页面滚动就是默认行为）。 // node为蒙层容器dom节点 node.addEventListener('touchstart', e => { e.preventDefault() }, false) 简单粗暴，滚动时底部页面也无法动弹了。假如你的蒙层内容不会有滚动条，那么上述方法prefect。 但是，最怕空气突然安静，假如蒙层内容有滚动条的话，那么它再也无法动弹了。因此我们需要写一些js逻辑来判断要不要阻止默认行为，复杂程度明显增加。 具体思路：判定蒙层内容是否滚动到尽头，是则阻止默认行为，反之任它横行。 解决方案三(推荐使用) 具体思路：要阻止页面滚动，那么何不将其固定在视窗（即position: fixed），这样它就无法滚动了，当蒙层关闭时再释放。 当然还有一些细节要考虑，将页面固定视窗后，内容会回头最顶端，需要记录一下同步top值。 let top = 0 function stopBodyScroll (isFixed) { let bodyEl = document.body if (isFixed) { top = window.scrollY bodyEl.style.position = 'fixed' bodyEl.style.top = -top + 'px' } else { bodyEl.style.position = '' bodyEl.style.top = '' window.scrollTo(0, top) // 回到原先的top } } iphone X 适配问题 安全区域 iPhoneX 取消了物理按键，改成底部小黑条，这一改动导致网页出现了比较尴尬的屏幕适配问题。对于网页而言，顶部（刘海部位）的适配问题浏览器已经做了处理，所以我们只需要关注底部与小黑条的适配问题即可（即常见的吸底导航、返回顶部等各种相对底部 fixed 定位的元素）。以下是解决方法： 新增 meta 标签： iOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式。可设置三个值： contain: 可视窗口完全包含网页内容 cover：网页内容完全覆盖可视窗口 auto：默认值，跟 contain 表现一致 样式中引用变量： body { /*页面主体内容限定在安全区域内*/ padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); } { /*fixed 元素的适配*/ padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); } /*使用 @supports 隔离兼容样式*/ @supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env( safe-area-inset-bottom)) { div { margin-bottom: constant(safe-area-inset-bottom); margin-bottom: env(safe-area-inset-bottom); } } 常见问题 iphone X 下，fixed 元素在页面滑动底部时，会往上滑动移动一点。这是由于页面高度不足一屏(或者撑开页面高度的元素加了fixed，脱离文档流)引起的。 解决方法： body 或者主元素中加 min-height 加空的 div 或伪元素撑高页面 元素使用 padding-bottom 预留底部小黑条区域，必需设置box-sizing: content-box 限制input输入 input 元素只允许输入数字、中文、字母等。 实现思路：Js监听键盘事件，通过正则匹配或键码值对比，将不符合校验的值替换或者将事件对象的returnValue置为false。 三个键盘事件：keydown、keypress、keyup 常见的限制类型： 只能输入或粘贴数字 只能输入数字(无闪动) 57)) event.returnValue=false\" /> 只能输入或粘贴数字和小数点 只能输入或粘贴英文字母和数字，不能输入中文 只能输入或粘贴中文 只能输入或粘贴英文 简易禁止输入汉字 只读文本框 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-13 22:03:07 "},"js探索系列/01-谈谈JavaScript的作用域和上下文.html":{"url":"js探索系列/01-谈谈JavaScript的作用域和上下文.html","title":"谈谈JavaScript的作用域和上下文","keywords":"","body":"谈谈 JavaScript 的作用域和上下文 Javascript与作用域有关的概念很多：全局作用域、局部作用域、词法作用域、上下文、闭包、还有最令人疑惑的 this 等等。。。 本文主要是对作用域相关的内容做个疏理。 什么是作用域？ 一句话：作用域就是变量与函数的可访问范围。 作用域是一个抽象概念，在 JavaScript 中, 作用域可以理解为可访问变量、对象、函数的集合。通常我们说某个变量在不在某个作用域，指的就是变量在此作用域是否可访问。换句话说，作用域决定了代码区块中变量和其他资源的访问权限。 作用域分为词法作用域（静态作用域）和动态作用域。 词法作用域 词法作用域，也称静态作用域，是指函数的作用域在声明（定义）时就已经确定了。 JavaScript 采用的就是词法作用域。Javascript函数无论在何处调用，它能访问哪些变量，不能访问哪些变量是早已确定的。它的作用域是由定义时的位置决定的。 大多数现在程序设计语言都是采用静态作用域规则，如C/C++、C#、Python、Java…… 来看一个简的例子： let fengyun = '风中之神' function funcA (){ console.log(fengyun) } function funcB () { let fengyun = '不哭死神' funcA() } funcB() //风中之神 如上代码，在funcB调用funcA。funcA没有变量fengyun，它会在定义函数的作用域中查找。funcA是在全局作用域用定义的，因此，它会在全局作用域中查找变量fengyun。 JavaScript关心的是函数声明时的作用域，而不是函数执行时的作用域。 词法作用域可分为全局作用域、函数作用域，以及ES6新增的块级作用域。 全局作用域 全局作用域中的变量能被程序中任何函数或者方法访问，这种变量也称为全局变量。全局变量的生命周期是存在于整个程序之内，只有在页面关闭后才会销毁。 一般来说以下三种情形拥有全局作用域： 程序最外层定义的函数或者变量 //全局变量会挂载到 window 对象上 var varA = 123 var funcA = function () { console.log('funcA') } console.log(varA) //123 console.log(funcA) //ƒ () {console.log('funcA')} console.log(varB) //undefined var varB = 123 //这里要注意，varB在定义之前被调用，不会报错。这是因为变量提升。但变量提升只会声明变量，并不会直接赋值。以上代码价于： var varB console.log(varB) //undefined varB = 123 var funcA = function () { console.log('1') } function funcA() { console.log('2') } funcA() //1 //以上代码等价于 //先声明变量funcA；定义一个函数名为funcA的函数，变量funcA指向这个函数；对变量funcA赋值一个新函数，覆盖前面函数 var funcA function funcA() { console.log('2') } funcA = function () { console.log('1') } 未声明直接赋值的变量 这个跟我们平常写代码的坏习惯有关，不用var声明的变量会自动升级为全局作用域，不管是在程序的最外层还是函数内部。 var funcA = function () { a = 123 return a } funcA() //123 console.log(a) //123 程序最外层定义的变量会挂载到window属性，它有一个特性是不能用delete运算符删除。delete一个全局变量返回的是false。 未声明直接赋值的变量创建一个全局变量，创建的是全局属性，属性能够被delete运算符删除 。 var a = '123' b = '456' delete a //false delete b //true console.log(a) //123 console.log(b) //Uncaught ReferenceError: b is not defined Window对象的属性和方法 一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等 通常在Javascript中我们说全局对象，指的就是Window对象（与宿主环境有关），引用this指代的也是Window对象，如果我们在程序中定义一个全局作用域的变量，那么它自然也会成为Window对象的属性。 全局作用域弊端：过多的定义全局变量会污染全局命名空间， 容易引起命名冲突。 函数作用域 函数作用域是指函数内声明的变量（不带var），只能在函数内部访问，外层的作用域（全局作用域或者其他函数作用域）无法直接访问。不同的函数内可以使用相同名称的变量，它们之间互不干扰。 函数内声明的变量称为局部变量，在函数执行完毕后销毁。 var funcA = function () { var a = 123 return a } var funcB = function () { console.log(a) } console.log(a) //Uncaught ReferenceError: a is not defined funcB() //Uncaught ReferenceError: a is not defined 块级作用域 块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。 for(var k = 0; k 用 var关键字声明的变量，在 for 循环之后仍然被保存这个作用域里。 块级作用域可通过ES6新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问： for(let k = 0; k 创建匿名函数，函数内的变量无法被外部访问： (function () { for(var k = 0; k 动态作用域 首先说明一下，JavaScript没有用动态作用域概念，但this机制却和动态作用域类似！ 动态作用域是指函数的作用域在运行时才确定。动态作用域不关心函数是如何声明以及在何处声明的，只关心它们从何处调用。动态作用域的概念和js中的this相同，this也关心函数在哪里调用的。JavaScript 除了this之外，其他，都是根据词法作用域查找！！！ 采用动态作用域的语言有Pascal、Emacs Lisp、Common Lisp（兼有静态作用域）、Perl（兼有静态作用域）。C/C++是静态作用域语言，但在宏中用到的名字，也是动态作用域。 执行上下文栈 在ECMASscript中的代码有三种类型：global, function和eval。 每一种代码的执行都需要依赖自身的上下文。当然global的上下文可能涵盖了很多的function和eval的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval函数的每一次执行，也会进入eval执行中的上下文，判断应该从何处获取变量的值。 注意：一个function可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。 一系列活动的执行上下文从逻辑上形成一个栈。栈底总是全局上下文，栈顶是当前（活动的）执行上下文。当在不同的执行上下文间切换（退出的而进入新的执行上下文）的时候，栈会被修改（通过压栈或者退栈的形式）。 当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。 执行上下文 也称为执行环境，即Javascript代码执行时的环境。不同类型代码的执行会产生不同的执行环境。一个执行的上下文可以抽象的理解为object，每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。主要有三个属性： 变量对象(variable object) this指针(this value) 作用域链(scope chain) 变量对象(Variable Object) 变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。 它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。 它是一个抽象的概念，不同的上下文中，它表示使用不同的object。 例如：在浏览器中，变量对象也是全局对象自身，即window；在Nodejs中，变量对象也是全局对象自身，即Global对象。（这就是我们可以通过全局对象的属性来指向全局变量）。 进入执行上下文时，VO的初始化过程具体如下： 函数的形参：当进入函数执行上下文时，形参是变量对象的一个属性，其属性名就是形参的名字，其值就是实参的值；对于没有传递的参数，其值为undefined 函数声明：函数也是变量对象的一个属性，其属性名和值都是函数对象创建出来的；如果变量对象已经包含了相同名字的属性，则替换它的值 变量声明：函数内的变量也是变量对象的一个属性，其属性名即为变量名，其值为undefined;如果变量名和已经声明的函数名或者函数的参数名相同，则不会影响已经存在的属性。 执行代码的时候，VO的一些Undefined值会被确定。 console.log(varA) //undefined console.log(funcB)//ƒ baz(){ console.log(\"baz\")} var varA = '雪饮刀' function funcB(){ console.log(\"绝世好剑\"); } 变量varA初始化为变量对象中的属性，属性名是变量名，值为undefined。console.log(varA)执行时，varA还未赋值，其值仍为undefined。 函数funcB初始化为变量对象中的属性，其属性名和值都是函数对象创建出来的。因此它是有值的。 以上代码等价于： var varA function funcB(){ console.log(\"绝世好剑\"); } console.log(varA) console.log(funcB) varA = '雪饮刀' 活动对象(activation object) 当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。 即：活动对象 = 变量对象 + 特殊对象arguments 。 AO是在进入函数的执行上下文时创建的，并为该对象初始化一个arguments属性，该属性的值为Arguments对象。 对于VO和AO的关系可以理解为：VO在不同的执行上下文有不同的表现：当在全局执行上下文，可以直接使用VO；但是，在函数执行上下文中，AO就会被创建，并在函数上下文中作为变量对象使用。 作用域链(scope chain) 一句话：作用域链其实就是对执行上下文中的变量对象(VO|AO)有序访问的链表。 在执行上下文的作用域中查找变量的过程被称为标识符解析(indentifier resolution)，这个过程的实现依赖于函数内部另一个同执行上下文相关联的对象——作用域链。作用域链是一个有序链表，其包含着用以告诉JavaScript解析器一个标识符到底关联着哪一个变量的对象。而每一个执行上下文都有其自己的作用域链Scope。 作用域链的用途，是保证对执行上下文有权访问的所有变量和函数的有序访问。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。 let varA = '风神腿' let varB = '排云掌' function funcA () { let varB = '天霜拳' function funcB () { console.log(varA) //风神腿，全局对象中的varA console.log(varB) //天霜拳，funcA中的varB } funcB() funcC() } function funcC () { console.log(varA) //风神腿，全局对象中的varA console.log(varB) //排云掌，全局对象中的varB } funcA() funcA调用funcB打印varA，funcB没有此变量，然后再在父级执行上下文(funcA的函数执行上下文)中查找，没有找到，再往上级查找，一直找到全局对象的let varA = '风神腿'。 注意：这里的父级行上下文指的是词法层面上的父级，即定义函数的父级上下文。比如：funcC虽然是在funcA中调用的，但它不会调用funcA定义的变量varB，而是调用全局上下文中的let varB = '排云掌'，因为它是在全局上下文中声明的。 在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量VO和活动对象（activation object）。当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复。 上下文（this） 上下文通常是取决于一个函数如何被调用。当函数作为对象的方法被调用时，上下文就是调用方法的对象，this指向这个对象。 this关键词是JavaScript中最令人疑惑的机制之一。this是非常特殊的关键词标识符，在每个函数的作用域中被自动创建，它到底指向什么（对象），取决于 this 所在的函数属于谁： 全局上下文中 this指向JavaScript 的宿主换环境的全局对象。在浏览器中，this始终指向Window对象；在Node.js中，this始终指向Global 对象。 console.log(this === window) // true 函数上下文中 简单调用 简单调用，即独立函数调用。this没有明确的指向对象，那么默认就指向全局对象。 function funcA () { return this } funcA() === window //true 在严格模式下，this保持进入执行上下文时被设置的值。如果没有设置，那么默认是undefined。它可以被设置为任意值（包括null/undefined/1等等基础值，不会被转换成对象）。 function funcB () { \"use strict\" return this } funcB() === undefined //true 箭头函数 在箭头函数中，this由词法作用域设置。它被设置为定义它的执行上下文的this，并且不再被调用方式影响（call/apply/bind）。 let self = this let funcC = () => this funcC() === self //true let obj = { funcC } obj.funcC() === self //true funcC.call(obj) === self //true let funcD = funcC.bind(obj) funcD() === self //true 作为对象方法 当函数作为对象方法调用时，this指向该对象。 let objA = { propA: '火麒麟', funcF: function () { return this.propA } } objA.funcF() //\"火麒麟\" 构造函数 在构造函数（函数用new调用）中，this指向构造出来的新对象。 function funcG () { return this } funcG() === window //true new funcG() === window //false,this指向新生成的实例 class classA { funcH () { console.log(this === window) //false return this } } let consA = new classA() consA.funcH() === consA //true call和apply Function.prototype上的call和apply可以指定函数运行时的this。 var c = 50 var d = 60 function funcI(a, b){ return a + b + this.c + this.d } let objB = { c: 10, d: 20 } funcI.call(objB, 1, 2) //33 = 1 + 2 + 10 + 20 funcI.apply(objB, [100, 200]) //330 = 100 + 200 + 10 + 20 funcI.apply(1, [100, 200]) //NaN = 100 + 200 + undefined + undefined。this指向new Number(1)生成的Number对象，对象没有c、d属性 funcI.apply('1', [100, 200]) //NaN = 100 + 200 + undefined + undefined。this指向new String('1')生成的String对象，对象没有c、d属性 funcI.apply(null, [100, 200]) //410 = 100 + 200 + 50 + 60。this指向window 注意：当用call和apply而传进去作为this的不是对象时，将会调用对应的数据类型的构造函数转换成对象，而null/undefined由于无法转换成对象，全局对象将作为this。 bind ES5引进了Function.prototype.bind。f.bind(someObject)会创建新的函数（函数体和作用域与原函数一致），但this被永久绑定到someObject，不论你怎么调用。 function funcI(a, b){ return a + b + this.c + this.d } let objB = { c: 10, d: 20 } let funcJ = funcI.bind(objB) funcJ(80, 90) //200 = 80 + 90 + 10 + 20 DOM事件的函数 this自动设置为触发事件的dom元素。 document.querySelector('div').addEventListener('click', function () { console.log(this === document.querySelector('div')) //true }, false) //点击div元素，执行结果为true 简单的说就是： 没指定调用对象，默认都指向全局对象 有对象就指向调用对象 在箭头函数中，this由词法作用域设置 用new构造就指向新对象 通过 apply 或 call 或 bind 来改变 this 的所指 作用域与执行上下文的区别 作用域是在函数声明的时候就确定的一系列变量的集合体，而执行上下文是函数执行时才产生的一系列变量的集合体。也就是说作用域定义了执行上下文中的变量的访问规则，执行上下文是在这个作用域规则的前提下执行代码的。 JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段： 解释阶段 词法分析 语法分析 作用域规则确定 执行阶段 创建执行上下文 执行函数代码 垃圾回收 作用域是在JavaScript 解释阶段确定的，而执行上下文是执行阶段创建的。 它们最大的区别是： 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。 闭包 《JavaScript高级编程指南》：闭包是指有权访问另外一个函数作用域中的变量的函数。 MDN：闭包是由函数以及声明该函数的词法环境组合而成的。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。 一个简单的闭包示例： function makeFunc() { var name = \"Mozilla\" function displayName() { alert(name) } return displayName } var myFunc = makeFunc() myFunc() 这里的displayName就是一个闭包。myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用。displayName 的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当 myFunc 被调用时，变量 name 仍然可用，其值 Mozilla 就被传递到alert中。 一个更有意思的示例： function makeAdder(x) { return function(y) { return x + y } } var add5 = makeAdder(5) var add10 = makeAdder(10) console.log(add5(2)) // 7 console.log(add10(2)) // 12 add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。 闭包的用处 模拟私有属性、方法 编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。比如： var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } })(); console.log(Counter.value()); /* logs 0 */ Counter.increment(); Counter.increment(); console.log(Counter.value()); /* logs 2 */ Counter.decrement(); console.log(Counter.value()); /* logs 1 */ 该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。 函数工厂 函数工厂，就是调用函数后，返回的是一个新函数。前面有一个示例中的makeAdder函数就是函数工厂： function makeAdder(x) { return function(y) { return x + y } } var add5 = makeAdder(5) var add10 = makeAdder(10) 避免局部属性污染全局变量空间导致的命名空间混乱 闭包的缺点 内存消耗 我们已经知道了闭包是自带执行环境的函数，相比普通函数，闭包对于内存的占用还真就比普通函数大，毕竟外层函数的自由变量无法释放。 闭包中的this var varA = \"风中之神\" var objA = { varA: \"不哭死神\", FuncM: function () { console.log(\"FuncM: \" + this.varA) //FuncM: 不哭死神 return function () { console.log(\"FuncN: \" + this.varA) //FuncN: 风中之神 } } } obj.FuncM()() //FuncN: 风中之神 FuncM的输出好理解。前面我们讲到：当函数作为对象方法调用时，this指向该对象。所以FuncM中的this指向的是objA，但是，这不并不意味它返回的函数也指向objA。FuncM返回的函数是全局上下文中调用的，它指向的是全局对象，即window。obj.FuncM()()等价于下面代码： var funcO = obj.FuncM() funcO() //FuncN: 风中之神 call/apply/bind的异同点 相同之处： 它们都可以改变函数体内 this 的指向。 第一个参数都是this要指向的对象 不传，或者传null，undefined， this指向window对象 传递另一个函数的函数名fun2，this指向函数fun2的引用 值为原始值(数字，字符串，布尔值)，this会指向该原始值的自动包装对象，如 String、Number、Boolean 传递一个对象，函数中的this指向这个对象 都可以利用后续参数传参 对ES6 的箭头函数无效 不同之处： call、apply传参方式不一样 apply、call 立即执行；bind不立即执行，它会返回一个新创建的函数 var varA = '风中之神' function funcA (a, b) { console.log(this.varA + `：${a} ${b}`) } var arrawFunc = (a, b) => { console.log(this.varA + `：${a} ${b}`) } var objF = { varA: '不哭死神' } funcA('风', '云') //风中之神：风 云 arrawFunc('风', '云') //风中之神：风 云 默认情况下，funcA、arrawFunc函数中的this都是指向window。我们通过call/apply/bind来改变this的指向（注意这三个方法的差异）： //普通函数，this指向改变，指向objF funcA.call(objF, '风', '云') //后续传参，传参需一个一个传 funcA.apply(objF, ['风', '云']) //后续传参，参数放在一个数组中 let funcC = funcA.bind(objF) //返回一个绑定函数 funcC('风', '云') //以上三个的输出结果：不哭死神：风 云 //箭头函数，this指向无法改变，仍是指向window arrawFunc.call(objF, '风', '云') arrawFunc.apply(objF, ['风', '云']) let funcD = arrawFunc.bind(objF) funcD('风', '云') //以上三个的输出结果：风中之神：风 云 模拟实现 call 和 bind 实现原理：将函数设置为对象的属性，然后用对象去调用。 //测试用列 var varA = '风中之神' function funcA (a, b) { console.log(this.varA + `：${a} ${b}`) } var objF = { varA: '不哭死神' } funcA('风', '云') //风中之神：风 云 //实现原理 var varA = '风中之神' var objF = { varA: '不哭死神', funcA: function () { console.log(this.varA) } } objF.funcA('风', '云') //不哭死神：风 云 具体实现： //call的模拟 Function.prototype.myCall = function (context) { var context = context || window context.fn = this //fn是属性名，随便定义，后面会删除 var args = [...arguments].slice(1) //取出函数中的参数 var result = context.fn(...args) delete context.fn //删除fn属性 return result } funcA.myCall(objF, '风', '云') //不哭死神：风 云 //bind的模拟 Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var that = this var args = [...arguments].slice(1) return function F() { // 返回一个函数 // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new that(...args, ...arguments) } return that.apply(context, args.concat(...arguments)) } } let funcC = funcA.myBind(objF) new funcC('风', '云') //undefined：风 云。this指向新建的实例，新建的实例中没有varA属性，输出undefined 实用场景 将类似数组的对象转化为数组 类似数组的对象：对象的所有键名都是正整数或零，并且有length属性。 Array.prototype.slice.call(document.querySelectorAll('div')) Array.prototype.slice.apply(document.querySelectorAll('div')) Array.prototype.slice.bind(document.querySelectorAll('div'))() 判断变量类型 Object.prototype.toString.call([]) Object.prototype.toString.apply([]) Object.prototype.toString.bind([])() //[object Array] 数组追加 var arrA = [1 , 2 , 3, 4] var arrB = [\"风\" , \"中\" , \"之\" , \"神\"] Array.prototype.push.apply(arrA, arrB) console.log(arrA) //[1, 2, 3, 4, \"风\", \"中\", \"之\", \"神\"] 获取数组中的最大值和最小值 var num = [1, 3, 5, 7, 2, -10, 11] Math.max.apply(Math, num) //11 Math.min.apply(Math, num) //-10 最后，留一个Javascript题目 以下代码的最终输出结果是什么？ function funcQ() { funcR = function () { console.log('1') } return this } funcQ.funcR = function () { console.log('2') } funcQ.prototype.funcR = function () { console.log('3') } var funcR = function () { console.log('4') } function funcR() { console.log(5) } funcQ.funcR() funcR() funcQ().funcR() funcR() new funcQ.funcR() new funcQ().funcR() new new funcQ().funcR() 查看DEMO 执行结果是：2 4 1 1 2 3 3。 参考链接 理解执行环境与作用域链 MDN 闭包 一篇文章看懂JS闭包，都要2020年了，你怎么能还不懂闭包？ © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 02:10:55 "},"js探索系列/02-JavaScript-Date的使用和日期时间字符串格式.html":{"url":"js探索系列/02-JavaScript-Date的使用和日期时间字符串格式.html","title":"JavaScript Date的使用和日期时间字符串格式","keywords":"","body":"JavaScript Date的使用和日期时间字符串格式 JavaScript的时间由世界标准时间（UTC）1970年1月1日开始，用毫秒计时，一天由 86,400,000 毫秒组成。Date 对象的范围是 -100,000,000 天至 100,000,000 天（等效的毫秒值）。 创建一个 JavaScript Date 实例，该实例呈现时间中的某个时刻。Date 对象则基于 Unix Time Stamp，即自1970年1月1日（UTC）起经过的毫秒数。 常规函数调用 以一个函数的形式来调用 Date 对象（即不使用 new 操作符）会返回一个代表当前日期和时间的字符串。 Date() //Sat May 30 2020 21:08:12 GMT+0800 (中国标准时间) 注意，即使带有参数，Date作为普通函数使用时，返回的还是当前时间。 Date(2020, 4, 1) //Sat May 30 2020 21:09:28 GMT+0800 (中国标准时间) 构造函数用法 创建一个新Date对象的唯一方法是通过new 操作符。Date()构造函数有四种基本形式 new Date() // 当前日期和时间 new Date(milliseconds) //返回从 1970 年 1 月 1 日至今的毫秒数 new Date(dateString) new Date(year, month, day, hours, minutes, seconds, milliseconds) 没有参数 如果没有输入任何参数，则Date的构造器会依据系统设置的当前时间来创建一个Date对象。 new Date() //Sat May 30 2020 21:13:39 GMT+0800 (中国标准时间) Unix时间戳 Unix时间戳表示当前时间到1970年1月1日00:00:00 UTC对应的秒数。 注意，JavaScript内的时间戳指的是当前时间到1970年1月1日00:00:00 UTC对应的毫秒数，和unix时间戳不是一个概念，后者表示秒数，差了1000倍。 时间戳必须是number格式，string会返回Invalid Date。 new Date(1600000000000) //Sun Sep 13 2020 20:26:40 GMT+0800 (中国标准时间) new Date('1600000000000') //Invalid Date 时间戳字符串 dateString表示日期的字符串值。该字符串必须是能被Date.parse()解析的，即符合 IETF-compliant RFC 2822 timestamps 或 version of ISO8601。 注意: 由于浏览器差异和不一致性，强烈建议不要使用Date构造函数（和Date.parse，它们是等效的）解析日期字符串。 比如：对 ISO 8601 格式的支持中，仅有日期的字符串 (例如 \"1970-01-01\") 会被处理为 UTC 而不是本地时间，与其他格式的串的处理不同。 分别提供日期与时间的每一个成员 至少需要提供年份与月份两个参数。如果只传一个参数，会被解析为时间戳。 new Date(2000) //Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间) new Date(2000, 0) //Sat Jan 01 2000 00:00:00 GMT+0800 (中国标准时间) 这一形式的 Date()返回的 Date对象中的每一个成员都来自下列参数。没有提供的成员将使用最小可能值（对日期为1，其他为0）。 year 表示年份的整数值。 0到99会被映射至1900年至1999年，其它值代表实际年份。 monthIndex 表示月份的整数值，从 0（1月）到 11（12月）。 day 可选 表示一个月中的第几天的整数值，从1开始。默认值为1。 hours 可选 表示一天中的小时数的整数值 (24小时制)。默认值为0（午夜）。 minutes 可选 表示一个完整时间（如 01:10:00）中的分钟部分的整数值。默认值为0。 seconds 可选 表示一个完整时间（如 01:10:00）中的秒部分的整数值。默认值为0。 milliseconds 可选 表示一个完整时间的毫秒部分的整数值。默认值为0。 注意：当Date作为构造函数调用并传入多个参数时，如果数值大于合理范围时（如月份为 13 或者分钟数为 70），相邻的数值会被调整。 new Date(2019, 13, 1) //Sat Feb 01 2020 00:00:00 GMT+0800 (中国标准时间) new Date(2020, 1, 1) //Sat Feb 01 2020 00:00:00 GMT+0800 (中国标准时间) new Date(2019, 13, 1, 8, 70) //Sat Feb 01 2020 09:10:00 GMT+0800 (中国标准时间) new Date(2019, 13, 1, 9, 10) //Sat Feb 01 2020 09:10:00 GMT+0800 (中国标准时间) 注意：当Date作为构造函数调用并传入多个参数时，所定义参数代表的是当地时间。如果需要使用世界协调时 UTC，使用 new Date(Date.UTC(...)) 和相同参数。 new Date(2019, 4, 30).getTime() //1559145600000 new Date(2019, 4, 30) // Thu May 30 2019 00:00:00 GMT+0800 (中国标准时间) new Date(Date.UTC(2019, 4, 30)).getTime() //1559174400000 new Date(Date.UTC(2019, 4, 30)) // Thu May 30 2019 08:00:00 GMT+0800 (中国标准时间) Date 对象为跨平台提供了统一的行为。时间属性可以在不同的系统中表示相同的时刻，而如果使用了本地时间对象，则反映当地的时间。 Date 对象支持多个处理 UTC 时间的方法，也相应地提供了应对当地时间的方法。UTC，也就是我们所说的格林威治时间，指的是time中的世界时间标准。而当地时间则是指执行JavaScript的客户端电脑所设置的时间。 Date对象的属性 constructor 返回对创建此对象的 Date 函数的引用。 prototype 允许为 Date 对象添加属性。 length Date.length 的值是 7。这是该构造函数可接受的参数个数。 Date对象的方法 now() 返回自 1970-1-1 00:00:00 UTC（世界标准时间）至今所经过的毫秒数。 为了提供针对定时攻击和指纹追踪的保护，Date.now() 的精度可能会根据浏览器的高级设置项目而被取整。 Date.now() //1590848667253 parse() 解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。 不推荐在ES5之前使用Date.parse方法，因为字符串的解析完全取决于实现。直到至今，不同宿主在如何解析日期字符串上仍存在许多差异，因此最好还是手动解析日期字符串（在需要适应不同格式时库能起到很大帮助）。 比如：2020-05-31 15:30:00的字符串解析，可能为NaN，UTC时间或者本地时间。 其参数必须是一个符合 RFC2822或 ISO 8601 日期格式的字符串（其他格式也许也支持，但结果可能与预期不符）。 UTC() 接受的参数同日期构造函数接受最多参数时一样（2个参数~7个参数），返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。 Date.UTC(year, month, day, hours, minutes, seconds, milliseconds) Date实例的方法 所有的 Date 实例都继承自 Date.prototype。修改 Date构造函数的原型对象会影响到所有的 Date 实例。 valueOf() valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法。 get 类方法（共19个） 方法 描述 getYear() 请使用 getFullYear() 方法代替。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 new Date().getTimezoneOffset() //-480 //-480表示 UTC 比当前时间少480分钟，即当前时区比 UTC 早8个小时。 返回实例对象年、月、日、时、分、秒、毫秒、周的值（共8个）： 方法 描述 getFullYear() 从 Date 对象以四位数字返回年份。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getMilliseconds() 返回 Date 对象的毫秒(0 ~ 999)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 0 代表星期日， 1 代表星期一，2 代表星期二， 依次类推。 根据世界时，返回实例对象年、月、日、时、分、秒、毫秒、周的值（共8个）： 方法 描述 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0 ~ 11)。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。 getUTCHours() 根据世界时返回 Date 对象的小时 (0 ~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0 ~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0 ~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒(0 ~ 999)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。0 代表星期日， 1 代表星期一，2 代表星期二， 依次类推。 set 类方法(共16个) 方法 描述 setTime() 以毫秒设置 Date 对象。 setYear() 请使用 setFullYear() 方法代替。 设置实例对象的年、月、日、时、分、秒、毫秒的值（共7个）： 注：没有setDay方法，因为星期几是计算出来的，而不是设置的。 方法 描述 setFullYear() 设置 Date 对象中的年份（四位数字）。 setMonth() 设置 Date 对象中月份 (0 ~ 11)。 setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。 setHours() 设置 Date 对象中的小时 (0 ~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0 ~ 999)。 根据世界时，设置实例对象的年、月、日、时、分、秒、毫秒的值（共7个）： 方法 描述 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0 ~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0 ~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0 ~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。 let dateA = new Date('2020-05-31') dateA //Sun May 31 2020 08:00:00 GMT+0800 (中国标准时间) dateA.setFullYear(2030) dateA //Fri May 31 2030 08:00:00 GMT+0800 (中国标准时间) set类方法和get类方法，可以结合使用，得到相对时间。 let dateA = new Date('2020-05-31') //设置1000天以后 dateA.setDate(dateA.getDate() + 1000) dateA //Sat Feb 25 2023 08:00:00 GMT+0800 (中国标准时间) //设置1年以后 dateA.setFullYear(dateA.getFullYear() + 1) dateA //Sun Feb 25 2024 08:00:00 GMT+0800 (中国标准时间) to 类方法（共12个） 方法 描述 toString() 返回一个表示该日期对象的字符串。覆盖了Object.prototype.toString() 方法。 toUTCString() 把一个日期对象转换为一个以UTC时区计时的字符串。 toISOString() 把一个日期转换为符合 ISO 8601 扩展格式的字符串。注意：返回的总是 UTC 时区的时间。 toJSON() 与toISOString方法的返回结果完全相同。默认情况下，这个方法常用于 JSON序列化Date对象。 toLocaleString() 返回一个表示该日期对象的字符串，该字符串与系统设置的地区关联（locality sensitive）。覆盖了 Object.prototype.toLocaleString() 方法。 toDateString() 以人类易读（human-readable）的形式返回该日期对象日期部分的字符串。 toLocaleDateString() 返回一个表示该日期对象日期部分的字符串，该字符串格式与系统设置的地区关联（locality sensitive）。 toTimeString() 以人类易读格式返回日期对象时间部分的字符串。 toLocaleTimeString() 返回一个表示该日期对象时间部分的字符串，该字符串格式与系统设置的地区关联（locality sensitive）。 toGMTString() 返回一个基于 GMT (UT) 时区的字符串来表示该日期。请使用 toUTCString() 方法代替。 toSource() 返回一个与Date等价的原始字符串对象，你可以使用这个值去生成一个新的对象。重写了 Object.prototype.toSource() 这个方法。 注：该特性是非标准的，请尽量不要在生产环境中使用它！ toLocaleFormat() 使用格式字符串将日期转换为字符串。该特性是非标准的，请尽量不要在生产环境中使用它！ let DateA = new Date(2020，5，30) DateA.toString() // Sat May 30 2020 00:00:00 GMT+0800 (中国标准时间) DateA.toUTCString() // Fri, 29 May 2020 16:00:00 GMT DateA.toISOString() // 2020-05-29T16:00:00.000Z DateA.toJSON() // 2020-05-29T16:00:00.000Z DateA.toLocaleString() // 2020/5/30 上午12:00:00 DateA.toDateString() // Sat May 30 2020 DateA.toLocaleDateString() // 2020/5/30 DateA.toTimeString() // 00:00:00 GMT+0800 (中国标准时间) DateA.toLocaleTimeString() // 上午12:00:00 toLocaleDateString()、toLocaleString()、toLocaleTimeString()返回的字符串格式因不同语言而不同。新增的参数 locales 和 options 使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现（behavior）。在旧版本浏览器中， locales 和 options 参数被忽略，使用的语言环境和返回的字符串格式是各自独立实现的。 let DateA = new Date(2020, 4, 30) let options = { timeZone: \"UTC\", timeZoneName: \"short\", hour12: true } DateA.toLocaleTimeString() //上午12:00:00 DateA.toLocaleTimeString(\"cn\", options) //UTC 下午4:00:00 DateA.toLocaleTimeString(\"en-US\", options) //4:00:00 PM UTC 标准时间 GMT即「格林威治标准时间」(Greenwich Mean Time，简称G.M.T.)，指位于英国伦敦郊区的皇家格林威治天文台的标准时间，因为本初子午线被定义为通过那里的经线。然而由于地球的不规则自转，导致GMT时间有误差，因此目前已不被当作标准时间使用。 UTC是最主要的世界时间标准，是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间。UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。 理论上，UTC与 GMT 时间是相等的（除非出现了闰秒，日常使用上可以忽略不计）。 时区与UTC偏移 时区的概念 时区是地球上的区域使用同一个时间定义。以前，人们通过观察太阳的位置（时角）决定时间，这就使得不同经度的地方的时间有所不同（地方时）。1863年，首次使用时区的概念。时区通过设立一个区域的标准时间部分地解决了这个问题。 整个地球分为二十四时区，每个时区都有自己的本地时间 。本地时间 = 标准时间 + 时区差，时区差东为正，西为负。 时区表示法 如果时间是以协调世界时（UTC）表示，则在时间后面直接加上一个“Z”（不加空格）。“Z”是协调世界时中0时区的标志。因此，09:30 UTC就写作 09:30Z 或是 0930Z。14:45:15 UTC 则为 14:45:15Z 或 144515Z。 UTC时间也被叫做祖鲁时间，因为在北约音标字母中用“Zulu”表示“Z”。 UTC偏移量 UTC偏移量代表了某个具体的时间值与UTC时间之间的差异。用 ±[hh]:[mm] 、 ±[hh][mm] 、±[hh] 的形式表示。比如北京时间的时区会表达成 +08:00、+0800 、UTC+8 。 一个时区中往往会包含多个偏移量，而多个时区可能在一年的某些时间有相同的偏移量。比如 America/Chicago、America/Denver、America/Belize 在一年中不同的时间都会包含 -06:00这个偏移。 日期时间字符串格式 日期格式的字符串必须符合 RFC2822 或 ISO 8601标准。 其他非标准格式也许也支持，但结果可能与预期不符。 ECMAScript规范规定：如果一个字符串不符合标准格式，则函数可以使用任何由引擎决定的策略或解析算法。 RFC 2822标准（推荐） RFC 2822标准指定了在计算机用户之间发送的电子邮件时的文本消息的语法。 YYYY/MM/DD HH:MM:SS ±timezone(时区用4位数字表示) //2020/05/31 15:15:30.500 +0800 YYYY = 4位数年份 month = 2位数月份或者'Jan/Feb/Mar/Apr/May/Jun/Jul/Aug/Sep/Oct/Nov/Dec' day = 2位数日期 hour = 小时的2位数 minute = 分钟的2位数 second = 秒的2位数 timezone = ±4位数时区，即±[hh][mm] /* 以下皆为chrome测试结果。By lizhao，2020/05/31 */ //未指定时区，以本地时区解析 new Date('2020/05/31 15:15:30.500') //本地时区（东八区），Sun May 31 2020 15:15:30 GMT+0800 (中国标准时间) new Date('2020/05/31 15:15:30.500Z') //UTC时间，Sun May 31 2020 23:15:30 GMT+0800 (中国标准时间) new Date('2020/05/31 15:15:30.500 +0100') //东一区Sun May 31 2020 22:15:30 GMT+0800 (中国标准时间) //毫秒可以是【:】或【.】分隔，标准中未说明 new Date('2020/05/31 15:15:30:500') //Sun May 31 2020 15:15:30 GMT+0800 (中国标准时间) new Date('2020/05/31 15:15:30.500') //Sun May 31 2020 15:15:30 GMT+0800 (中国标准时间) //RFC 2822的兼容性比较好 //年、月、日的【/】前后可以有空格，时、分、秒不可以 new Date('2020 / 05 / 31 15:15:30:500') //Sun May 31 2020 15:15:30 GMT+0800 (中国标准时间) new Date('2020 / 05 / 31 15 : 15 : 30: 500') //Invalid Date //用英文指定月份，好像是做英文简写的不区分大小写的字符匹配？？？ //以下都可以正常返回结果：Thu Feb 20 2020 00:00:00 GMT+0800 (中国标准时间) new Date('2020/February/20') new Date('2020/FEBRUARY/20') new Date('2020/Februar/20') new Date('2020/Februa/20') new Date('2020/Febru/20') new Date('2020/Febr/20') new Date('2020/Feb/20') new Date('2020/Febaaaa/20') //以下报错，Invalid Date new Date('2020/Fe/20') ISO 8601标准 国际标准化组织的国际标准ISO 8601是日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。目前最新为第三版ISO8601:2004，第一版为ISO8601:1988，第二版为ISO8601:2000。年由4位数组成，以公历公元1年为0001年，以公元前1年为0000年，公元前2年为-0001年，其他以此类推。应用其他纪年法要换算成公历，但如果发送和接受信息的双方有共同一致同意的其他纪年法，可以自行应用。 注意：IOS 8601标准日期字符串，不能有空格。 YYYY-MM-DDThh:mm:ss.sTZD //2020-05-31T15:15:30.500+08:00 YYYY = 四位数年份 MM = 两位数的月份（01 =一月，依此类推） DD = 两位数字的月份（01到31） hh = 小时的两位数（00到23）（不允许上午/下午） mm = 分钟的两位数（00到59） ss = 秒的两位数字（00到59） s = 一个或多个数字，代表秒的小数部分 TZD = 时区指示符，Z或±[hh]:[mm] /* 以下皆为chrome测试结果。By lizhao，2020/05/31 */ //指定时区 new Date('2020-05-31T15:15:30.500Z') //【Z】表示UTC标准时区，即\"00:00\" //输出结果（东八区）：Sun May 31 2020 23:15:30 GMT+0800 (中国标准时间) new Date('2020-05-31T15:15:30.500+01:00') //【+01:00】表示东一区 //输出结果（东八区）：Sun May 31 2020 22:15:30 GMT+0800 (中国标准时间) //不指定时区 new Date('2020-05-31') //解析为UTC时间：Sun May 31 2020 08:00:00 GMT+0800 (中国标准时间) new Date('2020-5-31') //以本地时区解析：Sun May 31 2020 00:00:00 GMT+0800 (中国标准时间) new Date('2020-05-31T15:15:30.500') //以本地时区解析：Sun May 31 2020 15:15:30 GMT+0800 (中国标准时间) new Date('2020-5-31T15:15:30.500') //报错：Invalid Date。因为字符串中，月份只有1位数。 日期与时间之间用【T】分隔，以指示时间元素的开始。标准是大写(T)，chrome中小写(t)也可以解析。 时区以UTC（世界标准时间）表示，并带有特殊的UTC标记（“ Z”）。 时区偏移量为 + hh:mm 表示日期/时间使用的本地时区比UTC提前 hh小时和 mm分钟。时区偏移量为-hh:mm 表示日期/时间使用本地时区，该时区比UTC落后 hh小时和 mm分钟。 两者之间的差别 ISO 8601标准的兼容性比RFC 2822差得多。IE8、Safari、iOS均不支持ISO 8601。一般情况下建议用RFC 2822格式的。 未指定时区并且不符合ISO 8601标准，默认使用本地时区。 只有一种情况会以UTC时间的零点为标准进行解析：未指定时区，只有日期格式，没有时间格式，且符合ISO 8601标准的字符串。 注：这个只是ES5的标准而已，在ES6里这两种形式都会变成当前时区的零点为基准 //以UTC时间的零点为标准进行解析 new Date('2020-05-31') //Sun May 31 2020 08:00:00 GMT+0800 (中国标准时间) //以下全部以本地时区为标准进行解析 new Date('2020/05/31') //RFC 2822标准：Sun May 31 2020 00:00:00 GMT+0800 (中国标准时间) new Date('2020-5-31') //非ISO 8601标准：Sun May 31 2020 00:00:00 GMT+0800 (中国标准时间) new Date(\"May 31, 2020\") //非标准格式: Sun May 31 2020 00:00:00 GMT+0800 (中国标准时间) RFC2822 的时区表示用四位数字 ±[hh][mm](+0800)，而 ISO 8601 的时区表示用±[hh]:[mm](+08:00) //+0800不是标准IOS 8601写法。 //chrome浏览器、安卓中正常，Ios中获取时间出错。 new Date(\"2018-11-12T00:00:00+0800\") 其他非标准格式 new Date(\"May 31, 2020\") //Sun May 31 2020 00:00:00 GMT+0800 (中国标准时间) new Date(\"31 May, 2020\") //Sun May 31 2020 00:00:00 GMT+0800 (中国标准时间) new Date(\"Sun, 31 May 2020 00:00:00 GMT\") //Sun May 31 2020 08:00:00 GMT+0800 (中国标准时间) new Date(\"Sun May 31 2020 00:00:00 GMT\") //Sun May 31 2020 08:00:00 GMT+0800 (中国标准时间) new Date(\"Sun, 31 May 2020 00:00:00 +0000\") //Sun May 31 2020 08:00:00 GMT+0800 (中国标准时间) new Date(\"Sun, 31 May 2020 00:00:00 +00:00\") //Sun May 31 2020 08:00:00 GMT+0800 (中国标准时间) //注意月份与日期的顺序。以数字表示月份、日期时，月份在前。 new Date(\"05 31, 2020\") //Sun May 31 2020 00:00:00 GMT+0800 (中国标准时间) new Date(\"31 05, 2020\") //Invalid Date new Date(\"12 05, 2020\") //Sat Dec 05 2020 00:00:00 GMT+0800 (中国标准时间) 时间对象的夏令时问题 执行命令：new Date(584290800000)（当前东八时区） 执行结果：Fri Jul 08 1988 00:00:00 GMT+0900 (CDT) (变成东九时区) //safari、IOS new Date(584290800000) Thu Jul 07 1988 23:00:00 GMT+0800 (CST) //Android | chrome new Date(584290800000) Fri Jul 08 1988 00:00:00 GMT+0900 (中国夏令时间) 导致不同环境获取的日期不一样： //safari、IOS new Date(584290800000).getDate() //7 //Android | chrome new Date(584290800000).getDate() //8 夏令时的原因，不同浏览器解析夏令时间的时间戳的返回结果有差异。在安卓或chrome中，解析为Sat Sep 10 1988 00:00:00 GMT+0900 (中国夏令时间)(东九区)，但在IOS或safari中，解析为Thu Jul 07 1988 23:00:00 GMT+0800 (CST)（东八区）。 什么是夏令时？ 夏时制，夏时令（Daylight Saving Time：DST），又称“日光节约时制”和“夏令时间”，是一种为节约能源而人为规定地方时间的制度，在这一制度实行期间所采用的统一时间称为“夏令时间”。一般在天亮早的夏季人为将时间提前一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。各个采纳夏时制的国家具体规定不同。目前全世界有近110个国家每年要实行夏令时。 1986年至1991年，中华人民共和国在全国范围实行了六年夏令时，每年从4月中旬的第一个星期日2时整（北京时间）到9月中旬第一个星期日的凌晨2时整（北京夏令时）。除1986年因是实行夏令时的第一年，从5月4日开始到9月14日结束外，其它年份均按规定的时段施行。夏令时实施期间，将时间调快一小时。1992年4月5日后不再实行。 解决方法 不存储时间戳，存时间字符串。 时间精确到天的，可以手动加1~2个小时。 new Date(584290800000 + 2* 60 * 60 * 1000) 其他常见问题 日期的运算 类型自动转换时，Date实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。 两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。 let DateA = new Date(2020, 4, 30) let DateB = new Date(2020, 4, 1) console.log(DateA - DateB) //2505600000 console.log(DateA + DateB) //Sat May 30 2020 00:00:00 GMT+0800 (中国标准时间)Fri May 01 2020 00:00:00 GMT+0800 (中国标准时间) 注：不能用 == 或 === 判断时间对象是否表示同一时间 let DateA = new Date(2020, 4, 30) let DateB = new Date(2020, 4, 30) //实际是两个对象对比。对比的是变量中存的栈内存的地址 DateA == DateB //false DateA === DateB //false //可以在运算后，转化成时间戳再对比 +DateA == +DateB //true +DateA === +DateB //true getTime()与parse()的区别 Date.parse()虽然声称是返回日期与 1970 年 1 月 1 日午夜之间所间隔的毫秒数，但是实际上返回的是精确到秒的毫秒数，而并非实际的毫秒。并且这个数字是非四舍五入的，也就是即使是1秒999毫秒，也按照1000毫秒来输出。 而getTime()则返回实际毫秒数。 let DateA = new Date(2020, 4, 30, 8, 0, 0, 300) DateA.getTime() //1590796800300 Date.parse(DateA) //1590796800000 生日算年龄 /* 函数：根据生日算年龄 参数： - birth为Date对象|时间字符串|时间戳 - d为指定时间，不传默认为当前时间 */ function getAgeFromBirth (birth, d = new Date()) { if (birth === undefined || birth === null || birth > d) { return -1 } let curDate = new Date(d) let birthDate = new Date(birth) let age = curDate.getFullYear() - birthDate.getFullYear() if (curDate.getMonth() Date解析为时间字符 /* 函数：Date对象|时间字符串|时间戳，转换成指定格式的时间字符串 参数： - time为Date对象|时间字符串|时间戳 - cFormat String。指定返回的字符串格式 */ function parseTime (time, cFormat = '{y}-{m}-{d} {h}:{i}:{s}') { if (time === undefined || time === null) { return null } let date if (typeof time === 'object') { date = time } else { if (('' + time).length === 10){ time = parseInt(time) * 1000 } date = new Date(time) } const formatObj = { y: date.getFullYear(), m: date.getMonth() + 1, d: date.getDate(), h: date.getHours(), i: date.getMinutes(), s: date.getSeconds(), a: date.getDay() } const timeStr = cFormat.replace(/{(y|m|d|h|i|s|a)+}/g, (result, key) => { let value = formatObj[key] if (key === 'a') { return ['日', '一', '二', '三', '四', '五', '六'][value] } if (result.length > 0 && value 参考链接 JavaScript 标准内置对象 Date JavaScript 时间与日期处理实战:你肯定被坑过 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/03-四种判断数据类型方法的优缺点.html":{"url":"js探索系列/03-四种判断数据类型方法的优缺点.html","title":"四种判断数据类型方法的优缺点","keywords":"","body":"四种判断数据类型方法的优缺点 JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据： let a = 42 a = \"bar\" a = true a = {} 最新的 ECMAScript 标准定义了 8 种数据类型: 基本类型（7种） Boolean Null Undefined Number BigInt String Symbol 基本类型也称为简单类型，存储于栈内存中，数据大小确定，内存空间大小可以分配，是按值存储的，可以直接访问。 引用类型（1种） Object Object 是唯一的复杂数据类型。 Object、Function 、Array、RegExp、Date 这些引用类型值最终都可以归结为 Object 复杂数据类型。 引用类型存储于堆内存中。而存储在变量处的值，是一个指针，指向存储对象的内存处，即按址访问。 除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的（如：JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为\"原始值”。 鉴于ECMAScript 是弱类型的语言，因此需要有一种手段来检测给定变量的数据类型。对于这个问题，JavaScript 也提供了多种方法，但遗憾的是，没有一种是完美，每种方法都有自己的优缺点。 let objT = { str: '', num: 1, bool: true, undef: undefined, nul: null, symbol: Symbol(), bigInt: BigInt(10), fun: new Function(), arr: [], numN: new Number(), boolN: new Boolean(), strN: new String(), date: new Date(), reg: new RegExp(), } typeof typeof 操作符返回一个字符串，表示未经计算的操作数的类型。 typeof variable 返回该类型的字符串(全小写字母)形式表示，包括以下 8 种：string、number、boolean、symbol、bigint、undefined、function、object 等。 有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值： 对于 null ，返回'object ' // JavaScript 诞生以来便如此 typeof null === 'object'; 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回'object'。 曾有一个 ECMAScript 的修复提案（通过选择性加入的方式），但被拒绝了。该提案会导致 typeof null === 'null'。 引用类型Function，返回'function' let func1 = new Function() let func2 = function () {} typeof func1 //\"function\" typeof func2 //\"function\" 对于其他基本类型，均可以返回正确的结果 对于其他引用类型，一律返回'object' 除 Function 外的所有构造函数的类型都是'object' // 除 Function 外的所有构造函数的类型都是 'object' let str = new String('String'); let num = new Number(100); let func = new Function(); typeof str; // 返回 'object' typeof num; // 返回 'object' typeof func; // 返回 'function' 对正则表达式字面量的类型判断在某些浏览器中不符合标准： typeof /s/ === 'function'; // Chrome 1-12 , 不符合 ECMAScript 5.1 typeof /s/ === 'object'; // Firefox 5+ , 符合 ECMAScript 5.1 当前所有的浏览器都暴露了一个类型为 undefined 的非标准宿主对象 document.all。 typeof document.all === 'undefined'; 尽管规范允许为非标准的外来对象自定义类型标签，但它要求这些类型标签与已有的不同。document.all 的类型标签为 'undefined' 的例子在 Web 领域中被归类为对原 ECMA JavaScript 标准的“故意侵犯”。 在 ECMAScript 2015 之前，typeof 总能保证对任何所给的操作数返回一个字符串。即便是没有声明的标识符，typeof 也能返回 'undefined'。使用 typeof 永远不会抛出错误。 但在加入了块级作用域的 let 和 const 之后，在其被声明之前对块中的 let 和 const 变量使用 typeof 会抛出一个 ReferenceError。块作用域变量在块的头部处于“暂存死区”，直至其被初始化，在这期间，访问变量将会引发错误。 for (let k in objT) { console.log(typeof objT[k]) } let objT = { str: '', //string num: 1, //number bool: true, //boolean undef: undefined, //undefined nul: null, //object symbol: Symbol(), //symbol bigInt: BigInt(10), //bigint fun: new Function(), //function //以下都为object arr: [], numN: new Number(), boolN: new Boolean(), strN: new String(), date: new Date(), reg: new RegExp() } instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。即用来判断 object 是否为 constructor 的实例，如果 object 是 constructor 的实例，则返回 true，否则返回 false。表达式为： object instanceof constructor 不能用来判断7种基本类型值，因为基本数据类型没有原型链 objT.str instanceof String //false objT.num instanceof Number //false objT.bool instanceof Boolean //false objT.undef instanceof undefined //Uncaught TypeError: Right-hand side of 'instanceof' is not an object objT.nul instanceof null //Uncaught TypeError: Right-hand side of 'instanceof' is not an object objT.symbol instanceof Symbol //false objT.bigInt instanceof BigInt //false 不能正确判断 Object 类型 instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 [] instanceof Array // true [] instanceof Object; // true function Person(){} new Person() instanceof Person //true new Person() instanceof Object;// true prototype 属性的值是可变的 function A( ){} let a = new A() a instanceof A //true //修改构造函数的prototype A.prototype = null a instanceof A //false //修改对象的原型链 b.__proto__ = null b instanceof A //false 构造函数的 prototype 属性的值有可能会改变，改变之后的值很有可能不存在于 object 的原型链上。 对象 obj 的原型链的也是可以修改的。虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 __proto__ 伪属性，是可以实现的。 不能用于跨窗口判断 在浏览器中，我们的脚本可能需要在多个 frame 或 window 之间的交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如： document.body.appendChild(document.createElement('iframe')) let xArray = window.frames[0].Array let arr = new xArray(1,2,3) arr instanceof xArray //true arr instanceof Array //false 针对数组的这个问题，ES5 提供了 Array.isArray() 方法 。该方法用以确认某个对象本身是否为 Array 类型，而不区分该对象在哪个环境中创建。 constructor constructor属性返回一个指向创建了该对象原型的函数引用。需要注意的是，该属性的值是那个函数本身。所有对象都会从它的原型上继承一个 constructor 属性。 obj.constructor === Constructor null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。 objT.undef.constructor //Cannot read property 'constructor' of undefined objT.nul.constructor //Cannot read property 'constructor' of null 其他基本数据类型访问时，JavaScript会自动调用其构造函数来生成一个对象 (0).constructor === Number // true true.constructor === Boolean // true 'a'.constructor === String // true // 相当于 (new Number(0)).constructor === Number (new Boolean(true)).constructor === Boolean (new String('a')).constructor === String 对象的constructor是可变的 function A( ){} let a = new A() a.constructor === A //true //修改对象的constructor a.constructor = null a.constructor === A //false 不能用于跨窗口判断 与instanceof类似，constructor在不同的窗口拥有不同的内置构造函数。 document.body.appendChild(document.createElement('iframe')) let xArray = window.frames[0].Array let arr = new xArray(1,2,3) arr.constructor === Array //false arr.constructor === xArray //true toString toString方法是最为可靠的类型检测手段，它会将当前对象转换为字符串并输出。 toString属性定义在Object.prototype上，因而所有对象都拥有toString方法。 但Array, Date等对象会重写从Object.prototype继承来的toString， 所以最好用Object.prototype.toString来检测类型。 //目前是最可靠的了，它总能返回正确的值 Object.prototype.toString.call(variable) 无法检测用户自定义类型 toString也不是完美的，它无法检测用户自定义类型。 因为Object.prototype是不知道用户会创造什么类型的， 它只能检测ECMA标准中的那些内置类型。 function A( ){} let a = new A() Object.prototype.toString.call(a) //[object Object] 避免了跨窗口问题 因为返回值是字符串，也避免了跨窗口问题。当然IE弹窗中还是有Bug，不必管它了。 常见问题 null 和 undefined 的区别 null 与 undefined 都可以表示 没有，含义非常相似。将一个变量赋值为 undefined 或 null，老实说，语法效果几乎没区别。 1995年 JavaScript诞生 时，最初像 Java 一样，只设置了 null 作为表示\"无\"的值。但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够，有两个原因。 首先，null 像在 Java 里一样，被当成一个对象。但是，JavaScript 的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示\"无\"的值最好不是对象。 其次，JavaScript 的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计了一个 undefined。 null 表示空值，是一个表示\"无\"的对象，转为数值时为0。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined 表示“未定义”，是一个表示\"无\"的原始值，转为数值时为 NaN。 Number(null) //0 Number(undefined) //NaN typeof null //'object' typeof undefined //\"undefined\" 总结 typeof只适用于基本数据类型，对于null还有Bug instanceof适用于构造函数创建的对象，它是基于原型链运作的 constructor适用于ECMA内置JavaScript类型和构造函数创建的对象，无法判断null、undefined toString适用于ECMA内置JavaScript类型（包括基本数据类型和内置对象）的类型判断 instanceof和constructor是不安全的，且都有跨窗口问题 总之，如果你要判断的是基本数据类型或JavaScript内置对象，使用toString； 如果要判断的是自定义类型，请使用instanceof或constructor。 参数链接 判断JS数据类型的四种方法 如何检查 JavaScript 变量类型？ © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/04-深入理解JavaScript的浅拷贝和深拷贝.html":{"url":"js探索系列/04-深入理解JavaScript的浅拷贝和深拷贝.html","title":"深入理解JavaScript的浅拷贝和深拷贝","keywords":"","body":"深入理解JavaScript的浅拷贝和深拷贝 JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念。在JS引擎中，每一个变量都需要一个内存空间，内存空间主要有两种类型：堆内存和栈内存。 什么是堆栈？ 对于开发人员而言，或多或少都会接触过堆跟栈的概念。 对于计算机存储而言： 堆与栈是两种不同的内存管理 对于数据结构而言：堆与栈是两种常用的数据结构 这里，我们需要了解的是计算机存储中的栈和堆： 栈(Stack) 栈是由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等。栈使用一级缓存，它的访问效率会高一些。 栈存储基本数据类型 栈主要用于存储JavaScript中的基本数据类型：undefined，boolean，number，string，null以及对象变量的指针。 栈内存中数据大小确定，内存空间大小可以分配，是按值存储的，可以直接访问。 当我们定义一个const对象的时候，我们说的常量其实是指针，就是const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。 栈内存中变量的值是不可变的 动态修改了基本数据类型的值，它的原始值也是不会改变的。例如： var str = \"abc\" str[1] = 'ddd' //返回值：ddd console.log(str) //其原始值还是：abc 栈内存中变量的比较是值的比较 堆(Heap) 堆是由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收。堆存储在二级缓存中。 JavaScript中有自动垃圾回收机制，会通过标记清除的算法识别哪些变量对象不再使用，对其进行销毁。开发者也可在代码中手动设置变量值为null进行标记清除。 局部环境中，函数执行完成后，函数局部环境声明的变量不再需要时，就会被垃圾回收销毁（理想的情况下，闭包会阻止这一过程）。 全局环境只有页面退出时才会出栈，解除变量引用。所以开发者应尽量避免在全局环境中创建全局变量，如需使用，也要在不需要时手动标记清除，将其内存释放掉。 堆存储引用类型 堆主要用于存储JavaScript中的引用类型：Object, Array, Date, RegExp, Function等。 堆内存中变量实际上是一个指向堆内存地址的指针。每个空间大小不一样，要根据情况开进行特定的分配。 堆内存中变量的值是可变的 堆内存中变量的比较是内存地址的比较 为什么会有栈内存和堆内存之分？ 通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。 当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的。 当创建一个对象时，这个对象将被保存到堆内存中，以便反复利用（因为对象的创建成本通常较大）。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁。只有当一个对象没有任何引用变量引用它时，才会被销毁。 赋值和浅拷贝、深拷贝的区别 赋值（=） 在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再将值赋值到新的栈中。所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。 而引用类型的赋值（=）是将对象保存在栈内存的地址赋值到新变量，拷贝的是对象的引用，而不是对象本身。新变量和原变量指向的是同一个对象，因此两者之间操作互相有影响。 let objA = { a: 'abc', b: '123' } let objB = objA objB.a = 'xyz' //将objA赋值给objB，它们仍指向同一对象。objB改变属性a，objA同样会改变。 console.log(objA) //{a: \"xyz\", b: \"123\"} 浅拷贝和深拷贝 浅拷贝和深拷贝是对引用类型的数据（对象）而言。它们会创建一个新的对象，会开辟一块新的内存空间，将原对象的属性的值拷贝过来。拷贝结束之后，内存中的值是完全相同的，但是内存地址是不一样的，两个对象之间相互不影响，也互不干涉。 浅拷贝：只会将对象的各个属性进行依次拷贝，并不会进行递归拷贝，也就是说只会对对象的第一层属性进行拷贝。 深拷贝：不同于浅拷贝，它不但拷贝目标对象的第一层属性，而且还递归拷贝目标对象的所有属性。 浅拷贝的实现方法 浅拷贝测试用例： let objA = { a: 'abc', b: '123', c: { d: 'ddd', e: 'eee', }, [Symbol()]: { f: 'fff', g: 'ggg' }, get m () { return 1 } } Object.defineProperty(objA, 'h', { value: 4, enumerable: false }) for...in循环 function shallowCopy1 (obj) { if (typeof obj !== 'object') { return } let newObj = obj.constructor === Array ? [] : {} for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key] } } return newObj } shallowCopy1(objA) // 输出结果为 // a: \"abc\" // b: \"123\" // c: {d: \"ddd\", e: \"eee\"} // m: 1 该方法无法正确拷贝以下属性： Symbol：Symbol是ES6中引入的原始数据类型。Symbol值通过Symbol函数生成，是独一无二的。ES6中规定了对象的属性名有两种类型，一种是字符串，另一种就是 Symbol 类型。 不可枚举属性 属性描述符 我们来列举一下，可以获取对象键名的方法： 方法 自身属性 继承属性 可枚举 不可枚举 Symbol属性 for...in ✓ ✓ ✓ X X Object.keys() ✓ X ✓ X X Object.getOwnPropertyNames() ✓ X ✓ ✓ X Object.getOwnPropertySymbols() ✓ X X X ✓ Reflect.ownKeys() ✓ X ✓ ✓ ✓ for...in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys()返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames()返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols()返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys()返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 将上面方法改成遍历Reflect.ownKeys()返回的数组： //修改后，可遍历对象自身的所有键名。不含继承、不含属性描述符 function shallowCopy2 (obj) { if (typeof obj !== 'object') { return } let newObj = obj.constructor === Array ? [] : {} Reflect.ownKeys(obj).forEach(key => { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key] } }) return newObj } shallowCopy2(objA) // 输出结果为 // a: \"abc\" // b: \"123\" // c: {d: \"ddd\", e: \"eee\"} // h: 4 // m: 1 // Symbol(): {f: \"fff\", g: \"ggg\"} 该方法可以正确拷贝Symbol属性、不可枚举属性，但仍无法正确拷贝继承属性、属性描述符。 再来了解下这两个方法： Object.getPrototypeOf方法返回参数对象的原型。这是获取原型对象的标准方法。 ES6引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象 我们可以用Object.create()，根据对象的原型链和属性描述符生成新对象： function shallowCopy3 (obj) { return Object.create( Object.getPrototypeOf(objA), Object.getOwnPropertyDescriptors(objA) ) } shallowCopy3(objA) // 输出结果为 // a: \"abc\" // b: \"123\" // c: {d: \"ddd\", e: \"eee\"} // m: 1 // Symbol(): {f: \"fff\", g: \"ggg\"} // h: 4 // get m: ƒ m() 该方法成功拷贝了Symbol属性、不可枚举属性、属性描述符，但仍无法拷贝承继属性。 Object.assign() Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（包含Symbol），不包含继承属性，也不包含不可枚举的属性。 ES6扩展运算符的结果与Object.assign() 的相同。 Object.assign({}, objA) { ...objA } // a: \"abc\" // b: \"123\" // c: {d: \"ddd\", e: \"eee\"} // m: 1 // Symbol(): {f: \"fff\", g: \"ggg\"} 数组的浅拷贝 let arrA = [1, 2, 3] //concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 let arrB = arrA.concat() //slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。 let arrB = arrA.slice() //es6扩展运算符 let arrB = [...arrA] 深拷贝的实现方法 深拷贝测试用例： let objB = { num: 0, str: '', boolean: true, unf: undefined, nul: null, obj: { name: '我是一个对象', id: 1 }, arr: [0, 1, 2], func: function() { console.log('我是一个函数') }, date: new Date(), reg: new RegExp('/我是一个正则/ig'), err: new Error('我是一个错误'), [Symbol()]: { f: 'fff', g: 'ggg' } } Object.defineProperties(objB, { h: { value: 4, enumerable: false, writable: false, configurable: false }, m: { get() { console.log('调用了get') return [1,2,3] }, set(val) { console.log('调用了set') } } }) JSON.parse(JSON.stringify()) 原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。 JSON.parse(JSON.stringify())的确是一种很简单易用的方式。可惜的是，它能正确处理的对象只有 Number、String、Array 等能够被Json 表示的数据结构。在遇到不安全的JSON值会自动将其忽略，在数组中则会返回null（以保证单元位置不变）。 不安全的 JSON 值: undefined 、 function 、 symbol （ES6+）和包含循环引用的对象，都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们。 JSON.parse(JSON.stringify(objB)) // 输出结果 // arr: [0, 1, 2] // boolean: true // date: \"2020-05-13T12:34:57.078Z\" // err: {} // nul: null // num: 0 // obj: {name: \"我是一个对象\", id: 1} // reg: {} // str: \"\" // 丢失的数据有：undefined、function、Symbol、不可枚举属性 // 不能正确复制：Date、RegExp、Error、属性描述符 该方法的局限： 不能复制：undefined、function、Symbol、不可枚举属性 不能正确复制：Date、RegExp、Error、属性描述符 循环引用 相同引用会被重复复制 迭代递归法 原理：对于简单类型，直接复制。对于引用类型，递归复制它的每一个属性。 我们将前面讲到的方法做一个递归： function deepCopy1 (obj) { if (!obj || typeof obj !== 'object') { return obj } let newObj = obj.constructor === Array ? [] : {} Reflect.ownKeys(obj).forEach(key => { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepCopy1(obj[key]) : obj[key] } }) return newObj } // 输出结果 // arr: [0, 1, 2] // boolean: true // date: {} // err: {stack: \"Error: 我是一个错误\", message: \"我是一个错误\"} // func: ƒ () // h: 4 // m: (3) [1, 2, 3] // nul: null // num: 0 // obj: {name: \"我是一个对象\", id: 1} // reg: {lastIndex: 0} // str: \"\" // unf: undefined // Symbol(): {f: \"fff\", g: \"ggg\"} //不能正确复制：Date、RegExp、Error、属性描述符(拷贝后属性描述符丢失) 这是一般场景中使用的方法，功能比JSON方法强大。但它同样存在以下问题： 不能正确复制：Date、RegExp、Error、属性描述符。 循环引用 相同引用会被重复复制 当然，JavsScript中的数据类型远远不只这些。 Javascript中的数据类型 常见的有 基本数据类型：Boolean、String、Number 引用类型：function、Array、Date 其他：RegExp，Arguments，Error、NodeList 不一定常见 Blob、File、FileList、ImageData ES6 Map、Set、WeakMap、WeakSet、ArrayBuffer对象、TypedArray视图和DataView视图、Float32Array、Float64Array、Int8Array... 一一实现他们不是一件简单的事情，甚至是一件完全没有必要的事情（当然可以让你了解更多） 深入解析深拷贝方法 我们在上面迭代递归法的基础上来分析实现深拷贝需要解决的问题： 类型判断用 要实现各种数据类型的拷贝，先要判断其类型。上述方法使用!obj || typeof obj !== 'object'来判断是否为对象，而typeof方法本身也有局限性。 JavaScript 有四种方法可以判断： typeof运算符 typeof可以判断出number、string、boolean、undefined及function等类型，而对于null及数组、对象，typeof均判断为object，不能进一步判断它们的类型。需要特别注意下null的类型判断： //特别注意`typeof null`的坑 typeof null // \"object\" null instanceof Object // false instanceof运算符 instanceof不能判断undefined和null，而且对于不是用new声明的基本类型也无法判断。对于是使用new声明的类型，它还可以检测出多层继承关系。 constructor constructor不能判断undefined和null，并且使用它是不安全的，因为contructor的指向是可以改变的 Object.prototype.toString方法 在任何值上调用 Object原生的toString()方法，都会返回一个[object NativeConstructorName]格式的字符串。每个类在内部都有一个[[Class]] 属性，这个属性中就指定了上述字符串中的构造函数名。 但是它不能检测非原生构造函数的构造函数名。 相对而言，这是一种比较常用的判断方法： Object.prototype.toString.call(obj).slice(8,-1) 处理特殊的数据类型 实现Date、RegExp、Error、属性描述符的正确拷贝。解决方法如下： function deepCopy2 (obj) { if (!obj || typeof obj !== 'object') { return obj } let newObj let Constructor = obj.constructor switch(Constructor){ case RegExp: newObj = new Constructor(obj) break case Date: newObj = new Constructor(obj.getTime()) break default: newObj = new Constructor() newObj = Object.create( Object.getPrototypeOf(newObj), Object.getOwnPropertyDescriptors(obj) ) break } Reflect.ownKeys(obj).forEach(key => { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepCopy2(obj[key]) : obj[key] } }) return newObj } deepCopy2(objB) 完整版可以查看lodash深拷贝 函数的处理：函数拥有一些内在属性，但我们一般不修改这些属性，所以函数一般直接引用其地址即可。如果需要处理，可考虑用eval或new Function来实现。 循环引用 当对象中有一个属性等于它自身时，会出现循环引用的报错： objB.n = objB deepCopy2(objB) // Uncaught RangeError: Maximum call stack size exceeded 解决思路：存储已经被拷贝的对象，每一次进行拷贝的时候就先查询该对象是否已经被拷贝，如果已经被拷贝则取出该对象并返回。 解决方法一：weakMap储存被拷贝过对象 function deepCopy3 (obj, hash = new WeakMap()) { if (!obj || typeof obj !== 'object') { return obj } if (hash.has(obj)) { return hash.get(obj) } let newObj let Constructor = obj.constructor switch(Constructor){ case RegExp: newObj = new Constructor(obj) break case Date: newObj = new Constructor(obj.getTime()) break default: newObj = new Constructor() newObj = Object.create( Object.getPrototypeOf(newObj), Object.getOwnPropertyDescriptors(obj) ) break } hash.set(obj, newObj) Reflect.ownKeys(obj).forEach(key => { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepCopy3(obj[key], hash) : obj[key] } }) return newObj } deepCopy3(objB) 解决方法二：闭包变量储存被拷贝过对象 function deepCopy4 (obj, hash = []) { if (!obj || typeof obj !== 'object') { return obj } for(let i = 0; i { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepCopy4(obj[key], hash) : obj[key] } }) return newObj } deepCopy4(objB) 相同引用会被重复复制 objB对象中c、d引用的是同一个对象，但在深拷贝时，会分别给c、d拷贝了一个新对象。拷贝后，c、d指向的并不是同一对象，这种情况并不是我们想要的。 let objC = { a: 'aaa' } objB.p = objC objB.q = objC objB.p === objB.q // true，指向同一对象 let objD = deepCopy2(objB) objD.p === objD.q // false，指向不同对象 相同引用的解决思路与上面循环引用相似，上面循环引用的解决方法，已解决该问题 递归爆栈 当数据的层次很深时就会栈溢出。以下是一个生成指定深度和广度JSON数据的方法： //定义一个方法，生成指定深度和广度的JSON对象 function createData(deep = 1, breadth = 1) { var data = {} var temp = data for (var i = 0; i 拷贝的层级很深会栈溢出，但数据的广度不会造成溢出： deepCopy3(createData(200000, 5)) //Uncaught RangeError: Maximum call stack size exceeded deepCopy3(createData(5, 200000)) //正常 破解递归爆栈的方法有两种： 第一种是消除尾递归，但在这里貌似行不通。 第二种方法就是干脆不用递归，改用循环。 function deepCopy5(obj, root = {}) { // 栈 const stackList = [ { parent: root, key: null, data: obj, } ] while(stackList.length) { // 深度优先 const node = stackList.pop() const parent = node.parent const key = node.key const data = node.data // 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素 let res = parent if (key !== null) { res = parent[key] = {} } for(let k in data) { if (data.hasOwnProperty(k)) { if (typeof data[k] === 'object') { // 下一次循环 stackList.push({ parent: res, key: k, data: data[k], }) } else { res[k] = data[k] } } } } return root } 递归爆栈的场景很少见，通常可以忽略。这里仅仅是提出问题，并提供一种解决思路。该方法没有考虑特殊数据的处理、循环引用、相同引用等。 推荐的深拷贝方法 我们在deepCopy3基础上做些改动，实现一个在日常开发中通用的深拷贝方法： function deepCopy (obj, hash = new WeakMap()) { if (!obj || typeof obj !== 'object') { return obj } if (hash.has(obj)) { return hash.get(obj) } let newObj let Constructor = obj.constructor switch(Constructor){ case RegExp: newObj = new Constructor(obj) break case Date: newObj = new Constructor(obj.getTime()) break default: newObj = new Constructor() break } hash.set(obj, newObj) for (let key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key], hash) : obj[key] } } return newObj } 你如仔细看，会发现这个方法功能不如deepCopy3强大。为了适应vue项目中的开发，该方法有二处改动： 删除了Object.create方法。无法拷贝属性描述符。 原因一：此方法中创建数据时，返回的对象类型有些怪异。vue中的props选项在做类型校验时会报错。 var a = [1,2,3] var b = Object.create( Object.getPrototypeOf(a), Object.getOwnPropertyDescriptors(a) ) b instanceof Array // true，判断为数组 b.constructor === Array // true，判断为数组 Object.prototype.toString.call(b) // [object Object]，判断为Object 原因二：在vue框架下，使用此方法无法实现深拷贝，具体原因没研究明白。（我写了一段调用deepCopy3拷贝多层级的JSON对象的JS，在chrome测试过，是可以实现深拷贝的） Reflect.ownKeys方法换成了for..in。无法拷贝不可枚举属性。 这是因为有些对象中的不可枚举属性，不能通过new Constructor()直接创建。比如：vue项目的数据有不可枚举属性__ob__，这是一个Observer方法，在new Constructor时，因为没有传参，引起报错。 总结 JavaScript的深拷贝涉及的内容还很多，比如：能否用Object.create()实现深拷贝、 如何拷贝原型链上的属性、函数等数据类型的拷贝等。 一般来说，上面的推荐方法已经够用了。这个方法已经覆盖了大部分的业务需求。如果业务中需要频繁使用深考贝且数据结构复杂，可以考虑引入第三方库，比如： loadsh 。 参考链接 ES6时代，你真的会克隆对象吗 ES6时代，你真的会克隆对象吗(二) JavaScript深拷贝的一些坑 深拷贝的终极探索 深入 js 深拷贝对象 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/05-Canvas基础入门篇.html":{"url":"js探索系列/05-Canvas基础入门篇.html","title":"Canvas基础入门篇","keywords":"","body":"Canvas基础入门篇 Canvas API 提供了一个通过JavaScript和 HTML的元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。 Canvas API主要聚焦于2D图形。而同样使用元素的 WebGL API则用于绘制硬件加速的2D和3D图形。 获取渲染上下文(2D环境) 使用元素不是非常难，但你需要一些基本的HTML和JavaScript知识。除一些过时的浏览器不支持元素外，所有的新版本主流浏览器都支持它。Canvas的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。为了在 Canvas 上绘制图形，我们使用一个JavaScript上下文对象，它能动态创建图像（ creates graphics on the fly）。 注：css中的width\\height控制的是画布在文档中的宽高，当宽度比例与canvas属性中定义的宽度不一致时，会拉伸canvas元素，相当于把固定的图片拉伸了。 let canvas = document.getElementById(\"canvas_base\") let context = canvas.getContext(\"2d\") // 封装 function getContext2D () { return new Promise((resolve, reject) => { let canvas = document.getElementById(\"canvas_base\") let context = canvas.getContext(\"2d\") if (context) { resolve(context) } else { reject() } }) } 状态的保存和恢复 canvas是基于状态的绘制。保存（推送）当前状态到堆栈，调用以下函数。 save()：保存画布(canvas)的所有状态 restore()：save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。 Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。一个绘画状态包括： 当前应用的变形 以及下面这些属性：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled 当前的裁切路径 从线条开始 移动画笔(moveTo()) context.moveTo(x, y) 这句代码的意思是移动画笔至(x, y)这个点（单位是px）。记住，这里是以canvas画布的左上角为笛卡尔坐标系的原点，且y轴的正方向向下，x轴的正方向向右。 笔画停点(lineTo()) context.lineTo(x, y) 这句的意思是从上一笔的停止点绘制到(x, y)这里。不过要清楚，这里的moveTo()、lineTo()都只是状态而已，是规划，是我准备要画，还没有开始画，只是一个计划而已！ 选择画笔 context.lineWidth = 2 //设置画笔(线条)的粗细为2px context.fillStyle = \"#0dd\" //设置或返回用于填充绘画的颜色、渐变或模式 context.strokeStyle = \"#0dd\" //设置或返回用于笔触的颜色、渐变或模式 Canvas是基于状态的绘制，所以我们在选择画笔粗细和颜色的同时，其实也是选择了线条的粗细和颜色。 确定绘制 确定绘制只有两种方法，fill()和stroke()，前者是指填充，后者是指描边。 //绘制线条：青色 function drawLine (context) { context.moveTo(100, 100) context.lineTo(300, 200) context.lineWidth = 2 context.strokeStyle = \"#0dd\" context.stroke() } //绘制折线：粉红 -> 深蓝 function drawBrokenLine (context) { context.lineWidth = 2 context.moveTo(100, 100) context.lineTo(300, 300) context.strokeStyle = \"#d0d\" context.stroke() context.moveTo(300, 300) context.lineTo(100, 500) context.strokeStyle = \"#00d\" context.stroke() } getContext2D().then(context => { drawLine(context) drawBrokenLine(context) }) 查看DEMO 我们期待的结果页是：第一条线是青色，第二条线是粉红色，第一条线是深蓝。 然，最终渲染出的结果：三条线都是深蓝色。第一条线的青色，第二条线的粉红色了呢？其实，这里的原因是我之前一直强调的一点——Canvas是基于状态的绘制。 什么意思呢？其实这段代码每次使用stroke()时，它都会把之前设置的状态再绘制一遍。第一次stroke()时，绘制一条青色的折线；第二次stroke()时，会再重新绘制之前的那条青色的折线，但是这个时候的画笔已经被更换成粉红色的了，所以画出的折线全是粉红色的。换言之，strokeStyle属性被覆盖了。第三次stroke()同理，画笔更换成了深蓝色。所以最终渲染，三条线都是深蓝！所以，这里看到的三条折线，其实绘制了3次，一共绘制了6条折线。 使用beginPath()开始绘制 为了让绘制方法不重复绘制，我们可以在每次绘制之前加上beginPath()，代表下次绘制的起始之处为beginPath()之后的代码。我们在三次绘制之前分别加上context.beginPath()。 function drawMultBrokenLine (context) { context.lineWidth = 2 context.beginPath() context.moveTo(100, 100) context.lineTo(300, 200) context.strokeStyle = \"#0dd\" context.stroke() context.beginPath() context.moveTo(100, 100) context.lineTo(300, 300) context.strokeStyle = \"#d0d\" context.stroke() context.beginPath() context.moveTo(300, 300) context.lineTo(100, 500) context.strokeStyle = \"#00d\" context.stroke() } 查看DEMO beginPath()是绘制设置状态的起始点，它之后代码设置的绘制状态的作用域结束于绘制方法stroke()、fill()或者closePath()。 线条属性概述 lineCap属性：定义上下文中线的端点，可以有以下 3 个值。 lineCap 定义上下文中线的端点，可以有以下 3 个值。 butt：默认值，端点是垂直于线段边缘的平直边缘。 round：端点是在线段边缘处以线宽为直径的半圆。 square：端点是在选段边缘处以线宽为长、以一半线宽为宽的矩形。 lineJoin属性：定义两条线相交产生的拐角，可将其称为连接。在连接处创建一个填充三角形，可以使用 lineJoin 设置它的基本属性。 lineJoin 定义两条线相交产生的拐角，可将其称为连接。在连接处创建一个填充三角形，可以使用 lineJoin 设置它的基本属性。 miter：默认值，在连接处边缘延长相接。miterLimit 是角长和线宽所允许的最大比例(默认是 10)。 bevel：连接处是一个对角线斜角。 round：连接处是一个圆。 lineWidth属性：定义线的宽度(默认值为 1.0)。 strokeStyle属性： 定义线和形状边框的颜色和样式。 填充颜色 基本颜色 context.fillStyle = \"red\" context.fillStyle = \"#FF0000\" context.fillStyle = \"#F00\" context.fillStyle = \"rgb(255,0,0)\" context.fillStyle = \"rgba(255,0,0,1)\" context.fillStyle = \"hsl(0,100%,50%)\" context.fillStyle = \"hsla(0,100%,50%,1)\" 渐变颜色（又分为线性渐变与径向渐变） 径向渐变（createLinearGradient） context.createLinearGradient(x0,y0,x1,y1) //x0 渐变开始点的 x 坐标 //y0 渐变开始点的 y 坐标 //x1 渐变结束点的 x 坐标 //y1 渐变结束点的 y 坐标 function createLinearGradient (context) { context.rect(100, 100, 300, 300); let grd = context.createLinearGradient(100, 100, 300, 300) grd.addColorStop(0, \"#dd0\") grd.addColorStop(0.5, \"#fd0\") grd.addColorStop(1, \"#0dd\") context.fillStyle = grd context.fill() } 查看DEMO 径向渐变（createRadialGradient） context.createRadialGradient(x0,y0,r0,x1,y1,r1) //x0 渐变的开始圆的 x 坐标 //y0 渐变的开始圆的 y 坐标 //r0 开始圆的半径 //x1 渐变的结束圆的 x 坐标 //y1 渐变的结束圆的 y 坐标 //r1 结束圆的半径 function createRadialGradient (context) { let grd = context.createRadialGradient(75, 50, 5, 90, 60, 100) grd.addColorStop(0, \"#0aa\") grd.addColorStop(1, \"white\") context.fillStyle = grd context.fillRect(10, 10, 300, 300) } 查看DEMO gradient 对象中的颜色和位置：addColorStop gradient.addColorStop(stop,color) //stop 介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。 //color 在结束位置显示的 CSS 颜色值 填充纹理 纹理其实就是图案的重复，填充图案通过createPattern()函数进行初始化。 context.createPattern(image,\"repeat|repeat-x|repeat-y|no-repeat\") //第一个参数：Image对象、canvas对象、video对象 //平面上重复：repeat; //x轴上重复：repeat-x; //y轴上重复：repeat-y; //不使用重复：no-repeat; function createPattern (context) { let canvas = document.createElement(\"canvas\") let context2 = canvas.getContext('2d') canvas.width = 200 canvas.height = 200 let img = new Image() img.src = \"./img/pins_3338674420.jpg\" img.onload = function() { context2.drawImage(img, 0, 0, 200, 200) let pattern = context.createPattern(canvas, 'no-repeat') context.fillStyle = pattern context.fillRect(0, 0, 500, 500) context.lineWidth = 1 context.strokeStyle = '#0dd' context.strokeRect(0, 0, 500, 500) } } 查看DEMO 绘制矩形 context.rect(x,y,width,height)//需调用stroke()或fill()完成绘制 context.fillRect(x,y,width,height) context.strokeRect(x,y,width,height) context.clearRect(x,y,width,height) //x 矩形左上角的 x 坐标 //y 矩形左上角的 y 坐标 //width 矩形的宽度，以像素计 //height 矩形的高度，以像素计 绘制标准圆弧 context.arc(x,y,r,sAngle,eAngle,counterclockwise); //x 圆的中心的 x 坐标。 //y 圆的中心的 y 坐标。 //r 圆的半径。 //sAngle 起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。 //eAngle 结束角，以弧度计。 //counterclockwise 可选。规定应该逆时针还是顺时针绘图。False = 顺时针(默认)，true = 逆时针。 function drawArc (context) { context.beginPath() context.lineWidth = 1 context.strokeStyle = '#0dd' context.arc(100, 75, 100, 0, (120 / 180) * Math.PI, false) context.stroke() } 查看DEMO //在画布上创建介于两个切线之间的弧的JavaScript语法 context.arcTo(x1,y1,x2,y2,r); //x1 弧的起点的 x 坐标 //y1 弧的起点的 y 坐标 //x2 弧的终点的 x 坐标 //y2 弧的终点的 y 坐标 //r 弧的半径 function drawArcTo (context) { context.beginPath() context.lineWidth = 1 context.strokeStyle = '#0dd' context.moveTo(20, 20) context.lineTo(100, 20) context.arcTo(150, 20, 150, 70,50) context.lineTo(150, 100) context.stroke() } 查看DEMO 贝塞尔曲线 二次贝塞尔曲线 //二次贝塞尔曲线 context.quadraticCurveTo(cpx,cpy,x,y); //cpx 贝塞尔控制点的 x 坐标 //cpy 贝塞尔控制点的 y 坐标 //x 结束点的 x 坐标 //y 结束点的 y 坐标 二次贝塞尔曲线需要两个点。第一个点是用于二次贝塞尔计算中的控制点，第二个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点 function drawQuadraticCurveTo (context) { context.lineWidth = 1 context.strokeStyle = '#0dd' context.beginPath() context.moveTo(20, 20) context.quadraticCurveTo(20, 100, 200, 20) context.stroke() } 查看DEMO 三次贝塞尔曲线 //三次贝塞尔曲线 context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); //cp1x 第一个贝塞尔控制点的 x 坐标 //cp1y 第一个贝塞尔控制点的 y 坐标 //cp2x 第二个贝塞尔控制点的 x 坐标 //cp2y 第二个贝塞尔控制点的 y 坐标 //x 结束点的 x 坐标 //y 结束点的 y 坐标 三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo()方法来定义开始点。 文本设置 font //设置或返回文本内容的当前字体属性 textAlign //设置或返回文本内容的当前对齐方式 textBaseline //设置或返回在绘制文本时使用的当前文本基线 context.font = \"[font-style] [font-variant] [font-weight] [font-size/line-height] [font-family]\" //font-style //规定字体样式：normal\\italic\\oblique //font-variant // 规定字体变体：normal\\small-caps //font-weight //规定字体的粗细：normal\\bold\\bolder\\lighter\\100~900 //font-size/line-height //规定字号和行高，以像素计。 //font-family //规定字体系列。 context.textAlign = \"center|end|left|right|start\" //默认。文本在指定的位置开始。 //end 文本在指定的位置结束。 //center 文本的中心被放置在指定的位置。 //left 文本左对齐。 //right 文本右对齐。 context.textBaseline = \"alphabetic|top|hanging|middle|ideographic|bottom\" //alphabetic 默认。文本基线是普通的字母基线。 //top 文本基线是 em 方框的顶端。。 //hanging 文本基线是悬挂基线。 //middle 文本基线是 em 方框的正中。 //ideographic 文本基线是表意基线。 //bottom 文本基线是 em 方框的底端。 fillText() //在画布上绘制“被填充的”文本 strokeText() //在画布上绘制文本（无填充） measureText() //返回包含指定文本宽度的对象 context.fillText(text,x,y,maxWidth) context.strokeText(text,x,y,maxWidth) //text 规定在画布上输出的文本。 //x 开始绘制文本的 x 坐标位置（相对于画布）。 //y 开始绘制文本的 y 坐标位置（相对于画布）。 //maxWidth 可选。允许的最大文本宽度，以像素计。 function drawText (context) { context.fillStyle = \"#0aa\" context.strokeStyle = \"#0aa\" context.font = \"normal normal bold 30px/150px Times\" context.textAlign = \"center\" context.textBaseline = \"middle\" context.fillText(\"Hello Canvas\", 200, 250) context.strokeText(\"width:\" + context.measureText(\"Hello Canvas\").width, 200, 300, 200) } 查看DEMO 变换设置 context.scale(scalewidth,scaleheight); //缩放 //scalewidth 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) //scaleheight 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.) context.rotate(angle); //旋转 //angle 旋转角度，以弧度计。 //如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。 //举例：如需旋转 5 度，可规定下面的公式：5*Math.PI/180。 context.translate(x,y); //位移 //x 添加到水平坐标（x）上的值 //y 添加到垂直坐标（y）上的值 对于缩放变换有两点问题需要注意： 1.缩放时，图像左上角坐标的位置也会对应缩放 2.缩放时，图像线条的粗细也会对应缩放 //矩阵设置 context.transform(a,b,c,d,e,f); context.setTransform(a,b,c,d,e,f); //a 水平缩放(1) //b 水平倾斜(0) //c 垂直倾斜(0) //d 垂直缩放(1) //e 水平位移(0) //f 垂直位移(0) //平移变换： x’ = x + dx， y’ = y + dy。 //也即是说可以使用 context.transform (1,0,0,1,dx,dy)代替context.translate(dx,dy)。 //同理可以使用 context.transform(sx,0,0,sy,0,0)代替context.scale(sx, sy); //也可以使用context.transform(0,sy,sx,0,0,0); //context.transform(Math.cos(θ*Math.PI/180)，Math.sin(θ*Math.PI/180), -Math.sin(θ*Math.PI/180),Math.cos(θ*Math.PI/180)，0，0）可以替代context.rotate(θ)。 //也可以使用 context.transform(-Math.sin(θ*Math.PI/180),Math.cos(θ*Math.PI/180)， Math.cos(θ*Math.PI/180)，Math.sin(θ*Math.PI/180)，0，0）替代。 //区别：transform()变换是指在上一次变换的状态基础上再次变换；setTransform()变换是指先重置到最初始的状态再开始变换。 function transform (context) { context.save() context.fillStyle = \"#0aa\" context.scale(1, 0.5) context.rotate(10 * Math.PI / 180) context.translate(20, 0) context.fillRect(0, 0, 150, 150) console.log('scale') context.restore() //transform context.save() context.translate(100, 0) context.fillStyle = \"yellow\" context.fillRect(0, 0, 150, 100) context.transform(1, 0.5, -0.5, 1, 30, 10) context.fillStyle = \"red\" context.fillRect(0, 0, 150, 100) context.transform(1, 0.5, -0.5, 1, 30, 10) context.fillStyle = \"blue\" context.fillRect(0, 0, 150, 100) context.restore() //setTransform context.save() context.translate(400, 0) context.fillStyle = \"yellow\" context.fillRect(0, 0, 150, 100) context.setTransform(1, 0.5, -0.5, 1, 100, 0) context.fillStyle = \"red\" context.fillRect(0, 0, 150, 100) context.setTransform(1, 0.5, -0.5, 1, 100, 0) context.fillStyle = \"blue\" context.fillRect(0, 0, 150, 100) context.restore() } 查看DEMO 注意保存和恢复Canvas状态 变换只会影响 transform() 等方法调用之后的绘图 裁剪区域 clip()方法来实现Canvas的图像裁剪功能。该方法使用路径来对Canvas画布设置一个裁剪区域。因此，必须先创建好路径。创建完整后，调用clip()方法来设置裁剪区域。 需要注意的是裁剪是对画布进行的，裁切后的画布不能恢复到原来的大小，也就是说画布是越切越小的，要想保证最后仍然能在canvas最初定义的大小下绘图需要注意save()和restore()。画布是先裁切完了再进行绘图。并不一定非要是图片，路径也可以放进去~ function setClip (context) { context.save() context.beginPath() context.fillStyle = '#0aa' context.arc(100, 100, 100, 2 * Math.PI, false) context.clip() let img = new Image() img.src = require(\"@/assets/image/01eb485e44bf8fa8012165187fa336.jpg@1280w_1l_2o_100sh.jpg\") img.onload = function() { context.drawImage(img, 0, 0, 350, 250) context.closePath() context.restore() context.beginPath() context.moveTo(100, 100) context.lineTo(300, 100) context.strokeStyle = '#0aa' context.stroke() context.closePath() } } 查看DEMO 绘制图像 canvas更有意思的一项特性就是图像操作能力。可以用于动态的图像合成或者作为图形的背景，以及游戏界面（Sprites）等等。浏览器支持的任意格式的外部图片都可以使用，比如PNG、GIF、JPEG。 你甚至可以将同一个页面中其他canvas元素生成的图片作为图片源。 引入图像到canvas里需要以下两步基本操作： 获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片。canvas的API可以使用下面这些类型中的一种作为图片的源： HTMLImageElement：这些图片是由Image()函数构造出来的，或者任何的元素 HTMLVideoElement：用一个HTML的 元素作为你的图片源，可以从视频中抓取当前帧作为一个图像 HTMLCanvasElement：可以使用另一个元素作为你的图片源。 ImageBitmap：这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。 这些源统一由 CanvasImageSource类型来引用。 使用drawImage()函数将图片绘制到画布上 context.drawImage(img,x,y) context.drawImage(img,x,y,width,height) context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height) //img 规定要使用的图像、画布或视频。 //sx 可选。开始剪切的 x 坐标位置。 //sy 可选。开始剪切的 y 坐标位置。 //swidth 可选。被剪切图像的宽度。 //sheight 可选。被剪切图像的高度。 //x 在画布上放置图像的 x 坐标位置。 //y 在画布上放置图像的 y 坐标位置。 //width 可选。要使用的图像的宽度。（伸展或缩小图像） //height 可选。要使用的图像的高度。（伸展或缩小图像） function drawImage (context) { let img = new Image() img.src = \"./img/pins_3338674420.jpg\" img.onload = function() { // context.drawImage(img, 0, 0, 500, 500, 0, 0, window.innerWidth, window.innerHeight) context.drawImage(img, 0, 0, 350, 250) } } 查看DEMO 非零环绕原则与奇偶原则 我们一般使用Canvas的fill方法时，是直接进行填充路径。其实fill方法有两个参数可选：nonzero | evenodd ，“nonzero”是非零环绕原则，也是默认值，“evenodd”为奇偶原则。 非零环绕原则nonzero 是用来判断哪些区域属于路径内( 计算结果非0，即为路径内 )。 * 在路径包围的区域中，随便找一点，向外发射一条射线， * 和所有围绕它的边相交， * 然后开启一个计数器，从0计数， * 如果这个射线遇到顺时针围绕，那么+1， * 如果遇到逆时针围绕，那么-1， * 如果最终值非0，则这块区域在路径内。结果为0，代表这块区域不要填充，否则，必须填充 奇偶原则 * 在路径包围的区域中，随便找一点，向外发射一条射线， * 和所有围绕它的边相交， * 查看相交线的个数，如果为奇数，就填充，如果是偶数，就不填充 drawCircular (context) { context.shadowColor = \"#545454\"; context.shadowOffsetX = 5; context.shadowOffsetY = 5; context.shadowBlur = 2; context.globalCompositeOperation = 'source-over' context.fillStyle = \"#00AAAA\" context.arc(200, 200, 100, 0, Math.PI * 2 ,false) context.arc(200, 200, 115, 0, Math.PI * 2 ,true) context.fill() } 查看DEMO 其他属性 阴影设置 shadowColor //设置或返回用于阴影的颜色 shadowBlur //设置或返回用于阴影的模糊级别 shadowOffsetX //设置或返回阴影距形状的水平距离 shadowOffsetY //设置或返回阴影距形状的垂直距离 需要注意的是，这里的阴影同其他属性设置一样，都是基于状态的设置。因此，如果只想为某一个对象应用阴影而不是全局阴影，需要在下次绘制前重置阴影的这四个属性。 全局透明 globalAlpha //默认值为1.0，代表完全不透明，取值范围是0.0（完全透明）~1.0。这个属性与阴影设置是一样的，如果不想针对全局设置不透明度，就得在下次绘制前重置globalAlpha。 图像合成(查看效果) globalCompositeOperation //source-over 默认。在目标图像上显示源图像。 //source-atop 在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 //source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 //source-out 在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 //destination-over 在源图像上方显示目标图像。 //destination-atop 在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 //destination-in 在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 //destination-out 在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 //lighter 显示源图像 + 目标图像。 //copy 显示源图像。忽略目标图像。 //xor 使用异或操作对源图像与目标图像进行组合。 橡皮擦 context.clearRect(x,y,w,h) //清空指定矩形上的画布上的像素。它接受四个参数，和其他绘制矩形的方法一样 点是否位于当前路径中 isPointInPath() 像素操作API width //返回 ImageData 对象的宽度 height //返回 ImageData 对象的高度 data //返回一个对象，其包含指定的 ImageData 对象的图像数据 createImageData() //创建新的、空白的 ImageData 对象 getImageData() //返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() //把图像数据（从指定的 ImageData 对象）放回画布上 绘制圆角矩形 function roundRect (ctx, x, y, w, h, r) { var min_size = Math.min(w, h); if (r > min_size / 2){ r = min_size / 2 } ctx.beginPath() ctx.moveTo(x + r, y) ctx.arcTo(x + w, y, x + w, y + h, r) ctx.arcTo(x + w, y + h, x, y + h, r) ctx.arcTo(x, y + h, x, y, r) ctx.arcTo(x, y, x + w, y, r) ctx.closePath() } 查看DEMO 绘制圆角图片 //方法一 function drawRoundImg (ctx, x, y, w, h, r) { ctx.save(); let img = new Image() img.src = \"./img/pins_3338674420.jpg\" img.onload = function() { roundRect(ctx, x, y, w, h, r) ctx.clip(); ctx.drawImage(img, x, y, w, h) ctx.restore() } } //方法二 function drawRoundImg2 (ctx, x, y, w, h, r) { ctx.save(); let img = new Image() img.src = \"./img/pins_3338674420.jpg\" img.onload = function() { let pattern = ctx.createPattern(img, \"no-repeat\"); roundRect(ctx, x, y, w, h, r) ctx.fillStyle = pattern ctx.fill() } } 查看DEMO 圆角图片1 查看DEMO 圆角图片2 Canvas API没有结束 Canvas的标准一直在更新，大家可以访问 W3C Canvas标准查看最新的API。但是一般最新的API很多浏览器都不会立刻去支持。 常用问题 图片的跨域问题 在 HTMLImageElement上使用crossOrigin属性，你可以请求加载其它域名上的图片。如果图片的服务器允许跨域访问这个图片，那么你可以使用这个图片而不污染canvas，否则，使用这个图片将会污染canvas。 vue项目中，图片的引用 放置在 public 目录下或通过绝对路径被引用 使用require。如img.src = require(\"@/assets/image/01eb485e44bf8fa8012165187fa336.jpg\") 参考链接 Canvas API中文文档首页地图 MDN - canvas 原生HTML5 Canvas 参考API文档 canvas © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"js探索系列/06-SVG基础入门篇.html":{"url":"js探索系列/06-SVG基础入门篇.html","title":"SVG基础入门篇","keywords":"","body":"SVG基础入门篇 可缩放矢量图形（Scalable Vector Graphics，SVG），是一种用于描述二维的矢量图形，基于 XML 的标记语言。作为一个基于文本的开放网络标准，SVG能够优雅而简洁地渲染不同大小的图形，并和 CSS，DOM，JavaScript 和 SMIL 等其他网络标准无缝衔接。本质上，SVG 相对于图像，就好比 HTML 相对于文本。 和传统的点阵图像模式，像 JPEG 和 PNG 不同，SVG 格式提供的是矢量图，这意味着它的图像能够被无限放大而不失真或降低质量，并且可以方便地修改内容。 SVG 是由万维网联盟（W3C）自 1999 年开始开发的开放标准。 SVG 是指可伸缩矢量图形 SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或缩小（改变尺寸）的情况下，其图形质量不会受受损失 SVG 是 W3C 的一个标准 SVG 有哪些优缺点 与其他图像格式相比，使用 SVG 的优势在于： SVG 是矢量格式，可呈现任何大小而不降低其质量 SVG 支持静止或动态图像 SVG 支持透明度 SVG 可被非常多的工具读取和修改（比如：代码或文本编辑器） SVG 可以从 Adobe Illustrator 或 Sketch 等设计软件中导出 SVG 是由于基于文本的格式，是可搜索的（很适合制作地图） SVG 是开放的标准。现代浏览器支持 SVG 格式，并且面向未来 SVG 文件是纯粹的 XML SVG 格式具有高度可压缩性和轻量级 SVG 也有一些缺点： 设计 SVG 可能会变得复杂 在某些版本过低的浏览器上无法呈现 电子邮件客户端支持有限 SVG 的效率可能会不如 PNG 好。因为它需要运行时的计算和对应平台的渲染绘制。 渲染效果不一致。不同的浏览器乃至不同的平台的抗锯齿处理千差万别，尤其是用户关掉抗锯齿的情况下，多边形（边数较多）图标会惨不忍睹。 浏览器中如何使用SVG元素 注意：在外部文件引入的 SVG 必须与原始文件同源 要在浏览器中显示（前提是浏览器支持），可以通过几种方法来实现： HTML 元素引入 SVG 文件 使用 iframe 元素来嵌入SVG图像 使用 img 元素来嵌入SVG图像 引入DEMO 在 CSS 样式中使用 SVG 来对HTML内容应用图像效果 将 SVG 图像作为背景图像嵌入 div { background: url(img/snowman.svg) no-repeat center; background-size : 300px 200px; } 现代浏览器支持在 CSS 样式中使用 SVG 来对 HTML 内容应用图像效果。 你可以在同一文件中使用 SVG 样式，也可以通过外部样式表引入。有三个属性可以使用： mask、clip-path、filter。 ... ... ... .target { mask: url(#mask-1); clip-path: url(#clipping-path-1); filter:url(#f1); } .target2 { /*使用外部引用*/ clip-path: url(resources.svg#c1); } 将 SVG 直接嵌套在 HTML 中 直接使用 svg 元素，通过代码将SVG图像嵌入到HTML代码中。 ... 直接嵌套DEMO 使用 embed、object 元素来嵌入SVG图像。(不推荐使用) SVG 文档基本结构 一个独立的SVG文件，也就是平时看到的以扩展名 .svg 结尾的文件。一个简单的SVG图形例子： XML声明：和HTML文档的DTD声明是类似的。 --> version=\"1.0\" 和 encoding=\"utf-8\" 无论如何都是默认值。 standalone 属性 规定此 SVG 文件是否是\"独立的\"，或含有对外部文件的引用。standalone=\"no\" 意味着 SVG 文档会引用一个外部文件。 svg 根元素包括一个用来描述 SVG 的 XML 声明空间。 --> 嵌入 HTML5 文档中的 SVG 不应具有独立的 XML 声明。在格式良好的XML中只允许使用一个XML声明，并且如果有，它必须位于顶部。而通过 html5 img 或 css background-images 引用的 SVG 必须有自己的 XML 声明。 几个重要的 SVG 概念 1.viewport 视口，表示 SVG 可见区域的大小，或者可以想象成画布大小（与 canvas 的画布概念相似）。SVG 中超出视窗边界的区域会被裁切并且隐藏。 2.viewBox 属性 viewBox 是 “视区盒子” 的意思，即，创建一个可伸展的盒子，用以承载一组图形。当 viewBox 的大小与 viewport 不一致时，盒子会自动伸缩（与 preserveAspectRatio 属性有关）。 viewBox=\"min-x, min-y, width and height\" viewBox 大小，默认是与 viewport 相同。不允许宽度和高度为负值，0则禁用元素的呈现。 viewBox属性DEMO 如上所示，viewBox 的大小是 40 * 30，viewport 的大小是 400 * 300。实现渲染时，会将 viewBox 放大 10 倍。 有 marker、pattern、svg、symbol、view 等五个 svg 元素可以有这个属性。 3.preserveAspectRatio属性 有时候，通常我们使用 viewBox 属性时，希望图形拉伸占据整个视口。 在其他情况下，为了保持图形的长宽比，必须使用统一的缩放比例。preserveAspectRatio 属性表示是否强制进行统一缩放。 对于支持该属性的所有元素，除了 image 元素之外，preserveAspectRatio 只适用于元素上 viewBox 值的元素，如果元素没有提供属性 viewBox ，则忽略了preserveAspectRatio。 preserveAspectRatio=\" \" align：表示是否强制统一缩放。当 SVG 的 viewbox 属性与视图属性宽高比不一致时使用。默认值 xMidYMid ，即，居中。 align 属性的值一定是下列的值之一： none：不会进行强制统一缩放。注意： 如果 align 的值是 none ，则 meetOrSlice 属性的值将会被忽略。 xMinYMin： 强制统一缩放。viewbox 与 viewport X方向左对齐、Y 方向上对齐。 xMidYMin：强制统一缩放。viewbox 与 viewport X方向居中、Y 方向上对齐。 xMaxYMin：强制统一缩放。viewbox 与 viewport X方向居右、Y 方向上对齐。 xMinYMid： 强制统一缩放。viewbox 与 viewport X方向左对齐、Y 方向居中。 xMidYMid (默认值) ：强制统一缩放。viewbox 与 viewport X方向、Y 方向都居中。 xMaxYMid：强制统一缩放。viewbox 与 viewport X方向右对齐、Y 方向居中。 xMinYMax：强制统一缩放。viewbox 与 viewport X方向左对齐、Y 方向下对齐。 xMidYMax：强制统一缩放。viewbox 与 viewport X方向居中、Y 方向下对齐。 xMaxYMax：强制统一缩放。viewbox 与 viewport X方向右对齐、Y 方向下对齐。 meetOrSlice：可选。默认值 meet，即图形将缩放到。 meet：默认值。这种情况下，宽高比将会被保留，尽可能的放大 SVG 的 viewbox，但要确保整个 viewbox 在视图窗口内是可见的。 slice： 这种情况下，宽高比将会被保留，尽可能的放大 SVG 的 viewbox，并且要确保宽、高都覆盖整个视图窗口。 none：扭曲纵横比以充分适应viewport SVG 中的坐标系统 SVG 的坐标系统分为三种类型： 初始坐标系统 转换坐标系统 嵌套坐标系统 初始坐标系统 初始视窗坐标系是一个建立在视窗（viewport）上的坐标系。原点(0,0)在视窗的左上角，X轴正向指向右，Y轴正向指向下，初始坐标系中的一个单位等于视窗中的一个”像素”（更确切的说是一个单位）。 初始用户坐标系 是通过 VIEWBOX 建立在 SVG 画布上的坐标系。这个坐标系一开始和初始视窗坐标系完全一样-它自己的原点位于视窗左上角，x 轴正向指向右，y 轴正向指向下。 转换坐标系统 可以使用 transform 属性来对元素的坐标系统进行变换。transform 属性的作用对象是元素所在的坐标系统，而不是元素本身。 在 SVG 规范中，transform 属性的作用是 在被添加的元素上建立新用户空间坐标系（当前坐标系） (效果与 viewBox 类似)。 它和 CSS 中 transform 属性的变换函数，都是基于坐标系变换的。它们的区别在于：HTML 元素的坐标系建立在元素自身上，而 SVG中，元素坐标系是基于是 初始坐标系 或 当前用户空间坐标系 创建的 。 svg 元素有多个变换时，下一个变换的坐标系是基于上一个变换完成后的坐标系创建的，并且其子元素变换的坐标系，也是基于父元素变换后的坐标系创建的。 嵌套坐标系统 在 svg 元素中可以嵌套 svg 元素。外面的 svg 创建一个 Viewport 和坐标系统，而且嵌套在里面的 svg 也可以创建一个 Viewport 和坐标系统。 如果你不声明子 SVG 的 x 和 y 属性，它们默认是 0。如果你不声明 height 和 width 属性，svg 会是父 SVG 宽度和高度的 100%。 除了可以通过嵌套 svg 外，也可以使用例如 use、symbol 的元素来建立新的 viewport 和用户坐标系。 SVG 的基本组成元素 一个简单的 SVG 文档由 svg 根元素和基本的形状元素构成。另外还有一个 g 元素，它用来把若干个基本形状编成一个组。 从这些开始，SVG 可以变得更加复杂。SVG 支持渐变、旋转、动画、滤镜效果、与 JavaScript 交互等等功能，但是所有这些额外的语言特性，都需要在一个定义好的图形区域内实现。 1.line元素（直线） line 元素是一个 SVG 基本形状，用来创建一条连接两个点的线。 x1：起点x坐标 y1：起点y坐标 x2：终点x坐标 y2：终点y坐标 line元素DEMO 2.rect元素（矩形） rect 元素是 SVG 的一个基本形状，用来创建矩形，基于一个角位置以及它的宽和高。它还可以用来创建圆角矩形。 x：左上角x坐标 y：左上角y坐标 width：宽度 height：高度 rx：x方向的圆角半径 ry：y方向的圆角半径 rect元素DEMO 3.circle元素 (圆) circle 元素是一个 SVG 的基本形状，用来创建圆,基于一个圆心和一个半径。 cx：圆心x坐标 xy：圆心y坐标 r：半径 circle元素DEMO 4.ellipse元素（椭圆） ellipse 元素是一个 SVG 基本形状，用来创建一个椭圆，基于一个中心坐标以及它们的 x 半径和 y 半径。 cx：圆心x坐标 cy：圆心y坐标c rx：x方向半径 ry：y方向半径 ellipse元素DEMO 5.polygon元素 (闭合多边形) polygon 元素是由连接一组点集的直线构成。polygon 的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形。 potins：定义了用来画一个 polygon 元素或 polyline 元素的点的数列。每个点用用户坐标系统中的一个 X 坐标和 Y 坐标定义。用逗号分开每个点。 polygon元素DEMO 6.polyline元素 (折线) polyline 元素是 SVG 的一个基本形状，用来创建一系列直线连接多个点。典型的一个 polyline 是用来创建一个开放的形状，最后一点不与第一点相连。 polyline元素DEMO 7.image元素（图片） 允许在一个 SVG 对象内部呈现光栅图像。它表现为图像文件或者其他 SVG 文件。SVG 图像格式转换软件支持 JPEG、PNG 格式，是否支持动图 GIF 不明确。 x：图像水平方向上到原点的距离 y：图像竖直方向上到原点的距离 width：图像宽度。和 HTML 的 img 不同，该属性是必须的 height：图像高度。和 HTML 的 img 不同，该属性是必须的 xlink:href：图像的 URL 指向 preserveAspectRatio：控制图像比例 image元素DEMO 如果你没有设置 x 属性或 y 属性，它们自动被设置为 0 如果你没有设置 height 属性或 width 属性，它们自动被设置为 0 如果 width 属性或 height 等于0，将不会呈现这个图像 8.textPath（文本） text 元素定义了一个由文字组成的图形。 注意：我们可以将渐变、图案、剪切路径、遮罩或者滤镜应用到 text 上。 x、y：在用户坐标系统中标识了一个 x 轴、y 轴坐标。 dx、dy：一个元素或其内容在 x 轴、y 轴方向上的偏移，偏移量取决于设置该属性的元素。 text-anchor：用来描述该文本与所给点的对齐方式 (开头、中间、末尾对齐) 。取值：start | middle | end。 rotate：指定动画元素沿 animateMotion 元素中指定的路径行进时如何旋转。取值： auto| auto-reverse| number。 textLength：指定文本将绘制到的空间的宽度。 lengthAdjust：控制文本如何拉伸到该 textLength 属性定义的长度。取值：spacing | spacingAndGlyphs。 9.textPath元素（文本路径） 除了笔直地绘制一行文字以外， SVG 也可以根据 path 元素的形状来放置文字。 只要在 textPath 元素内部放置文本，并通过其 xlink:href 属性值引用 path 元素，我们就可以让文字块呈现在 path 元素给定的路径上了。 startOffset：将路径转换为 textPath 元素的坐标系后，该属性定义了沿路径的初始当前文本位置相对于路径起点的偏移量。 method：指示应沿着 textPath 元素路径呈现文本的方法。取值：align|stretch。 spacing：指示用户代理应如何确定要沿路径呈现的印刷字符之间的间距。 xlink:href：将对资源的引用定义为引用IRI。该链接的确切含义取决于使用它的每个元素的上下文。 君子之交淡如水，茶人之交醇如茶。 君子之交淡如水，茶人之交醇如茶。 君子之交淡如水，茶人之交醇如茶。 君子之交淡如水，茶人之交醇如茶。 textPath元素DEMO 10.pattern元素（图案） 使用预定义的图形对一个对象进行填充或描边，就要用到 pattern 元素。pattern 元素让预定义图形能够以固定间隔在 x 轴和 y 轴上重复（或平铺）从而覆盖要涂色的区域。先使用 pattern 元素定义图案，然后在给定的图形元素上用属性 fill 或属性 stroke 引用用来填充或描边的图案。 patternUnits：指示将哪个坐标系用于 pattern 元素的几何属性。 patternContentUnits：指示要用于 pattern 元素内容的坐标系。 patternTransform：定义应用于图案的变换定义列表。 x、y：在用户坐标系统中标识了一个x 轴、y 轴坐标。 width、height：在用户坐标系统中标识了一个水平长度、垂直长度。 xlink:href：将对资源的引用定义为引用IRI。该链接的确切含义取决于使用它的每个元素的上下文。 preserveAspectRatio：表示是否强制进行统一缩放。 pattern元素DEMO SVG 中的路径 path 可能是SVG中最常见的形状。你可以用 path 元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线。 路径可以被填充、描边或者用于剪裁其他元素。 d：一个字符串，包含了一系列路径描述。可以使用不同的指令，移动到一个新的点，然后绘制不同的直线和曲线。 注意：指令字母大写表示坐标位置是绝对坐标，指令字母小写表示坐标位置是相对坐标。x、y坐标之间可以用空格或逗号隔开。 以下用 path 元素，绘制上个 polyline 元素 示例： path元素DEMO 1.直线指令 这里有五种不同的直线指令，你可以使用它们来创建路径。 moveto(M 或 m)：移动到新的位置 lineto(L 或 l)：从当前坐标画一条直线到一个新坐标 horizontal lineto(H 或 h)：画一条水平线到新坐标。只带一个参数，标明在 x 轴移动到的位置 vertical lineto(V 或 v)：画一条垂直线到新坐标。只带一个参数，标明在 y 轴移动到的位置 closepath(Z 或 z)：关闭当前路径。它是最简单的命令，而且不带有任何参数。Z 或 z，两种写法作用都一样 注意：指令的参数用空格或逗号隔开，多个指令之间不需要隔开。 d=\"M10 10L50 50L75 175L175 150L175 50L225 75L225 150L300 150\" d=\"M10,10 L50,50 L75,175 L175,150 L175,50 L225,75 L225,150 L300,150\" 注意：实际应用中使用指令字母即可。指令字母大写表示坐标位置是绝对位置，指令字母小写表示坐标位置时相对位置。 直线指令DEMO 2.曲线指令 绘制平滑曲线的命令有三个，其中两个用来绘制贝塞尔曲线，另外一个用来绘制弧形或者说是圆的一部分： Curveto: 三次贝塞尔曲线指令 (C, c, S, s)，需要一个初始点的控制点和一个结束点的控制点，还有一个结束点。 C (or c) x1,y1 x2,y2 x,y S (or c) x2,y2 x,y x1、y1 是曲线起点的控制点坐标 x2、y2 是曲线终点的控制点坐标 x、y 是曲线的终点坐标。（曲线的起点是上一条指令的终点） Curveto：二次贝塞尔曲线指令 (Q, q, T, t)，只需要一个控制点，同时作为起点控制点和终点控制点。 Q (or q) x1,y1 x,y T (or t) x1,y1 x,y x1、y1 是曲线起点和终点的控制点坐标 x、y 是曲线的终点坐标 曲线指令DEMO 为了连缀平滑的贝塞尔曲线，还可以使用 T 和 S 命令。它们的语法比别的 Curveto 命令简单。因为它假定第一个控制点是前一个控制点关于前一个点的反射（即，关于前一个点对称），或者说如果没有前一个控制点的话它实际上就是前一个点。 Arcto：椭圆弧线 (A, a)，用于绘制一段椭圆片段。若 rx 和 ry 的值相同，则绘制出圆。 A (or a) rx ry xAxisRotate large-arc-flag sweep-flag x y rx、ry：弧线在 x 轴、y 轴方向的半径 xAxisRotate：与 x 轴夹角的度数 large-arc-flag：0 或 1，用来确定是要画小弧（0）还是画大弧（1） sweep-flag：0 或 1，用来确定弧是顺时针方向（1）还是逆时针方向（0） x、y：弧线的终点 椭圆弧线指令DEMO SVG 中的其他元素 SVG 中的标记（Marker） marker 元素定义了在特定的 path、line、polyline、polygon 元素上绘制的箭头或者多边标记图形。 markerUnits： refX、refY：定义元素参考点的x、y坐标 markerWidth、markerHeight：定义 marker元素的宽度、高度。 orient：指示将标记放置在形状上的位置时如何旋转标记。 marker-start、marker-mid、marker-end 这三个 CSS 属性会将标记分别放置在路径的开始、中间和结束位置。 可以设置markerUnits=”strokeWidth” 使得标记进行缩放来适应路径描边的大小 标记DEMO SVG 中的clipPath SVG 剪裁路径是指根据指定的路径或形状来剪裁 SVG 图形。应用了剪裁路径的图形，在剪裁路径内部的图形可以被显示出来，在剪裁路径之外的图形会被隐藏。 你可以使用任何图形来作为剪裁路径或者被剪裁的对象。可以是文字、圆形、椭圆、多边形或自定义路径。 clipPath DEMO SVG DEFS元素、SYMBOL元素和USE元素 defs 元素：用于预定义一个元素使其能够在 SVG 图像中重复使用。在 defs 元素中定义的图形元素不会直接呈现。 symbol 元素：用于定义可重复使用的符号。 symbol 能够创建自己的视窗，所以能够应用 viewBox 和 preserveAspectRatio 属性。 use 元素：可以在SVG图像中多次重用一个预定义的SVG图形，包括 元素和元素。use 元素可以引入在 defs 元素中定义的图形。 出于安全原因，一些浏览器可能在use元素上应用同源策略，还有可能拒绝载入xlink:href属性内的跨源URI。 defs-symbol-use DEMO SVG元素的样式属性 SVG 元素不同于普通的 HTML 元素，具有特殊的一些样式属性。这些属性的声明可以通过SVG元素属性的方式直接声明，也可以通过 CSS样式表中进行声明。 语法和在 html 里使用 CSS 一样，只不过你要把 background-color、border 改成 fill 和 stroke。 注意，不是所有的属性都能用 CSS 来设置。上色和填充的部分一般是可以用 CSS 来设置的，比如fill，stroke，stroke-dasharray等，但是不包括下面会提到的渐变和图案等功能。另外，width、height，以及路径的命令等等，都不能用css设置。判断它们能不能用CSS设置还是比较容易的。 SVG 规范将属性区分成 properties 和其他 attributes，前者是可以用CSS设置的，后者不能。 以下是一些 CSS2 规范之中未定义的，SVG 独有的部分样式属性： fill：元素的填充颜色 fill-opacity：元素的填充颜色透明度 stroke：元素的笔画颜色 stroke-width：元素的笔画宽度 stroke-linecap：定义元素顶点样式 stroke-dasharray：虚线样式虚线长度 stroke-dashoffset：虚线样式的偏移长度 stroke-linejoin：定义元素之间的连接点的形状 stroke-opacity：元素的笔画颜色透明度 我们可以通过以下方法引用样式属性： 使用属性来添加CSS样式。 使用 STYLE 属性。 使用内联样式表。 这种使用内联样式表的工作方式和在HTML元素上使用内联样式表是完全相同的。样式可以定义在 svg 元素外，也可以定义在 svg 元素内。 .class_name2 { stroke: #0aa; fill: #a0a; } 使用外部样式表来添加CSS样式。 SVG 中的渐变效果 SVG 可以创建和并在填充和描边上应用渐变色。 有两种类型的渐变：线性渐变和径向渐变。你必须给渐变内容指定一个id属性，否则文档内的其他元素就不能引用它。为了让渐变能被重复使用，渐变内容需要定义在 defs 标签内部，而不是定义在形状上面。 线性渐变 线性渐变沿着直线改变颜色，要插入一个线性渐变，你需要在 SVG 文件的 defs 元素内部，创建一个 linearGradient 元素。 gradientUnits：定义用于在渐变元素上指定的属性的坐标系。取值：userSpaceOnUse 、objectBoundingBox，默认值为objectBoundingBox。objectBoundingBox 用百分比表示相对于当前SVG视口的值。userSpaceOnUse 使用绝对单元。 gradientTransform：定义从渐变坐标系到目标坐标系的转换。 x1、y1、x2、y2：起点的和结束点的坐标。用于定义渐变的方向和范围。 spreadMethod：确定如何填充超出定义的渐变边的形状。 pad（默认值）：该值表示渐变的最终颜色填充了超出渐变边缘的形状。 reflect：此值表示渐变超过其边缘反向重复。 repeat：此值指定渐变以原始顺序重复其边缘。 xlink:href：引入其他 linearGradient 元素 线性渐变DEMO 可以在 stop 元素中定义，stop-color 、stop-opacity 、fill 属性，也可以定义在 css 中： linearGradient 元素还需要一些其他的属性值，它们指定了渐变的大小和出现范围。渐变的方向可以通过两个点来控制，它们分别是属性x1、x2、y1和y2，这些属性定义了渐变路线走向。 可以在渐变上使用 xlink:href 属性，使一个渐变的属性和颜色中值（stop）可以被另一个渐变包含引用。 径向渐变 径向渐变与线性渐变相似，只是它是从一个点开始发散绘制渐变。创建径向渐变需要在文档的 defs 中添加一个 radialGradient 元素。 cx、cy：中心点的 x、y 轴坐标。 r：定义圆的半径 fx、fy：定义径向渐变的焦点的 x、y 轴坐标。如果该属性没有被定义，就假定它与中心点是同一位置。 fr：定义径向渐变的焦点的半径。若该属性没有被定义，默认值为 0%。 径向渐变DEMO SVG 中的SMIL动画 SMIL 是 Synchronized Multimedia Integration Language（同步多媒体集成语言）的首字母缩写简称。SMIL 开发组和 SVG 开发组合作开发了 SMIL 动画规范，在规范中制定了一个基本的 XML 动画特征集合。SVG 吸收了 SMIL 动画规范当中的动画优点，并提供了一些 SVG 继承实现。 SMIL允许你做下面这些事情： 动画元素的数值属性（X, Y, …） 动画属性变换（平移或旋转） 动画颜色属性 沿着运动路径运动 不论使用 4 个动画元素中的哪一个，你都需要为它指定一个动画目标。可以使用 xlink:href 属性来指定动画目标。这个属性指向将要执行动画的元素。这个元素必须在当前的 SVG 文档中。动画元素也可以嵌套在 SVG 元素中。如果没有为动画元素指定 xlink:href 属性，那么动画的目标元素就是当前动画元素的直接父元素。 SVG 五大动画元素 set元素 此元素没有动画效果。可以实现基本的延迟功能。即，可以在特定时间之后修改某个属性值（也可以是 CSS 属性值） SVG set元素DEMO animate元素 基础动画元素。实现单属性的动画过渡效果。类似于 CSS3 中的 transition 属性 SVG animate元素DEMO animateTransform 实现 transform 变换动画效果的。 SVG animateTransform元素DEMO animateMotion元素 可以让 SVG 图形沿着特定的 path 路径运动。 SVG animateMotion元素DEMO 与使用 CSS 动画的区别 SVG 元素可以像 HTML 元素一样，使用 CSS keyframes 和 animation 属性或者 CSS transitions 来制作各种动画效果。大多数情况下，一个复杂的动画效果需要组合多种变换效果：旋转、倾斜、缩放以及他们的转换和过渡效果。 多数情况下，SVG元素和HTML元素在使用 transform 和 transform-origin上是相同的。但它们之间也有不同之处: SVG 元素不能使用 box model 来管理，因此，它没有margin、padding、border或content boxes。 默认情况下，一个 HTML 元素的 transform 原点位于该元素的 (50%, 50%) 的地方，这里是元素的中心点。与之不同，SVG 元素的 transform 原点位于当前用户坐标系统的原点上，这个点是画布的左上角位置 SVG 动画的参数详解 attributeName属性 动画属性的名称 可以是元素直接暴露的属性，例如，对于本文反复出现的「马」对应的text元素上的 x, y或者 font-size; 可以是CSS属性。例如，透明度 opacity。 attributeType属性 动画属性的可选值：CSS | XML | auto。 attributeType 支持三个固定参数，CSS、XML、auto。用来表明 attributeName 属性值的列表。x、y 以及 transform 就属于 XML, opacity就属于 CSS。 auto 为默认值，自动判别的意思。 from, to, by, values 类似于CSS3中的关键帧定义。 from：动画的起始值,缺省默认值 to：指定动画的结束值 by：动画的相对变化值 values：用分号分隔的一个或多个值，可以看出是动画的多个关键值点 SVG begin, end 可选值包括： time-value：表示具体的时间值。常见单位有 h | min | s | ms，默认单位为 s 。时间值还支持 hh:mm:ss 这种写法，因此，90s 我们也可以使用 01:30 表示。 offset-value：表示偏移值，数值前面有 + 或 -。 应该指相对于 document 的 begin 值而言。 syncbase-value：基于同步确定的值。语法为：[元素的id].begin/end +/- 时间值。 就是说借用其他元素的 begin 值再加加减减，这个可以准确实现两个独立元素的动画级联效果。 event-value：这个表示与事件相关联的值。类似于 PowerPoint 动画的“点击执行该动画”。语法是： [元素的id].[事件类型] +/- 时间值。 repeat-value：指某动画重复多少次结束之后开始执行动画。语法为： [元素的id].repeat(整数) +/- 时间值。 accessKey-value：定义快捷键。即按下某个按键动画开始。语法为：accessKey(character)。 character 表示快捷键所在的字符。 wallclock-sync-value：指真实世界的时钟时间定义。时间语法是基于在 ISO8601 中定义的语法。 indefinite：表示“无限等待”。需要 beginElement() 方法触发或者指向该动画元素的超链接(SVG中的a元素)。 dur 该属性标识了动画的简单持续时间。常规时间值：clock-value | indefinite。 指定简单持续时间的时长。值必须大于0。可以用小时（h）、分钟（m）、秒（s）、毫秒（ms）表达这个值。可以组合这些时间表达式以提供一个复合的持续时间，比如这样：hh:mm:ss.iii 或者这样：mm:ss.iii。 如果一个动画元素不带有 dur 属性，简单持续时间就是无限期的。 calcMode、keyTimes、 keySplines calcMode 属性支持4个值：discrete | linear | paced | spline。 discrete: from 值直接跳到 to 值。类似于step(1, end)。 linear: animateMotion元素以外元素的calcMode默认值。动画从头到尾的速率都是一致的。 paced: 通过插值让动画的变化步调平稳均匀。仅支持线性数值区域内的属性，这样点之间“距离”的概念才能被计算（如 position, width, height等）。如果paced指定，任何 keyTimes 或 keySplines值将会失效。 spline: 插值定义贝塞尔曲线。spline点的定义在keyTimes属性中，每个时间间隔控制点由keySplines定义。 keyTimes： 是关键时间点的意思。一个以分号分隔的时间值列表，用于控制动画的执行步骤。列表中的每个值与 values 中的值一一对应，定义了 values 中的值在动画中何时执行，keyTimes 列表中的每一个值都是指定在[0-1]之间的浮点数，表示动画的完成时间。 前面提到过 values 也是多值，这里有一些约定的规则：首先，keyTimes 值的数目要和 values 一致，如果是 from/to/by 动画，keyTimes 就必须有两个值。然后对于 linear 和 spline 动画，第一个数字要是0, 最后一个是1。 最后，每个连续的时间值必须比它前面的值大或者相等。 repeatCount, repeatDur repeatCount 表示动画执行次数，可以是合法数值或者 indefinite （动画循环到电脑死机）。 repeatDur 定义重复动画的总时间。可以是普通时间值或者 indefinite（动画循环到电脑死机）。 fill 表示动画间隙的填充方式。支持参数有：freeze | remove。其中remove是默认值，表示动画结束直接回到开始的地方。freeze 表示动画结束后像是被冻住了，元素保持了动画结束之后的状态。 accumulate, additive accumulate 是累积的意思。支持参数有：none | sum。 默认值是 none 。如果值是 sum 表示动画结束时候的位置作为下次动画的起始位置。 additive 控制动画是否附加。支持参数有：replace | sum. 默认值是 replace 。如果值是 sum 表示动画的基础知识会附加到其他低优先级的动画上， restart restart控制重新开启动画的规则。支持的参数有：always | whenNotActive | never. always 是默认值，表示总是，也就是点一次圈圈，马儿跑一下。 whenNotActive 表示动画正在进行的时候，是不能重启动画的。 never 表示动画是一波流。 SVG 与 Javascript 当 SVG 嵌入到 HTML 页面的时候，你可以使用 Javascript 来操作 SVG 元素，就像操作其他 HTML 元素一样。 通过 ID 或 class 获取 SVG 元素 可以读取/修改 SVG 元素的属性值 可以读取/修改 SVG 元素的 css 属性值 可以给 SVG 元素及其子元素添加事件监听 动画的暂停与播放 // svg指当前svg DOM元素 svg.pauseAnimations(); // 暂停 svg.unpauseAnimations(); // 重启动 相关链接 SVG元素在移动H5页面动画的应用 SVG 动画精髓 MDN SVG MDN SVG教程 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:14:36 "},"js探索系列/JavaScript笔记/":{"url":"js探索系列/JavaScript笔记/","title":"JavaScript笔记","keywords":"","body":"README Node.js © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/JavaScript笔记/JavaScript之Ajax.html":{"url":"js探索系列/JavaScript笔记/JavaScript之Ajax.html","title":"JavaScript之Ajax","keywords":"","body":"JavaScript笔记之Ajax 浏览器与服务器之间，采用 HTTP 协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会向服务器发出 HTTP 请求。 1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。这个功能当时并没有引起注意，直到2004年 Gmail 发布和2005年 Google Map 发布，才引起广泛重视。2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本发起通信，就可以叫做 AJAX 通信。W3C 也在2006年发布了它的国际标准。 Ajax 不是指一种单一的技术，而是有机地利用了一系列相关的技术。具体来说，AJAX 包括以下几个步骤。 创建 XMLHttpRequest 实例 发出 HTTP 请求 接收服务器传回的数据 更新网页数据 概括起来，就是一句话，AJAX 通过原生的 XMLHttpRequest 对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。 常用的 Ajax 库有：XMLHttpRequest、Node HTTP、fetch、node-fetch、axios。。。 XMLHTTP XMLHTTP 是一组API函数集，可被 JavaScript、JScript、VBScript 以及其它 web 浏览器内嵌的脚本语言调用，通过 HTTP 在浏览器和 web 服务器之间收发XML或其它数据。 XMLHTTP最大的好处在于可以动态地更新网页，它无需重新从服务器读取整个网页，也不需要安装额外的插件。XMLHTTP 是 Ajax 网页开发技术的重要组成部分。除 XML 之外，XMLHTTP 还能用于获取其它格式的数据，如 JSON 或者甚至纯文本。 XMLHttpRequest XMLHttpRequest 对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有 XML 和 Http，它实际上可以使用多种协议（比如file或ftp，但可能受到更多出于安全等原因的限制），发送任何格式的数据（包括字符串和二进制）。 XMLHttpRequest 本身是一个构造函数，可以使用 new 命令生成实例。它没有任何参数。 下面是 XMLHttpRequest 对象简单用法的完整例子： function sendXMLHttpRequest() { var xhr = new XMLHttpRequest() xhr.withCredentials = true xhr.onreadystatechange = function () { // 通信成功时，状态值为4 if (xhr.readyState === 4) { if (xhr.status === 200) { console.log(xhr.responseText) } else { console.error(xhr.statusText) } } } xhr.onerror = function (e) { console.error(xhr.statusText) } xhr.open('GET', 'http://localhost:3000', true) xhr.send(null) } XMLHttpRequest 的实例属性 1.readyState 返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值： 0：表示 XMLHttpRequest 实例已经生成，但是实例的 open() 方法还没有被调用。 1：表示 open() 方法已经调用，但是实例的 send() 方法还没有调用，仍然可以使用实例的 setRequestHeader() 方法，设定 HTTP 请求的头信息。 2：表示实例的 send() 方法已经调用，并且服务器返回的头信息和状态码已经收到。 3：表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的 responseType 属性等于 text 或者空字符串，responseText 属性就会包含已经收到的部分信息。 4：表示服务器返回的数据已经完全接收，或者本次接收已经失败。 通信过程中，每当实例对象发生状态变化，它的 readyState 属性的值就会改变。这个值每一次变化，都会触发readyStateChange事件。 xhr.onreadystatechange = function(){ if (xhr.readyState === 4){ } } 2.onreadystatechange 指向一个监听函数。readystatechange事件发生时（实例的 readyState属性变化），就会执行这个属性。另外，如果使用实例的 abort()方法，终止 XMLHttpRequest请求，也会造成 readyState属性变化。 3.response 表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由XMLHttpRequest.responseType 属性决定。该属性只读。 如果本次请求没有成功或者数据不完整，该属性等于null。但是，如果 responseType 属性等于text或空字符串，在请求没有结束之前（readyState等于3的阶段），response属性包含服务器已经返回的部分数据。 4.responseType 该属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用 open() 方法之后、调用 send() 方法之前，设置这个属性的值，告诉服务器返回指定类型的数据。如果responseType设为空字符串，就等同于默认值text。 可以取以下值： ”“（空字符串）：等同于 text，表示服务器返回文本数据。 “arraybuffer”：ArrayBuffer 对象，表示服务器返回二进制数组。 “blob”：Blob 对象，表示服务器返回二进制对象。 “document”：Document 对象，表示服务器返回一个文档对象。 “json”：JSON 对象。 “text”：字符串。 上面几种类型之中，text 类型适合大多数情况，而且直接处理文本也比较方便。document 类型适合返回 HTML / XML 文档的情况，这意味着，对于那些打开 CORS 的网站，可以直接用 Ajax 抓取网页，然后不用解析 HTML 字符串，直接对抓取回来的数据进行 DOM 操作。blob类型适合读取二进制数据，比如图片文件。 function loadImage() { var xhr = new XMLHttpRequest() xhr.withCredentials = true xhr.open('GET', 'assets/img/20190419141710_4735vxaqwhri_small.jpg', true) xhr.responseType = 'blob' xhr.onload = function (e) { var img = document.createElement('img') img.style.width = '100%' img.src = window.URL.createObjectURL(this.response) document.body.appendChild(img) } xhr.send() } 查看DEMO 5.responseText 返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。 6.responseXML 返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。如果本次请求没有成功，或者收到的数据不能被解析为 XML 或 HTML，该属性等于null。 该属性生效的前提是 HTTP 回应的 Content-Type 头信息等于 text/xml 或 application/xml。这要求在发送请求前，XMLHttpRequest.responseType属性要设为 document。如果 HTTP 回应的 Content-Type 头信息不等于 text/xml 和 application/xml，但是想从 responseXML拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用XMLHttpRequest.overrideMimeType() 方法，强制进行 XML 解析。 该属性得到的数据，是直接解析后的文档 DOM 树。 var xhr = new XMLHttpRequest() xhr.open('GET', '/server', true) xhr.responseType = 'document' xhr.overrideMimeType('text/xml') xhr.onload = function () { if (xhr.readyState === 4 && xhr.status === 200) { console.log(xhr.responseXML) } } xhr.send(null) 7.responseURL 该属性是字符串，表示发送数据的服务器的网址。 注意：这个属性的值与 open() 方法指定的请求网址不一定相同。如果服务器端发生跳转，这个属性返回最后实际返回数据的网址。另外，如果原始 URL 包括锚点（fragment），该属性会把锚点剥离。 8.status 返回一个整数，表示服务器回应的 HTTP 状态码。一般来说，如果通信成功的话，这个状态码是200；如果服务器没有返回状态码，那么这个属性默认是200。请求发出之前，该属性为0。该属性只读。 200：OK，访问正常 301：Moved Permanently，永久移动 302：Move temporarily，暂时移动 304：Not Modified，未修改 307：Temporary Redirect，暂时重定向 401：Unauthorized，未授权 403：Forbidden，禁止访问 404：Not Found，未发现指定网址 500：Internal Server Error，服务器发生错误 9.statusText 返回一个字符串，表示服务器发送的状态提示。不同于status属性，该属性包含整个状态信息，比如 OK和 Not Found 。在请求发送之前（即调用open()方法之前），该属性的值是空字符串；如果服务器没有返回状态提示，该属性的值默认为 OK 。该属性为只读属性。 10.timeout 返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。 11.ontimeout 用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。 12.事件监听属性 XMLHttpRequest 对象可以对以下事件指定监听函数。 onloadstart：loadstart 事件（HTTP 请求发出）的监听函数 onprogress：progress事件（正在发送和加载数据）的监听函数 onabort：abort 事件（请求中止，比如用户调用了abort()方法）的监听函数 onerror：error 事件（请求失败）的监听函数 onload：load 事件（请求成功完成）的监听函数 ontimeout：timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数 onloadend：loadend 事件（请求完成，不管成功或失败）的监听函数 progress 事件的监听函数有一个事件对象参数，该对象有三个属性： loaded：返回已经传输的数据量 total：属性返回总的数据量 lengthComputable：属性返回一个布尔值，表示加载的进度是否可以计算。 所有这些监听函数里面，只有progress事件的监听函数有参数，其他函数都没有参数。 注意：如果发生网络错误（比如服务器无法连通），onerror 事件无法获取报错信息。 13.withCredentials 该属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为false，即向example.com发出跨域请求时，不会发送example.com设置在本机上的 Cookie（如果有的话）。 如果需要跨域 AJAX 请求发送 Cookie，需要 withCredentials 属性设为 true。注意，同源的请求不需要设置这个属性。 为了让这个属性生效，服务器必须显式返回 Access-Control-Allow-Credentials 这个头信息。 Access-Control-Allow-Credentials: true withCredentials属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果withCredentials属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。 注意：脚本总是遵守同源政策，无法从document.cookie或者 HTTP 回应的头信息之中，读取跨域的 Cookie，withCredentials属性不影响这一点。 14.upload XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过 XMLHttpRequest.upload 属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。 当请求一切正常时，相关的事件触发顺序如下： xhr.onreadystatechange //之后每次readyState变化时，都会触发一次 xhr.onloadstart //上传开始 xhr.upload.onloadstart xhr.upload.onprogress xhr.upload.onload xhr.upload.onloadend //上传结束 xhr.onprogress xhr.onload xhr.onloadend XMLHttpRequest 的实例方法 1.open() 用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数： xhr.open(method, url, async, user, password) method：表示 HTTP 动词方法，比如GET、POST、PUT、DELETE、HEAD等。 url：表示请求发送目标 URL。 async：布尔值，表示请求是否为异步，默认为true。如果设为false，则send()方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为false。 user：表示用于认证的用户名，默认为空字符串。该参数可选。 password：表示用于认证的密码，默认为空字符串。该参数可选。 注意，如果对使用过open()方法的 AJAX 请求，再次使用这个方法，等同于调用 abort() ，即终止请求。 2.send() 用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只包含头信息，也就是只有一个 URL，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。 其参数技多种格式：ArrayBufferView、Blob、Document、String、FormData。 注意，所有 XMLHttpRequest 的监听事件，都必须在send()方法调用之前设定。 3.setRequestHeader() 用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在open()之后、send()之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。 xhr.setRequestHeader('Content-Type', 'application/json') 4.overrideMimeType() 用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是text/xml，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成text/plain，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。 xhr.overrideMimeType('text/plain') 注意，该方法必须在send()方法之前调用。 5.getResponseHeader() 返回 HTTP 头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，返回null。该方法的参数不区分大小写。 如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。 6.getAllResponseHeaders() 返回一个字符串，表示服务器发来的所有 HTTP 头信息。格式为字符串，每个头信息之间使用CRLF分隔（回车+换行），如果没有收到服务器回应，该属性为null。如果发生网络错误，该属性为空字符串。 7.abort() 用来终止已经发出的 HTTP 请求。调用这个方法以后，readyState属性变为4，status属性变为0。 XMLHttpRequest 实例的事件 更多现代浏览器，包括 Firefox，除了可以设置 on* 属性外，也提供标准的监听器 addEventListener() API 来监听 XMLHttpRequest 事件。 xhr.addEventListener('readystatechange', () => {}) 1.readyStateChange 事件 readyState 属性的值发生改变，就会触发 readyStateChange 事件。 我们可以通过 onReadyStateChange 属性，指定这个事件的监听函数，对不同状态进行不同处理。尤其是当状态变为4的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。 2.progress 事件 上传文件时，XMLHTTPRequest 实例对象本身和实例的upload属性，都有一个progress事件，会不断返回上传的进度。 3.load 事件、error 事件、abort 事件、loadend 事件 load 事件：表示服务器传来的数据接收完毕 error 事件：表示请求出错 abort 事件：表示请求被中断（比如用户取消请求） loadend 事件：abort、load、error 这三个事件，会伴随一个 loadend 事件，表示请求结束，但不知道其是否成功。 4.timeout 事件 服务器超过指定时间还没有返回结果，就会触发 timeout 事件。 常见问题 Ajax 和 XMLHttpRequest 的正确理解 ajax 是 asynchronous javascript and XML的简写，中文翻译是异步的 javascript 和 XML，这一技术能够向服务器请求额外的数据而无须卸载页面，会带来更好的用户体验。它是一种技术方案，但并不是一种新技术。 XMLHttpRequest（XHR）是可用于 Web 浏览器脚本语言（例如JavaScript）的API。它用于将 HTTP 或 HTTPS 请求发送到 Web 服务器，并将服务器响应数据加载回脚本中。 就是一句话，ajax 通过原生的 XMLHttpRequest 对象发出HTTP请求，得到服务器返回的数据后，再进行处理。 响应头取Date异常 获取请求响应中的Date对象: res.request.getResponseHeader(\"Date\")，在浏览器中报错Refused to get unsafe header \"Date\"。 原因：默认的请求上， 浏览器只能访问以下默认的响应头 Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 解决：想让浏览器能访问到其他的 响应头的话 需要在服务器上设置 Access-Control-Expose-Headers。比如想获取时间Access-Control-Expose-Headers : 'Date' 参考链接 阮一峰 JavaScript 标准参考教程（alpha）- Ajax MDN XMLHttpRequest © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-14 23:44:32 "},"js探索系列/JavaScript笔记/JavaScript之Promise.html":{"url":"js探索系列/JavaScript笔记/JavaScript之Promise.html","title":"JavaScript之Promise","keywords":"","body":"JavaScript笔记之Promise Promise含义 Promise是一个对象，它代表了一个异步操作的最终完成或者失败。 Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 理想状态下，Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理（）。但有一些 API 仍然使用旧方式来传入的成功（或者失败）的回调。典型的例子就是 setTimeout() 函数。 Promise对象有以下特点： 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 Promise也有一些缺点： 无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。会在chrome的控制台上打印，但不影响其他代码执行。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise基础用法 const promise = new Promise((resolve, reject) => { // ... some code if (/* 异步操作成功 */){ resolve(value) } else { reject(error) } }) Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。其中，resolve函数的作用是，将Promise对象的状态从即从 pending变为 fulfilled，即，异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从从 pending变为 rejected，即，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 promise.then(value => { // success }, err => { // failure }); Promise实例生成后立即执行，然后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 Promise的一些约定 在本轮 事件循环 运行完成之前，回调函数是不会被调用的。 同步语句是按顺序，立即执行 Promise.resolve()在本轮 ”事件循环” 结束时执行 setTimeout(fn, 0)是零延迟，不过，这并不意味着回调会立即执行，它是在下一轮 “事件循环” 开始时执行。基本上，setTimeout 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。 setTimeout(function () { console.log('three') }, 0) Promise.resolve().then(function () { console.log('two') }); console.log('one') // one // two // three 即使异步操作已经完成（成功或失败），在这之后通过 then() 添加的回调函数也会被调用。 通过多次调用 then() 可以添加多个回调函数，它们会按照插入顺序执行。这就是Promise的链式调用（chaining）。 常见的Promise封装（图片加载、Ajax请求） function loadImage(url) { return new Promise((resolve, reject) => { const image = new Image() image.onload = function () { resolve(image) } image.onerror = function () { reject(new Error(`加载出错： ${url}`)) } image.src = url }) } loadImageAsync('./assets/img/pins_3338674420.jpg').then(res => { console.log('加载成功！', './assets/img/pins_3338674420.jpg') }, err => { console.log('加载失败！', './assets/img/pins_3338674420.jpg') }) function getText(url) { return new Promise((resolve, reject) => { const http = new XMLHttpRequest() http.open(\"GET\", url) http.onreadystatechange = function () { if (this.readyState !== 4) { return } if (this.status === 200) { return resolve(this.response) } else { return reject(new Error(this.statusText)) } } http.send() }) } getText(\"./assets/other/%E7%BE%8E%E4%BA%BA%E8%B0%B7%20-%20%E9%98%BF%E5%85%B0.vtt\").then(json => { console.log('Contents: ' + json) }, error => { console.error('出错了', error) }) promise原型对象方法 then() Promise.prototype.then()的作用是为 Promise实例添加状态改变时的回调函数。then里的两个参数都是可选的，如：catch(failureCallback) 是 .then(null, rejection)或.then(undefined, rejection) 的缩略形式。 then方法的第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数。如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。 reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise实例。如果resolve方法返回的是一个Promise对象（即有异步操作），那么，后一个then方法中的第一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 调用resolve或reject并不会终结 Promise 的参数函数的执行。也就是说，其后面还可以执行其它语句，但是，一般不建议这么做。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。then方法中可以用return来返回参数，在后一个then的回调函数中接收。 Promise.resolve().then(res => { return 'aa' }).then(res => { console.log(res) }, err => { console.log(err) //aa }) catch() Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 loadImageAsync('./img/pins_3338674420.jpg').then(res => { console.log('加载成功！') }, err => { console.log(err.message) }) loadImageAsync('./img/pins_3338674420.jpg').then(res => { console.log('加载成功！') }).catch( err => { console.log(err.message) }) 上面代码中，loadImageAsync()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。 Promise 状态已经变成resolved，再抛出错误是无效的。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 const promise = new Promise((resolve, reject) => { resolve('ok') throw new Error('test') //无法被catch捕获 }); promise.then(function(value) { console.log(value) }).catch(error => { console.log(error) }); Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()或者catch()方法。 finally() Promise.prototype.finally()用于指定不管 Promise 对象最后状态如何，都会执行的操作，即，不依赖于 Promise 的执行结果。该方法是 ES2018 引入标准的。 promise .then(result => {···}) .catch(error => {···}) .finally(() => {···}); finally()的实现： Promise.prototype.finally = function (callback) { let P = this.constructor return this.then( value => P.resolve(callback()).then(() => value), reason => P.resolve(callback()).then(() => { throw reason }) ) } Promise静态方法 all() Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。Promise.all()方法的参数可以是数组或者其他具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 const p = Promise.all([p1, p2, p3]) p的状态由p1、p2、p3决定： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 p1、p2、p3有catch方法，会调用自己的catch（）方法；没有就会调用Promise.all()的catch方法。 race() Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。Promise.race()方法的参数与Promise.all()方法一样 const p = Promise.race([p1, p2, p3]); 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 应用场景：如，对一个异步请求做超时判断 const p = Promise.race([ loadImageAsync('./img/pins_3338674420.jpg'), new Promise( (resolve, reject) => { setTimeout(() => reject(new Error('request timeout')), 1000) }) ]) p.then(console.log).catch(console.error) allSettled() Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。 Promise.allSettled()方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。数组中的每个Promise实例都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。 应用场景：不关心异步操作的结果，只关心这些操作有没有结束。 any() Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。该方法目前是一个第三阶段的提案 。 Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。 resolve() Promise.resolve()方法用于现有对象转为 Promise 对象。 Promise.resolve('foo') // 等价于 new Promise(resolve => resolve('foo')) Promise.resolve方法的参数分成四种情况： 参数是一个 Promise 实例：不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象：将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 let thenable = { //thenable对象指的是具有then方法的对象 then: function(resolve, reject) { resolve(42); } }; let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value); // 42 }); 参数不是具有then方法的对象，或根本就不是对象：如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。Promise.resolve方法的参数，会同时传给回调函数。 不带有任何参数：直接返回一个resolved状态的 Promise 对象。 reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 const p = Promise.reject('出错了'); // 等同于 const p = new Promise((resolve, reject) => reject('出错了')) p.then(null, function (s) { console.log(s) }); 注意：Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续回调方法的参数。这一点与Promise.resolve方法不一致。 try() Promise.try()是现在有一个提案，Promise 来统一处理同步函数和异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。 一般就会采用下面的写法： const f = () => console.log('now'); Promise.resolve().then(f); console.log('next'); // next // now 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行，即就是说，它并没有像同步函数一个立即执行。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法： 用async函数来写 const f = () => console.log('now') (async () => f())() console.log('next') // now // next 使用new Promise() const f = () => console.log('now'); ( () => new Promise(resolve => resolve(f())) // 或者 // () => Promise.resolve(f()) )() console.log('next') // now // next Promise.try方法替代上面的写法： const f = () => console.log('now'); Promise.try(f); console.log('next'); // now // next Promise 拒绝事件 rejectionhandled 当一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发rejectionhandled事件： // 不会触发 window.addEventListener(\"rejectionhandled\", event => { console.log(\"拒绝原因: \" + event.reason) }, false) let p = Promise.reject('rejected').then(res => {}, err => {}) // 触发 window.addEventListener(\"rejectionhandled\", event => { console.log(\"拒绝原因: \" + event.reason) }, false) let p = Promise.reject('rejected') setTimeout(() => { // 或者 p.catch(e =>{}) p.then(res => {}, err => {}) }, 1000) unhandledrejection 当 Promise 被拒绝，但没有提供 reject 函数来处理该 rejection 时，会派发此事件。 //window window.addEventListener(\"unhandledrejection\", event => { /* 你可以在这里添加一些代码，以便检查 event.promise 中的 promise 和 event.reason 中的 rejection 原因 */ //告诉 JavaScript 引擎当 promise 被拒绝时不要执行默认操作，默认操作一般会包含把错误打印到控制台。 event.preventDefault() }, false) new Promise((resolve, reject) => { x = x + 1 }).then(() => {}) //Node.js process.on('unhandledRejection', (reason, promise) => { }) promise串行运行 以下是用 Promise 来包裹 setTimeout() 函数，并返回 promise 实例，作测试用例： const func1 = () => new Promise(resolve => { setTimeout(() => { console.log('func1') resolve('func1') }, 2000) }) const func2 = () => new Promise(resolve => { setTimeout(() => { console.log('func2') resolve('func2') }, 1000) }) const func3 = () => new Promise(resolve => { setTimeout(() => { console.log('func3') resolve('func3') }, 1000) }) Promise.all() 和 Promise.race()是并行运行异步操作的两个函数，其参数中的 Promise 实例，是并行执行的，不存在等待关系。 Promise.all([func1(), func2(), func3()]).then(res => { console.log('Promise.all：', res) }) /* func2 func3 func1 Promise.all： (3) ['func1', 'func2', 'func3'] /* 查看DEMO Promise 串行运行，即 promise1 运行完，再运行 promise2。。。，可以通过以下方法实现： Promise 链式调用 Promise.resolve().then(func1).then(func2).then(func3).then(res => { console.log('参数：', res) }) /* func1 func2 func3 参数： func3 */ 查看DEMO 依次调用 func1、func2、func3，返回 func3 的执行结果。 for 版本 function sequencePromisesWithForThen (promises) { function recordValue(results, value) { results.push(value) return results } // 记录每个Promise实例的执行结果。如果不调用此方法，函数最后的Promise的传递出来的参数，只有最后一个Promise实例的执行结果 let pushValue = recordValue.bind(null, []) let promise = Promise.resolve() for (let i = 0; i { console.log('sequencePromisesWithForThen：', res) }) /** func1 func2 func3 sequencePromisesWithForThen： (3) ['func1', 'func2', 'func3'] **/ 查看DEMO reduce 版本 function sequencePromisesWithReduce (promises) { function recordValue(results, value) { results.push(value) return results } // 记录每个Promise实例的执行结果。如果不调用此方法，函数最后的Promise的传递出来的参数，只有最后一个Promise实例的执行结果 let pushValue = recordValue.bind(null, []) return promises.reduce((promise, task) => { return promise.then(task).then(pushValue) }, Promise.resolve()) } sequencePromisesWithReduce([func1, func2, func3]).then(res => { console.log('sequencePromisesWithReduce：', res) }) /** func1 func2 func3 sequencePromisesWithReduce： (3) ['func1', 'func2', 'func3'] **/ 查看DEMO async/await async function sequencePromisesForAsync(promises) { let result for (let f of promises) { result = await f(result) } console.log('sequencePromisesForAsync：', result) return result } sequencePromisesForAsync([func1, func2, func3]) /** func1 func2 func3 sequencePromisesForAsync： func3 **/ 查看DEMO 注意：以上串行运行方法中的参数是函数，不是 Promise 对象。 常见问题 IE 不技持 Promise 引入 polyfill.js ： 或者通过 node安装并引入@babel/polyfill npm i @babel/polyfill -S // js文件中引入 import '@babel/polyfill' Promise嵌套 优先执行 Promsie 构造其中的同步任务，再执行then方法。 new Promise((resolve, reject) => { console.log('1') resolve() new Promise((resolve, reject) => { console.log('2') resolve() }).then(() => { console.log('3') }) }).then(() => { console.log('4') }) /** 1 2 3 4 ** 参考链接 MDN promise 阮一峰 ECMAScript 6 入门 promise © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-13 22:08:51 "},"js探索系列/JavaScript笔记/JavaScript之Touch事件.html":{"url":"js探索系列/JavaScript笔记/JavaScript之Touch事件.html","title":"JavaScript之Touch事件","keywords":"","body":"JavaScript笔记之Touch事件 为了给基于触摸的用户界面提供高质量的支持，Touch 事件提供了在触摸屏或触控板上解释手指（或触控笔）活动的能力。 Touch 事件接口是较为底层的 API，可为特定程序提供多点触控交互（比如双指手势）的支持。多点触控交互开始于一个手指（或触控笔）开始接触设备平面的时刻。随后其他手指也可触摸设备表面，并随意进行划动。当所有手指离开设备平面时，交互结束。整个交互期间，程序接收开始、移动、结束三个阶段的触摸事件。 触摸事件的API 浏览器的触摸 API 由三个部分组成。 Touch：表示用户与触摸表面间的一个单独的接触点。 TouchList：表示一组 Touch，用于多点触控的情况。 TouchEvent：表示位于表面上的一个触摸点的某个状态发生改变时产生的事件。 Touch 接口的实例对象用来表示触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由 TouchList 接口的实例对象表示。TouchEvent 接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。 在很多情况下，触摸事件和鼠标事件会同时被触发（目的是让没有对触摸设备优化的代码仍然可以在触摸设备上正常工作）。如果你使用了触摸事件，可以调用 event.preventDefault() 来阻止鼠标事件被触发。 触摸事件的类型 为了区别触摸相关的状态改变，存在多种类型的触摸事件。可以通过检查触摸事件的 TouchEvent.type 属性来确定当前事件属于哪种类型。触摸引发的事件有以下几种： touchstart：当用户在触摸平面上放置了一个触点时触发。事件的目标元素将是触点位置上的那个目标元素。 touchend：当一个触点被用户从触摸平面上移除（即用户的一个手指或手写笔离开触摸平面）时触发。当触点移出触摸平面的边界时也将触发。例如用户将手指划出屏幕边缘。 事件的目标元素与触发 touchstart 事件的目标元素相同，即使 touchend 事件触发时，触点已经移出了该元素 。 已经被从触摸平面上移除的触点，可以在 changedTouches 属性定义的 TouchList 中找到。 touchmove：当用户在触摸平面上移动触点时触发。事件的目标元素和触发 touchstart 事件的目标元素相同，即使当 touchmove 事件触发时，触点已经移出了该元素 。 当触点的半径、旋转角度以及压力大小发生变化时，也将触发此事件。 touchcancel：当触点由于某些原因被中断时触发。有几种可能的原因如下（具体的原因根据不同的设备和浏览器有所不同）： 由于某个事件出现而取消了触摸：例如触摸过程被弹窗打断。 触点离开了文档窗口，而进入了浏览器的界面元素、插件或者其他外部内容区域。 当用户产生的触点个数超过了设备支持的个数，从而导致 TouchList 中最早的 Touch 对象被取消。 Touch接口 Touch 对象表示在触控设备上的触摸点。通常是指手指或者触控笔在触屏设备或者触摸板上的操作。Touch 对象代表一个触点，每个触点包含位置，大小，形状，压力大小，和目标元素属性。 Touch 对象可以通过以下属性获取，需要注意的是，这三个属性是有区别： touches：当前屏幕上所有触摸点的集合列表 targetTouches：绑定事件的那个结点上的触摸点的集合列表 changedTouches：触发事件时改变的触摸点的集合 Touch对象的属性 clientX: 341.6842346191406 clientY: 229.68423461914062 force: 1 identifier: 0 pageX: 341.6842346191406 pageY: 229.68423461914062 radiusX: 12.105263710021973 radiusY: 12.105263710021973 region: null rotationAngle: 0 screenX: 345.6000061035156 screenY: 356 target: canvas.element_canvas1 identifier：只读。此 Touch 对象的唯一标识符。 一次触摸动作（例如手指触摸）在平面上移动的整个过程中，该标识符不变。可以根据它来判断跟踪的是否是同一次触摸过程。 screenX、screenY：只读。触点相对于屏幕左边缘的X坐标、上边缘的Y坐标。 clientX、clientY：只读。触点相对于可见视区左边缘的X坐标、上边缘的Y坐标。不包括任何滚动偏移。 pageX、pageY：只读。触点相对于HTML文档左边缘的X坐标、上边缘的Y坐标。当存在水平、垂直滚动的偏移时，这个值包含了水平、垂直滚动的偏移。 target：只读。返回触摸点最初接触的元素，即使这个触摸点已经移出那个元素的交互区域。 需要注意的是：如果这个元素在触摸过程中被移除，这个事件仍然会指向它，因此这个事件也不会冒泡到 window 或 document 对象。所以，如果有元素在触摸过程中可能被移除，最佳实践是将触摸事件的监听器绑定到这个元素本身，防止元素被移除后，无法再从它的上一级元素上侦测到从该元素冒泡的事件。 radiusX、radiusY：只读。返回能够包围接触区域的最小椭圆的水平轴（X轴）、垂直轴（Y轴）半径。 rotationAngle：只读。返回一个0到90的角度值，表示上述由 radiusX 和 radiusY 描述的椭圆为了尽可能精确地覆盖用户与平面之间的接触区域而需要顺时针旋转的角度。 force：只读。返回用户对触摸平面的压力大小，是一个从0.0(没有压力)到1.0(最大压力)的浮点数。 region：暂时没有找相关说明。 TouchList接口 TouchList 接口代表一个触摸平面上所有触点的列表。例如，如果一个用户用三根手指接触屏幕（或者触控板），与之对应的 TouchList 会包含每根手指的 Touch 对象，总共三个。 TouchList对象的属性和方法： length：只读。返回TouchList中 Touch 对象的数量。 identifiedTouch()：列表中标示符与指定值匹配的第一个Touch 对象会被返回。 item()：返回列表中以指定值作为索引的 Touch 对象。 TouchEvent接口 TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等。 TouchEvent 的属性继承了 UIEvent 和 Event： altKey: false ctrlKey: false shiftKey: false metaKey: false touches: TouchList {0: Touch, length: 1} targetTouches: TouchList {0: Touch, length: 1} changedTouches: TouchList {0: Touch, length: 1} // Event事件属性 currentTarget: null srcElement: canvas.element_canvas1 target: canvas.element_canvas1 type: \"touchstart\" bubbles: true // 该事件是否会在 DOM 中冒泡 cancelBubble: false // stopPropagation() 的历史别名。在事件处理器函数返回之前，将此属性的值设置为 true，亦可阻止事件继续冒泡 cancelable: true // 表示事件是否可以取消 composed: true // 表示事件是否可以穿过 Shadow DOM 和常规 DOM 之间的隔阂进行冒泡 defaultPrevented: true // 表示 preventDefault() 方法是否取消了事件的默认行为 eventPhase: 0 // 表示事件流正被处理到了哪个阶段 isTrusted: true // 表示事件是由浏览器（例如用户点击）发起的，还是由脚本（使用事件创建方法）发出的。 path: // 一个由事件流所经过的 DOM 节点组成的数组。实验中，可能用 deepPath 类似 returnValue: false // 旧版 IE 引入的一个非标准历史属性，为保证依赖此属性的网页正常运作，此属性最终被收入规范 timeStamp: 2128.1449999660254 // 事件创建时的时间戳（精度为毫秒） // UIEvent事件属性 sourceCapabilities: // 返回的一个实例InputDeviceCapabilities，其提供了关于负责产生的触摸事件，物理装置信息的接口。 detail: 0 // 当值为非空的时候, 提供当前点击数(和环境有关) 。 view: // 返回的生成事件的 document.defaultView 对象。在浏览器中，这是事件所在的 Window 对象。 which: 0 // 返回一个对应（键盘）按下的数字类型的 keyCode ，或者一个字母数字键按下时的字符码 type：表示事件的类型，不区分大小写。 altKey：布尔值，表示触摸时是否按下了 Alt 键。 ctrlKey：布尔值，表示触摸时是否按下了 Ctrl 键。 shiftKey：布尔值：表示触摸时是否按下了 Shift 键。 metaKey：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。 touches：当前屏幕上所有触摸点的集合列表。 targetTouches：绑定事件的那个结点上的触摸点的集合列表。 changedTouches：触发事件时改变的触摸点的集合。 currentTarget：指向事件所绑定的元素，是监听事件者。在事件处理程序内部，对象 this 始终等于currentTarget 的值。 target：指向事件发生时的元素，是事件的真正发出者。IE有兼容问题。 srcElement：和 target 相同，firFox 不兼容。 // 获取直接目标对象的兼容写法 let target = e.target || e.srcElement 常见问题 targetTouches 和 changedTouches 的区别 targetTouches 是当前触摸元素上的触摸点的集合列表；changedTouches 是触发事件时改变的触摸点的集合，包括已经被从触摸平面上移除的触点。 所以，在 touchend、touchcancel 事件中，只能用 changedTouches 获取 Touch 对象。 300ms延迟 移动浏览器会在 touchend 和 click 事件之间，等待 300 - 350 ms，判断用户是否会进行双击手势用以缩放文字。 这是因为触摸屏幕的行为被重载(overload)了。在手指触摸屏幕的瞬间，浏览器无法预知用户是在轻触(Tap)、双触(Double-Tap)、滑动(Swipe)、按住不放(Hold)还是其他什么操作。唯一保险的做法就是等上一会儿看接下来会发生什么。 解决方案一： 禁用缩放。注：浏览器可能不支持。 html { /*注意浏览器前缀*/ touch-action: manipulation; } 解决方案二： 改变视口宽度。为用户适配了页面大小和阻止了用户缩放，浏览器就不用再判断用户双击缩放了，于是便自动取消了click事件的 300ms 延迟。注：safari 浏览器可能不支持。 解决方案三： 引用 fastclick 库。（不推荐） 原理: 移动端点击事件发生时，会触发 touchStart -> touchMove -> touchEnd -> click ，fastclick 是在监听到 touchEnd 事件时，立即触发click事件，并阻止原来事件的发生。 缺点： 可以会引起表单 input 元素获取焦点时，唤起软件键的一些异常；还有其他Bug。 实时获取触摸点所在位置的元素 touchmove 事件的目标元素和触发 touchstart 事件的目标元素相同，即使当 touchmove 事件触发时，触点已经移出了该元素 。如果要实时获取触摸点所在位置的元素，普通方法已不奏效。 解决方案一(推荐)： //获取存储当前触摸点位置的对象，取clientX及clientY，再通过 elementFromPoint 获取当前触摸位置的元素 let myLocation = e.originalEvent.changedTouches[0]; let realTarget = document.elementFromPoint(myLocation.clientX, myLocation.clientY); 此方法返回的是最顶层的元素，所以务必将你需要的元素的 z-index 设置为最高。由于手机兼容性问题。touchmove 事件的监听函数需加上 e.stopPropagation 和 e.preventDefault。 解决方案二： 在父元素上定义 touchmove 事件。 touchend监听事件无法触发 部分安卓机中，touchend 事件无效。 解决方案一：在 touchstart 或者 touchmove 事件的监听函数中，阻止事件的默认行为 event.preventDefault()，那么到 touchend 就能正常触发。 touchend是触发了，但页面默认滚动页面被阻止掉了。 在安卓4.0系统（即Android ICS系统），如果在 touchstart 和第一个 touchmove 触发时，没有调用 preventDefault，那么后面 touchmove（连续触发）以及最后的 touchend 都不会被触发。所以我们需要决定第一个 touchmove 是否是一个滚动事件（如果是，则不能 preventDefault 阻止默认行为），然后手动触发touchend。 解决方案二：同时绑定 touchcancel 和 touchend 事件 这个可以解决 touchend 的触发问题，但其实还不是最优解，touchend 还是比较难触发。最根本的还是寄希望于谷歌尽早解决这个历史遗留bug。 参考资料 MDN Touch MDN 触摸事件 阮一峰 触摸事件 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/JavaScript笔记/JavaScript之键盘事件.html":{"url":"js探索系列/JavaScript笔记/JavaScript之键盘事件.html","title":"JavaScript之键盘事件","keywords":"","body":"键盘事件 键盘事件 三个键盘事件：keydown、keypress、keyup 事件触发顺序：keydown -> keypress -> keyup keydown：当用户按下任意键时触发，而且按住不放的话，会重复触发此事件。 keypress：当用户按下字符键时触发，而且按住不放的话，会重复触发此事件。但功能键不一定能触发这个事件。 keyup：当用户释放键时触发。 键盘事件的触发过程具体是这样的：在用户按下键盘上的一个字符键时， 首先会触发keydown事件，然后是keypress事件，最后是keyup事件。其中，keydown、keypress事件是在文本框发生变化之前 被触发；而keyup在文本框发生变化之后被触发。如果用户按下一个键不放，就会重复触发keydown、keypress事件。在用户按下一个功能键时，首先触发keydown事件，然后就是keyup事件。如果用户按下一个键不放，就会重复触发keydown。 在keyup 事件中无法阻止浏览器默认事件，因为在keypress时，浏览器默认行为已经完成，即，将文字输入文本框（尽管这时还没显示），这个时候不管是preventDefault还是return Value = false，都不能阻止在文本框中输入文字的行为，如要阻止默认行为，必须在keydown或keypress时阻止。 键盘键分类 键盘中的键分为字符键（可打印）和功能键（不可打印），系统功能键包括如下：Esc、Tab、Caps Lock、Shift、Ctrl、Alt、Enter、Backspace、Print Screen、Scroll Lock、Pause Break、Insert、Delete、Home、End、Page Up、Page Down， F1 ~ 12，Num Lock、The Arrow Keys。 keydown和keyup均可以对系统功能键进行有效的拦截，但事件截获的位置不同；keypress事件不能对系统功能键（例如：后退、删除等）、中文输入法进行正常的响应， keypress响应系统功能键总结： Firefox：支持 Esc、Enter、Backspace、Pause Break、Insert、Delete、Home、End、Page Up、Page Down、F1 ~ F12、The Arrow Keys、支持 The Arrow Keys Chrome、Oprea、Safari：支持Enter、不支持 The Arrow Keys IE：支持Esc、Enter、不支持 The Arrow Keys 中文输入法（浏览器之间表现得不太一致）： firfox：输入触发keydown，回车确认输入触发keyup chrome：输入触发keydown、keyup，回车确认输入只触发keydown IE：输入触发keydown、keyup，回车确认输入触发keydown，keyup Safari：输入触发keydown、keyup，回车确认输入触发keydown，keyup opera：输入触发keydown、keyup，回车确认输入触发keydown，keyup 键盘事件的取值 keyCode(键码)：就是字母或数字对应的ASCII码。在发生keydown、keypress、keyup事件时，可在event对象中获取。 在FF、Opera中，按分号键时keyCode值为59，但IE、Chrome、Safari则返回186 在Safari3之前的版本中，上、下、左、右箭头和上翻(PageUp)、下翻(PageDown)键返回大于63000的值 which： charCode(字符编码)：就是按下的字符键对应的ASCII编码。 keypress事件中，FF、Chrome、Safari的event对象都支持一个charCode属性，这个属性在按下非字符键或发生keydown和keyup事件时值为0； IE、Opera则是在keyCode中 保存字符键的ASCII编码。 所以，要想跨浏览器获得字符编码，代码如下： //获取字符编码，可以使用String.fromCharCode()将其转换为实际的字符。 var getCharCode = function(event){ var charcode = event.charCode; if(typeof charcode === \"number\" && charcode != 0){ return charcode; }else{ //在中文输入法下 keyCode === 229 || keyCode === 197(Opera) return event.keyCode; } }; 事件取值兼容情况 keydown、keyup表现一致，keypress与两者有差异 keydown、keyup事件中，字符键、功能键可获取keyCode、witch值，但charCode=0 keypress事件中，字符键可获取keyCode、witch、charCode值。有些浏览器中，功能键不一定能触发此事件 keypress事件的keyCode对字母的大小写敏感，而keydown、keyup事件不敏感 keypress事件的which值无法区分主键盘上的数字键和附键盘数字键的，而keydown、keyup的which值对主附键盘的数字键敏感。 IE(ie9以下，ie 11正常)，keydown、keyup 事件中只有一个属性keyCode属性，keycode属性表示你具体按下的键(也称为virtual keycode)；keypress事件中，keyCode属性指的是你键入的字符(character code) 查看DEMO keyCode对应表 字母（大、小写）：[A-Z] -> [65-90] 数字：[0-9] -> [48-57] 小键盘按键：[0-9] -> [96-105] F功能键：[F1-F12] -> [112-123] keyCod已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 你应该使用KeyboardEvent.code。 不幸的是，有一些浏览器还是没有实现它，所以你在使用之前必须要小心，确认你所使用的那个被所有目标浏览器所支持。 ASCII码表 信息在计算机上是用二进制表示的，这种表示法让人理解就很困难。因此计算机上都配有输入和输出设备，这些设备的主要目的就是，以一种人类可阅读的形式将信息在这些设备上显示出来供人阅读理解。为保证人类和设备，设备和计算机之间能进行正确的信息交换，人们编制的统一的信息交换代码，这就是ASCII码（American Standard Code for Information Interchange）表，它的全称是“美国信息交换标准代码”。 字符 编码 字符 编码 字符 编码 字符 编码 nul 0 sp 32 @ 64 ' 96 soh 1 ! 33 A 65 a 97 stx 2 \" 34 B 66 b 98 etx 3 # 35 C 67 c 99 eot 4 $ 36 D 68 d 100 enq 5 % 37 E 69 e 101 ack 6 & 38 F 70 f 102 bel 7 ` 39 G 71 g 103 bs 8 ( 40 H 72 h 104 ht 9 ) 41 I 73 i 105 nl 10 * 42 J 74 j 106 vt 11 + 43 K 75 k 107 ff 12 , 44 L 76 l 108 er 13 - 45 M 77 m 109 so 14 . 46 N 78 n 110 si 15 / 47 O 79 o 111 dle 16 0 48 P 80 p 112 dc1 17 1 49 Q 81 q 113 dc2 18 2 50 R 82 r 114 dc3 19 3 51 S 83 s 115 dc4 20 4 52 T 84 t 116 nak 21 5 53 U 85 u 117 syn 22 6 54 V 86 v 118 etb 23 7 55 W 87 w 119 can 24 8 56 X 88 x 120 em 25 9 57 Y 89 y 121 sub 26 : 58 Z 90 z 122 esc 27 ; 59 [ 91 { 123 fs 28 60 \\ 92 \\ 124 gs 29 = 61 ] 93 } 125 re 30 > 62 ^ 94 ~ 126 us 31 ? 63 _ 95 del 127 参考链接 MDN KeyboardEvent.keyCode 键盘事件keydown、keypress、keyup随笔整理总结（摘抄） © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-13 22:01:40 "},"js探索系列/_关于Javascript.html":{"url":"js探索系列/_关于Javascript.html","title":" 关于Javascript","keywords":"","body":"关于Javascript JavaScript 参考 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/nodeJs/":{"url":"js探索系列/nodeJs/","title":"NodeJs","keywords":"","body":"README Node.js © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/nodeJs/00-Node.js的三种调试方法.html":{"url":"js探索系列/nodeJs/00-Node.js的三种调试方法.html","title":"Node.Js的三种调试方法","keywords":"","body":"Node.js的三种调试方法 内置调试（Node inspector） Node.js 包含了一个进程外的调试实用程序，可通过 V8 检查器或内置的调试客户端访问。 启动：node inspect --port=[9229] [nodeFile] 单步执行 cont, c: 继续执行。 next, n: 单步执行下一行。 step, s: 单步进入。 out, o: 单步退出。 pause: 暂停运行中的代码（类似于开发者工具中的暂停按钮）。 断点 setBreakpoint(), sb(): 在当前行上设置断点。 setBreakpoint(line), sb(line): 在指定行上设置断点。 setBreakpoint('fn()'), sb(...): 在函数体的第一个语句上设置断点。 setBreakpoint('script.js', 1), sb(...): 在 script.js 的第一行上设置断点。 clearBreakpoint('script.js', 1), cb(...): 清除 script.js 中第一行上的断点。 信息 backtrace, bt: 打印当前执行帧的回溯。 list(5): 列出脚本源码的 5 行上下文（前后各 5 行）。 watch(expr): 将表达式添加到监视列表。 unwatch(expr): 从监视列表中移除表达式。 watchers: 列出所有的监视器和它们的值（在每个断点上自动地列出）。 repl: 打开调试器的 repl，用于调试脚本的上下文中的执行。 exec expr: 在调试脚本的上下文中执行一个表达式。 执行的控制 run: 运行脚本（在调试器启动时自动地运行）。 restart: 重启脚本。 kill: 杀死脚本。 杂项 scripts: 列出所有已加载的脚本。 version: 显示 V8 的版本。 运行命令行，终端提示错误：Timeout (2000) waiting for 127.0.0.1:9229 to be free。这并不是端口被占用的问题，是node inspect在打开端口超时的一个bug。可以尝试升级node-inspect版本，或者修改node.exe的超时配置。https://github.com/nodejs/node-inspect/issues/48 V8 检查器 V8 检查器的集成允许将 Chrome开发者工具附加到 Node.js 实例，以便进行调试和性能分析。 它使用了 Chrome 开发者工具协议。 启动： node --inspect [nodeFile] # 指定端口 node --inspect=[port] [nodeFile] # 在应用程序代码的第一行进行断点 node --inspect-brk [nodeFile] $ node --inspect-brk debug/index.js Debugger listening on ws://127.0.0.1:9229/1dc7da88-983c-4fbe-a8e3-2d5f256e98af For help, see: https://nodejs.org/en/docs/inspector Debugger attached. 开始调试：在 Chrome 浏览器的地址栏，键入 chrome://inspect或者about:inspect，回车后就可以看到下面的界面。 NIM 每次调试 Node.js都要打开隐藏那么深的入口是不是很烦？还好我们有 NIM。NIM（Node Inspector Manager）是一个 Chrome插件，可以帮助我们快捷地打开 DevTools，也可以设置自动发现并打开 DevTools。 inspect-process 如果你觉得 NIM用起来也麻烦，那你可能需要inspect-process。 全局安装：npm i inspect-process -g 命令：inspect app.js inspect-process 会自动调起 Chrome DevTools，然后定位到app.js，其余用法与 Chrome DevTools 一致。 process._debugProcess 如果一个 Node.js 进程已经启动，没有添加 —inspect 参数，我们不想重启（会丢失现场）又想调试怎么办？这时可以用 process._debugProcess。使用方法如下： 通过 ps命令或者 pgrep -n node 查看当前启动的 Node.js 进程的 pid，例如：53911。 ps ax | grep app.js 打开新的终端，运行：node -e \"process._debugProcess(53911)\"，原来的 Node.js 进程会打印出：Debugger listening on ws://127.0.0.1:9229/2331fa07-32af-45eb-a1a8-bead7a0ab905。 调出 Chrome DevTools 进行调试。 node inspect 和 node --inspect区别 node --inspect: 调试app.js，但暴露了远程调试接口，像vscode, Chrome devtools, Intellij等可以附加。另外，app.js可以正常运行，并可在终端完全控制。 node inspect: 在node绑定的交互式CLI调试器。它是可以代替vscode或Chrome devtools等可视化调试器。另外，CLI调试器可使用node --inspect在单独的进程中启动脚本并附加到它。 两者之间的关系更加明显体现在更多的流和支持跨机器的远程调试: # Start app.js with the inspect interface exposed, by default on port 9229: node --inspect app.js # In a separate terminal, start the inspect client against port 9229: node inspect -p 9229 node --inspect app.js运行后，CLI调试器(node inspect连接到可用的调试界面进程了（node --inspect）。 Visual Studio Code Vscode编辑器的调试是通过插件来实现的。Node.js 的调试器是VS Code 默认就支持的，而JavaScript的调试，需要安装Debugger for Chrome插件。在左侧栏单击Extensions按钮，搜索Debugger for Chrome并点击安装。 左侧栏单击run按钮，打开调试栏。 单击左侧栏上方的配置按钮，打开laungh.json文件，并进行配置。 { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node-launch\", \"request\": \"launch\", \"name\": \"Launch NodeJs\", \"skipFiles\": [ \"/**\" ], \"program\": \"${workspaceFolder}\\\\nodeDemo\\\\debug\\\\index.js\" }, { \"type\": \"node-attach\", \"request\": \"attach\", \"name\": \"Attach by Process ID\", \"processId\": \"${command:PickProcess}\", \"skipFiles\": [ \"/**\" ] }, { \"name\": \"Launch 15-canvas入门篇.html\", \"type\": \"chrome\", \"request\": \"launch\", \"sourceMaps\": false, \"file\": \"${workspaceRoot}\\\\htmlDemo\\\\15-canvas入门篇.html\" } ] } 在左侧栏上方选择相应的启动选项。注：如果没有配置项，并且本地有index.js 文件，是直接执行了这个文件。 在左侧栏上方单击start Debugging。 配置launch.json VS Code 提供了调试界面，但是并没有将调试配置统一起来，而是将它的自由度完全交给调试器本身，我们在launch.json 里书写的调试配置，其实就是调试器的配置或者参数，只不过它的格式是 JSON。 { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch NodeJs\", \"skipFiles\": [ \"/**\" ], \"program\": \"${workspaceFolder}\\\\nodeDemo\\\\debug\\\\index.js\" } type：必填项，代表着调试器的类型。它决定了VS Code 会使用哪个调试插件来调试代码。具体值如：node、chrome。 request：必填项，代表着该如何启动调试器，有两个值： launch 和 attach。前者的意思就是 VSCode会使用调试器直接启动代码并且调试，后者的意思是你已经打开了程序，然后接通 Node.js 的内部调试协议进行调试。 name：该配置的名字。调试时，可在调试栏上方选择运行哪个配置。 program：就是告诉 Node.js 调试器，我们想要调试哪个文件。这个值支持预定义参数，比如：${file}，也就是当前编辑器里打开的文件；${workspaceFolder} 是代表当前工作区文件夹地址。 MacOS 或者 Linux 的书写方式 ：\"program\": \"path/app.js\" Windows 平台指定特定的书写方式：program\": path\\\\app.js 这四个属性中，type、request是 VS Code 预先定义好的属性，每个调试器插件都会按照一样的方式去阅读和理解它的值；而name、program的定义和最终解释，都是由调试插件控制的，VS Code 并不会对它们做任何的约束和处理。 虽然每个调试器各自控制着用户可以使用哪些属性，但是调试器之间还是有很多相同的地方，调试插件在很多时候都会使用相同的属性名来代表同样的功能。经常使用的有下面这些： program 一般用于指定将要调试的文件。 stopOnEntry，当调试器启动后，是否在第一行代码处暂停代码的执行。 args 把参数传给将要被调试的代码。 env 环境变量。大部分调试器都使用它来控制调试进程的特殊环境变量。 cwd 控制调试程序的工作目录。 port 是调试时使用的端口。 参考链接 node 调试指南 Node 调试工具入门教程 VSCode 代码调试器 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:14:36 "},"js探索系列/nodeJs/01-npm模块的一些机制.html":{"url":"js探索系列/nodeJs/01-npm模块的一些机制.html","title":"Npm模块的一些机制","keywords":"","body":"npm模块的一些机制 npm （Node PackageManager） 是 JavaScript 世界的包管理工具，并且是 Node.js 平台的默认包管理工具。通过 npm 可以安装、共享、分发代码，管理项目依赖关系。 npm的模块安装及管理 安装模块 发出 npm install 命令 查询 node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了。 若不存在，npm 向 registry 查询模块压缩包的网址 下载压缩包，存放在根目录下的.npm目录里 解压压缩包到当前项目的node_modules目录 注意： 一个模块安装以后，本地其实保存了两份。一份是.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。但是，运行npm install 的时候，只会检查node_modules目录，而不会检查.npm目录。也就是说，如果一个模块在.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。 npm install # 远程版本较新、或者本地版本不存在时安装 npm install --force # 不管是否安装过，npm 都要强制重新安装 npm install packageName@[version] # 安装指定版本 更新模块 命令：npm update npm update 先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。 查询模块 npm 模块仓库提供了一个查询服务，叫做 registry 。以 npmjs.org 为例： https://registry.npmjs.org/webpack // 查看 webpack 模块所有版本的信息 https://registry.npmjs.org/webpack/4.44.2 // 查看4.44.2版本的 webpack 模块信息 npm install 和 npm update 命令，都是通过这种方式安装模块的。 模块缓存 npm install 或 npm update 命令，从 registry 下载压缩包之后，都存放在本地的缓存目录。 这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的 .npm 目录，在 Windows 默认是 %AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。 npm config get cache # $HOME/AppData/Roaming/npm-cache 每个模块的每个版本，都有一个自己的子目录，里面是代码的压缩包 package.tgz文件，以及一个描述文件package/package.json。除此之外，还会生成一个 {cache}/{hostname}/{path}/.cache.json 文件。 对于一些不是很关键的操作（比如 npm search 或 npm view），npm 会先查看 .cache.json 里面的模块最近更新时间，跟当前时间的差距，是不是在可接受的范围之内。如果是的，就不再向远程仓库发出请求，而是直接返回 .cache.json 的数据。 清空缓存： npm cache clean --force --cache-min 参数 npm 提供了一个 --cache-min 参数，用于从缓存目录安装模块。--cache-min 参数指定一个时间（单位为分钟），只有超过这个时间的模块，才会从 registry 下载。 npm install --cache-min 9999999 # 只有超过999999分钟的模块，才从 registry 下载。实际上就是指定，所有模块都从缓存安装，这样就大大加快了下载速度。 npm install --cache-min Infinity # 从缓存中安装 package.json package.json 用于记录项目中使用的 npm 包，以及项目的配置信息（比如名称、版本号、项目描述、许可证等元数据），便于开发组成员共享。开发人员在项目目录下运行 npm install 命令可以自动下载 package.json 文件中运行和开发环境中所需的依赖。 npm的模块安装机制 安装 npm 模块时，可能的方式有两种：平级式的安装或嵌套式的安装。 假设：项目 APP 下有两个依赖模块 A 和 B；A 又有一个依赖模块 C v1.0；而 B 也有一个依赖模块 C v2.0。显然，它们并不能同时存在于同一个 node_modules 下，当安装的时候，由于 npm的作用机制，只能有一个版本的依赖模块被安装，其中一个将覆盖另外一个。这可能会导致A模块和B模块不兼容 npm2下的模块安装机制 npm2 安装多级的依赖模块采用嵌套的安装方式。 优点：解决了版本单一时存在的存在的不兼容问题，实现多版本兼容 弊端：可能造成相同模块大量冗余的问题 npm3下的模块安装机制 npm3 和 npm2 的不同主要体现在二级模块的安装上： npm3会\"尽量\"把逻辑上某个层级的模块在物理结构上\"全部\"放在项目的第一层级里，具体我概括为以下三种情况： 在安装某个二级模块时，若发现第一层级还没有相同名称的模块，便把这第二层级的模块放在第一层级 在安装某个二级模块时，若发现第一层级有相同名称，相同版本的模块，便直接复用那个模块 在安装某个二级模块时，若发现第一层级有相同名称，但版本不同的模块，便只能嵌套在自身的父模块下方 在npm2中，依赖树的逻辑结构和它的物理结构相同 在npm3中，依赖树的逻辑结构和它的物理结构可能不同 npm的模块引用机制 在 Node.js 中，有三类模块： Node.js 的核心模块。如：fs 模块、database 模块 文件模块：开发者自行编写的。如：test.js 模块 npm 模块：这是一种特殊的文件模块，一般是一个文件或包的形式，比如引入 mysql 所需的 npm 包。 路径分析 文件模块引入时，模块标识指明了确切的文件位置（可以放置在任意位置，使用相对路径（ ./ 和 ../ ）或以 / 开头的绝对路径），所以在路径分析中可以省略大量时间，加载速度仅次于核心模块。 npm 模块则是会从以下路径中依次查找，直到找到目标模块为止。npm 模块的路径越深，路径分析的耗时越多，其加载速度是最慢的。 /Users/[whoami]/[projectname]/[directory]/node_modules /Users/[whoami]/[projectname]/node_modules /Users/[whoami]/node_modules /Users/node_modules /node_modules /Users/[whoami]/.node_modules /Users/[whoami]/.node_libraries /usr/local/Cellar/node/7.7.1/lib/node 文件定位 模块标识可以不包含后缀名，所以 Node.js 在文件定位时会依次补充 .js，.json，.node 后缀名，然后去进行文件定位。因为 Node.js 是单线程，所以文件定位时会发生堵塞，所以如果引入的模块后缀是 .json 或者 .node，可以在引入的时候加上后缀，可以提高查找速度。 编译执行 定义到具体文件后，Node.js 会创建一个模块对象，然后将模块引入并且编译。每一个编译成功的模块其文件路径都会作为索引缓存在缓存对象上，以提高二次引入模块的性能。 核心模块在 Node.js 源代码的编译过程中，直接被编译成二进制文件，然后被直接加载到内存中，所以核心模块引入时，文件定位和编译执行这两个步骤可以直接跳过，并且核心模块在路径分析中会被优先判断，所以核心模块的加载速度是最快的。 文件模块则是在执行时动态加载，所以路径分析，文件定位以及编译执行这三个步骤都不可省略，所以加载速度比核心模块慢。 Node.js 对引入过的模块会进行缓存，以减少二次引入模块的性能开销二次加载模块一律采用缓存优先方式。核心模块的缓存检查优先于文件模块。 npm模块循环依赖及其解决 重要问题：当我们在 A.js 中引用 B.js，在 B.js 中引用 A.js 时会发生什么？ 官网上点出了这种模块循环的情况，并且解释清楚了原因： When main.js loads a.js, then a.js in turn loads b.js. At that point, b.js tries to load a.js. In order to prevent an infinite loop, an unfinished copy of the a.js exports object is returned to the b.js module. b.js then finishes loading, and its exports object is provided to the a.js module. 简单说就是，为了防止模块载入的死循环，Node.js 在模块第一次载入后会把它的结果进行缓存，下一次再对它进行载入的时候会直接从缓存中取出结果。所以在这种循环依赖情形下，不会有死循环，但是却会因为缓存造成模块没有按照我们预想的那样被导出（export，详细的案例分析见下文）。 下面是一个两个模块循环依赖的问题最简情形： A.js： let b = require('./B'); console.log('A: before logging b'); console.log(b); console.log('A: after logging b'); module.exports = { A: 'this is a Object' }; B.js： let a = require('./A'); console.log('B: before logging a'); console.log(a); console.log('B: after logging a'); module.exports = { B: 'this is b Object' }; 运行 A.js，将会看到如下输出： B: before logging a {} B: after logging a A: before logging b { B: 'this is b Object' } A: after logging b JavaScript 作为一门解释型的语言，上面的打印输出清晰的展示出了程序运行的轨迹。在这个例子中，A.js 首先 require 了 B.js, 程序进入 B.js，在 B.js 中第一行又 require 了 A.js。 如前文所述，为了避免无限循环的模块依赖，在 Node.js 运行 A.js 之后，它就被缓存了，但需要注意的是，此时缓存的仅仅是一个未完工的 A.js（an unfinished copy of the a.js）。所以在 B.js require A.js 时，得到的仅仅是缓存中一个未完工的 A.js，具体来说，它并没有明确被导出的具体内容（A.js 尾端）。所以 B.js 中输出的 a 是一个空对象。 之后，B.js 顺利执行完，回到 A.js 的 require 语句之后，继续执行完成。 参考资料 npm 模块安装机制简介 https://www.cnblogs.com/penghuwan/p/6970543.html https://cloud.tencent.com/developer/article/1556014 http://maples7.com/2016/08/17/cyclic-dependencies-in-node-and-its-solution/ © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:14:36 "},"js探索系列/nodeJs/02-npm常用命令.html":{"url":"js探索系列/nodeJs/02-npm常用命令.html","title":"Npm常用命令","keywords":"","body":"npm常用命令 NPM的全称是 Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经安装的包。 npm -h # 列出帮助信息 npm -h # 列出该命令的帮助信息 npm help # 查看帮助信息 npm -l #列出全部可用命令 npm -v #列出npm版本号 npm init # 初始化一个基于node的项目，会创建一个配置文件package.json npm init --yes # 全部使用默认配置 npm config set # 设置配置 npm config delete # 删除配置 npm config list #查看全部配置 npm install [-g] [@] # 安装指定包。默认本地安装，-g全局安装 npm install [@] --save # 安装运行时依赖包 npm install [@] --save-dev # 安装开发时依赖包 npm install [@] [@] # 一次性安装多个 npm uninstall [-g] [@] # 卸载指定包 npm update [@] # 更新包 npm update [@] -g # 更新全局包 npm root # 查看当前包的安装路径 npm root -g #查看全局npm安装的路径 npm search pkg # 查看指定包是否存在 tree -d # 以树状图的方式列出一个项目下所有依赖的物理结构 npm ls # 查看当前目录下安装了那些包 npm ls # 查看特定package的信息 npm ls -g # 查看全局安装的包 npm info # 查看包的信息 npm view # 查看包的信息 npm info # 查看包的信息 npm show # 查看包的信息 npm v # 查看包的信息 npm login #登录 npm whoami #查看当前用户 npm publish #发布项目 npm unpublish [@]#取消发布项目 npm config set registry # 设置源 npm install -g cnpm --registry= #安装cnpm工具 cnpm install [@] # 使用cnpm代替npm npm cache clean --force # 清除缓存 npm install -g nrm # 安装nrm工具 nrm ls # 查看当前可用的镜像源 nrm use #切换npm源 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"js探索系列/nodeJs/03-从零开始，开发一个NPM包.html":{"url":"js探索系列/nodeJs/03-从零开始，开发一个NPM包.html","title":"从零开始，开发一个NPM包","keywords":"","body":"从零开始，开发一个NPM包 npm (Node Package Manager) 本来是 Node.js 的包管理工具，但随着JS这几年的蓬勃发展，现在npm 已经成为了几乎所有跟 JS 相关的工具和软件包的管理工具，并且还在不断的发展完善中。 现在最新版的 Node.js 的安装都会自带npm，装上Node.js就可以使用npm。 初始化项目 发布一个npm代码包，本质上就是将你的代码公开在https://www.npmjs.com/网上。使用者可以通过npm install [npm包名]，来引入你的代码。关键在于两点： 输出的js文件，也就是代码主体。如：通常输出到`lib/index.js。 package.json配置中指明你的输出文件的位置。这个是通过main属性来指定的 初始化项目，就是要创建一个package.json文件，其中模块的名字和版本号是必填项。可以手动创建，也可以用 npm init 自动创建。 package.json部分字段说明：package.json参数详解 { name: '', //插件的名字 version: '', //插件版本号 description: '', //插件描述 author: '', //作者名 main: '', //入口文件路径，require(name)将根据这个路径来引入 files: '', //文件夹名，所有文件都会被包含进项目中(除非是那些在其他规则中被忽略的文件) bin: {}, //许多包有一个或多个可执行文件希望被安装到系统路径。提供一个bin字段，它是一个命令名和本地文件名的映射。在安装时，如果是全局安装，npm将会使用符号链接把这些文件链接到prefix/bin，如果是本地安装，会链接到./node_modules/.bin/。 keywords: '', //关键词，使用数组形式，方便npm官网搜索 scripts: {}, //命令行，通过npm run 执行 license: '', //许可证书，一般开源是MIT homepage: '', //项目主页的url repository: '', //github仓库项目地址 } 开发npm包 这个可以很灵活，具体开发取决由npm包的复杂度。 可以是简单的，直接在lib文件夹下，创建一个只有一行代码的console.log(Hello World!)的JS文件；也可以采用webpack + vue之类的框架，开发一个复杂的项目，将最终编译出来的JS文件输出到lib文件夹。 可以给项目加eslint等代码校验 编写测试模块，如：mocha 和 chai 可以用gitlab CI类的方式实现自动化部署 可以创建readme.md文档，编写使用说明 测试npm包 相对路径安装 进入项目目录，用相对路径安装包。安装完后，可以在node_modules文件夹检查是否安装成功。 cd [项目目录] npm install [包的相对路径] 使用 npm link 连接到全局测试 相对路径安装找路径比较麻烦，所以我们推荐使用 npm link 将 npm 包链接到全局，再安装到本地项目。 首先定位到 npm 包项目的目录下，运行：npm link cd [npm包项目] npm link //执行后，输出/usr/local/lib/node_modules/[插件项目名称] -> /Users/${whoami}/Documents/[插件项目路径]/[插件项目名称] 意思是将 npm包项目 连接到全局的node_modules下,我们进入全局node_modules包下也可以查看到该 npm 包。 然后定位到需要使用 npm 包的项目，运行：npm link [npm包项目名称]，将 npm 包安装到当前项目。npm 包的修改，在 build 后，会同步更新到当前项目的node_modules。 cd [需要使用 npm 包的项目目录] npm link [npm包项目名称] 测试完成后，取消在全局的连接： cd [npm包项目] npm unlink 发布npm包 注册：npm adduser 判断是否登录：npm whoami 登录：npm login 发布：npm publish。每次发布，必须修改版本号。版本号更新，要遵循 Semver(语义化版本号) 规范： 升级补丁版本号：npm version patch 升级小版本号：npm version minor 升级大版本号：npm version major 删除：npm包发布后是无法删除的。即使是你删除了，也只是无法被搜索到，仍可以通过链接直接访问。 使用npm包 安装：npm install [npm包名] 使用：import \"[npm包名]或者import Obj, {Obj1, Obj2} from 'npm包名' 遇到问题 npm publish报错 报错[no_perms] Private mode enable, only admin can publish this module [no_perms] Private mode enable, only admin can publish this module 出现原因：使用的是淘宝源cnpm，登陆到的是npm 解决方法：切换到 npmjs的网址，代码如下：npm config set registry http://registry.npmjs.org/。也可以用nrm管理源。 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:14:36 "},"research/01-极细边框（1px边框）实现方式.html":{"url":"research/01-极细边框（1px边框）实现方式.html","title":"极细边框（1px边框）实现方式","keywords":"","body":"极细边框（1px边框）实现方式 移动端 web开发遇到的问题：UI稿上要求设置边框为1px，css设置border: 1px solid #eee;之后，UI又说边框太粗了。 这是因为devicePixelRatio特性导致。css设置的1px是css像素，而UI稿上指的是设备像素，它们之间存在一个比例关系，即，devicePixelRatio。iPhone的devicePixelRatio == 2，而border-width: 1px描述的是css像素，所以，border被放大到物理像素2px显示，在iPhone上就显得较粗。 像素基本概念（术语） device pixel / physical pixel （设置像素、物理像素、硬件像素）： 显示屏中最小的物理单元。 移动设备出厂时，不同设备自带的不同像素，每个像素点根据操作系统的指示设置自己的颜色和亮度。 density-independent pixel(DIP)（设备无关像素或密度无关像素）：可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统转换为物理像素。 CSS pixel （css 像素）：浏览器使用的抽象单元，用于精确地，一致地在网页上绘制内容。 通常，CSS 像素被称为与设备无关的像素（DIP）。 devicePixelRatio（设备像素比）：物理像素和逻辑像素的比例关系，通常可以通过js的 window.devicePixelRatio 来获取。 devicePixelRatio可以用来区分视网膜设备还是非视网膜设备。 devicePixelRatio 值为 1 的屏幕称之为标准屏（也称，非视网膜屏）；目前，大部分移动设备都是高清屏（也称，视网膜屏），即 devicePixelRatio 值大于 1 的屏幕，对于苹果设备来说，我们经常听到 Retina屏（视网膜屏），其中iPhone6/6s/7 的 devicePixelRatio 值为 2；而iPhone6 plus/6s plus/7 plus 的 devicePixelRatio 值为 3。 设置0.5px边框 优点：实现简单 缺点：retina屏的浏览器可能不认识0.5px的边框，将会把它解释成0px，没有边框。包括iOS 7 和之前版本，OS X Mavericks 及以前版本，还有 Android设备。 //判断手机是否支持0.5px if (window.devicePixelRatio && devicePixelRatio >= 2) { var divElem = document.createElement('div') divElem.style.border = '.5px solid transparent' document.body.appendChild(divElem) if (divElem.offsetHeight == 1) { document.querySelector('html').classList.add('hairlines'); } document.body.removeChild(divElem); } //在html中，加上此样式 .hairlines { *:not(table tr td), *:not(.noHairlines) { border-width: 0.5px!important; } } box-shadow（阴影） 优点：可以设置圆角 缺点：颜色不好控制 .border-1px { box-shadow:0 1px 1px -1px rgba(0, 0, 0, 0.5); } border-image（边框背景图片） 使用的图片是2px高，上部的1px颜色为透明，下部的1px使用视觉规定的border的颜色。 优点： 缺点：修改颜色麻烦，需要替换图片；圆角需要特殊处理，并且边缘会模糊。 .border-image-1px { border-width: 1px 0px; border-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAcSURBVHjaBMEBDQAADMMgckv1r20H1WxzoNoPAER9BjAKc4kUAAAAAElFTkSuQmCC\") 2 0 stretch; } background-image 渐变 缺点：不能实现圆角。 .border-1px { background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px; } transform: scale(0.5) （推荐，相当灵活） /*height：1px，然后根据媒体查询设置transform: scaleY(0.5)*/ .border-1px { height:1px; background:#000; transform: scaleY(0.5); transform-origin:0 0; overflow: hidden; } /*伪类::after和::befor,设置border-bottom：1px solid #000,然后在缩放transform: scaleY(0.5),可以实现两根边线的需求*/ .border-1px:after, .border-1px::after { content:''; width:100%; border-bottom:1px solid #000; transform: scaleY(0.5); } /*伪类::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scale(0.5); 优点可以实现圆角，缺点是按钮添加active比较麻烦。*/ .border-1px:after, .border-1px::after { content: ''; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid #bfbfbf; border-radius: 4px; transform: scale(0.5,0.5); transform-origin: top left; } viewport+rem 优点：可以自适应已知的各类手机屏幕,且不存在其它方法存在的变颜色困难、圆角阴影失效问题。 缺点：样式必须用rem为单位 var viewport = document.querySelector(\"meta[name=viewport]\"); //下面是根据设备像素设置viewport if (window.devicePixelRatio == 1) { viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no'); } if (window.devicePixelRatio == 2) { viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no'); } if (window.devicePixelRatio == 3) { viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no'); } var docEl = document.documentElement; var fontsize = 10 * (docEl.clientWidth / 320) + 'px'; docEl.style.fontSize = fontsize; 常见问题 细边框显示不全 原因： 未确定。可能与元素的高度、行高及像素的小点有关 解决方法： 上边框被遮住：如果样式中有position: absolute； top：50% ，可以尝试把改成 top: 51%。 尽量不要使用display: inline-block，改用display: block。 将0.5px改为0.7px。 指定高度、行高（如：line-height: normal）。 参考链接 移动web 1像素边框 瞧瞧大公司是怎么做的 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"research/02-如何监控前端异常？.html":{"url":"research/02-如何监控前端异常？.html","title":"如何监控前端异常？","keywords":"","body":"如何监控前端异常？ 一个完善的异常监控平台，是一个非常复杂的项目。它需要包括异常监控、信息收集、信息归类、信息的统计分析、异常场景的重现、异常在源码中的定位等等，同时，也要考虑异常日志的存放以及服务器压力等问题。 本文只涉及异常的捕获、上传方面的内容，大致围绕下面几点展开讨论： 前端需要处理的异常 前端异常的捕获方式 异常信息的上报方式 异常监控常见问题 为什么要处理异常？ 增强用户体验 远程定位问题 未雨绸缪，及早发现问题 无法复线问题，尤其是移动端，机型，系统都是问题 完善的前端方案，前端监控系统； 对于 JS 而言，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。 前端需要处理的异常 语法错误 运行时异常 EvalError eval错误 RangeError 范围错误 ReferenceError 引用错误 TypeError 类型错误 URIError URI错误 SyntaxError 语法错误 Error 通用错误 资源加载异常 img script link audio video iframe @font-face 外链资源的DOM元素。。。 Promise 异常 异步请求异常 XMLHttpRequest fetch 前端异常的捕获方式 try-catch-finally window.onerror = function () {} img script link window.addEventListener('error', function () {}, true) window.addEventListener(\"unhandledrejection\", function () {}) Promise.then().catch(function () {}) 封装 XMLHttpRequest、fetch，覆写请求接口对象 try-catch-finally try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误（如：中文分号）和异步错误(如：回调、promise、setTimeout ）就显得无能为力。 try { // 模拟一段可能有错误的代码 throw new Error(\"会有错误的代码块\") } catch(e){ // 捕获到try中代码块的错误得到一个错误对象e，进行处理分析 report(e) } finally { console.log(\"finally\") } window.onerror window.onerror 是一个全局变量，默认值为null。当 JS 运行时错误（包括语法错误）发生时，window会触发一个 ErrorEvent接口的事件，并执行 window.onerror();。onerror 可以接受多个参数。 window.onerror 无法捕获 静态资源异常、接口异常。 注意：语法错误会导致出现语法错误的那个脚本块执行失败，所以语法错误会导致当前代码块运行终止，从而导致整个程序运行中断，如果语法错误这个发生在我们的错误监控语句块中，那么我们就什么也监控不到了。 window.onerror = function (msg, url, row, col, error) { // msg：错误信息（字符串）。 // url：发生错误的脚本URL（字符串） // row：发生错误的行号（数字） // col：发生错误的列号（数字） // error：Error对象（对象） console.log('我知道异步错误了'); console.log({ msg, url, row, col, error }) return true; }; window.onerror = function () {} 要比其他脚本先执行（注意这个前提！），才可以捕捉到语法错误。 window.onerror函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。 window.addEventListener 监听 js 运行时错误事件，会比 window.onerror 先触发，与 onerror的功能大体类似，不过事件回调函数传参只有一个保存所有错误信息的参数，不能阻止默认事件处理函数的执行，但可以全局捕获资源加载异常的错误。 当资源（如img或script）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些error事件不会向上冒泡到window，但可以在捕获阶段被捕获。因此如果要全局监听资源加载错误，需要在捕获阶段捕获事件 网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。 需要注意： 不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。 需要注意避免 addEventListener 重复监听。 window.addEventListener('error', (msg, url, row, col, error) => { console.log('我知道 404 错误了') console.log( msg, url, row, col, error ); return true }, true) unhandledrejection 没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。 为了防止有漏掉的 Promise 异常，在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。 window.addEventListener(\"unhandledrejection\", function(e){ // Event新增属性 // @prop {Promise} promise - 状态为rejected的Promise实例 // @prop {String|Object} reason - 异常信息或rejected的内容 // 会阻止异常继续抛出，不让Uncaught(in promise) Error产生 e.preventDefault() }) Promise.then().catch(function () {}) new Promise(function(resolve, reject) { throw 'Uncaught Exception!'; }).catch(function(e) { console.log(e); // Uncaught Exception! }) 封装XMLHttpRequest、fetch /** * 函数：封装XMLHttpRequest和fetch对象，获取、上传异常信息。 */ function captureRequestError (reportLog) { // 覆写XMLHttpRequest API if(window.XMLHttpRequest) { var xmlhttp = window.XMLHttpRequest var _oldSend = xmlhttp.prototype.send var _handleEvent = function (event) { if (event && event.toString() === \"[object ProgressEvent]\" && event.currentTarget && event.currentTarget.status !== 200) { //处理错误信息 } } xmlhttp.prototype.send = function () { if (this['addEventListener']) { this['addEventListener']('error', _handleEvent) this['addEventListener']('load', _handleEvent) this['addEventListener']('abort', _handleEvent) this['addEventListener']('close', _handleEvent) } else { var _oldStateChange = this['onreadystatechange'] this['onreadystatechange'] = function (event) { if (this.readyState === 4) { _handleEvent(event) } _oldStateChange && _oldStateChange.apply(this, arguments) } } return _oldSend.apply(this, arguments) } } //覆写fetch API if (window.fetch) { var _oldFetch = window.fetch window.fetch = function() { return _oldFetch.apply(this, arguments).then(function(res){ // 处理信息 return res }).catch(function(error){ // 处理信息 }) } } } VUE errorHandler vue本身有监听异常机制，我们可以在它提供的监听函数中，上传异常信息。 Vue.config.errorHandler = (err, vm, info) => { console.error('通过vue errorHandler捕获的错误'); console.error(err); console.error(vm); console.error(info); } 崩溃和卡顿 卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？ 利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。 window.addEventListener('load', function () { sessionStorage.setItem('good_exit', 'pending'); setInterval(function () { sessionStorage.setItem('time_before_crash', new Date().toString()); }, 1000); }); window.addEventListener('beforeunload', function () { sessionStorage.setItem('good_exit', 'true'); }); if(sessionStorage.getItem('good_exit') && sessionStorage.getItem('good_exit') !== 'true') { /* insert crash logging code here */ alert('Hey, welcome back from your crash, looks like you crashed on: ' + sessionStorage.getItem('time_before_crash')); } 以使用 Service Worker 来实现网页崩溃的监控： Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃； Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态； 网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。 异常日记上报方式 异步请求上报, 后端提供接口，或者直接发到日志服务器 img请求上报，url参数带上错误信息 function report(error) { var reportUrl = 'http://xxxx/report'; new Image().src = reportUrl + 'error=' + error; } 常见问题 跨域脚本异常报错信息 生产环境的 JS 做静态资源 CDN 化，导致访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。 Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。 在H5的规定中，只要满足下面两个条件，是允许获取跨源脚本的错误信息的。 客户端在 script 标签上增加 crossorigin 属性； 服务端设置 js 资源响应头 Access-Control-Origin: 指定域名 | *。 window.error 和 window.addEventListener区别 window.onerror 含有详细的 error信息（如：error.stack），而且兼容性更好，所以一般 JS 运行时错误使用 window.onerror 捕获处理。 window.addEventListener('error') ，可以捕获 JS 运行时的错误，也能捕获资源加载错误。为避免重复上报 js 运行时错误，此时应该只有event.srcElement inatanceof HTMLScriptElement、HTMLLinkElement、HTMLImageElement 时才上报 总结 使用场景分析 可疑区域增加 Try-Catch 全局监控 JS 异常 window.onerror 全局监控静态资源异常 window.addEventListener 捕获没有 Catch 的 Promise 异常：unhandledrejection vue框架： VUE errorHandler 、React 框架： React componentDidCatch 监控网页崩溃：window 对象的 load 和 beforeunload 业界已经有的监控平台 Sentry 开源 (推荐) 阿里的 ARMS fundebug FrontJS 另外还有一些轻量级的 BetterJS 参考资料 前端异常监控-看这篇就够了 如何优雅处理前端异常？ 前端代码异常监控实战 如何做前端异常监控？ © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/03-H5页面的跳转、刷新、回退+刷新.html":{"url":"research/03-H5页面的跳转、刷新、回退+刷新.html","title":"H5页面的跳转、刷新、回退+刷新","keywords":"","body":"H5页面的跳转、刷新、回退+刷新 本文主要介绍前端 H5 页面的一些刷新、回退、替换、回退 + 刷新的方法。 页面跳转 a 标签。在 a 标签的 href 属性中设置跳转链接。 禁止 a 标签跳转： href = \"#\"：# 是有特定意义的，# 后面紧接的是一个锚占名称，默认的锚点为 #top, 即页面顶部。 href=\"###\"：### 就是一个 # 和不存在的锚点 ## 的组合，页面中找不到命名为 ## 的锚点不会发生跳转，也就不会突然跳到页面顶部。### 只是一种使用者习惯，可以随便找一个跳转不到的标签作为命名。 另外，### 容易带了一些副作用。比如：会改变浏览器的链接地址；再如：如果 a 标签带了 target=\"_blank\" 那么他们的处理就会不一样，###会开一个新页面。 href=\"javascript:;\"：javascript: 指定执行 js 内容，; 为空语句。 href=\"javascript: void(0);\"：void是一个操作符，该操作符指定要计算一个表达式但是不返回值。 直接删掉href属性。 location.href：一个可读可写的字符串，可设置或返回当前显示的文档的完整 URL。设置值可以跳转新网页。 常见的几种形式： self.location.href：当前页面打开URL页面。 window.location.href：当前页面打开URL页面。 this.location.href：当前页面打开URL页面。 location.href：当前页面打开URL页面。 parent.location.href：在父页面打开新页面。 top.location.href：在顶层页面打开新页面。 前四种形式实现的跳转是一样的，parent 和 top 在特定情况下有差异。如：当页面嵌套多个 iframe 时，parent 指向父窗口，top 指向最顶层的窗口。 location.replace(url)：以给定的URL来替换当前的资源。 需要注意是：调用 replace() 方法后，当前页面不会保存到会话历史中（History），这样，用户点击回退按钮时，将不会再跳转到该页面。 location.assign(url)：触发窗口加载并显示指定的 URL 的内容，效果与 location.href 相当。 window.navigate(url)：非标准的方法，仅 IE 浏览器支持，其他浏览器不提供该方法。 Meta 标签，控制页面自动跳转。比如：5秒后，自动跳转。 刷新页面 history.go(delta)： history.go 方法从会话历史记录中加载特定页面。 delta 是负值表示向后移动，正值表示向前移动。如果未向该函数传参或 delta == 0，则该函数与调用 location.reload() 具有相同的效果。注意：相等于0是采用宽松相等进行比较的。 location.reload()：用来刷新当前页面。 该方法只有一个参数，当值为 true 时，将强制浏览器从服务器加载页面资源，当值为 false 或者未传参时，浏览器则可能从缓存中读取页。 location.replace(location) location.href = location.href location = location location.assign(location) document.execCommand('Refresh')： 当一个HTML文档切换到设计模式时，document 暴露 execCommand 方法，该方法允许运行命令来操纵可编辑内容区域的元素。已废弃，尽量避免使用。 window.navigate(location) Meta 标签。如：每5秒自动刷新。 页面回退 H5 退回前一个页面，或者前几个页面。 history.go(-1)。 history.back()：前往上一页，用户可点击浏览器左上角的返回按钮模拟此方法。等价于 history.go(-1)。 document.referrer：返回的是一个 URI，当前页面就是从这个 URI 所代表的页面跳转或打开的。 location.href = document.referrer 页面替换 H5 跳转到一个新页面，但不需要在 History 新增记录，即，跳转出去后，点击回退不需要再回该页面。 history.replaceState(null, null, url) location.replace(url) replaceState() 方法修改当前历史记录实体。 history.replaceState(stateObj, title, url) stateObj：是一个JavaScript对象，它与传递给 replaceState 方法的历史记录实体相关联。 title：大部分浏览器忽略这个参数, 将来可能有用。 url：可选。历史记录实体的URL。新的 URL 跟当前的 URL 必须是同源；否则抛出异常。 注意：如果不加 history.replaceState，部分机型，可能会导致页面无法返回上一页。 页面回退+刷新 H5 退回前一个页面，并且刷新页面。比如：A -> B 页面，B 修改了跟 A 页面相关的一些数据，回退到 A 页面时，A 必需刷新页面上的数据。有以下解决方案： document.referrer location.replace(document.referrer) pageshow 事件 （推荐） // persisted：只读属性，代表一个页面是否从缓存中加载的 window.addEventListener('pageshow', function(e) { if (e.persisted) { location.reload() } }) let isPageHide = false window.addEventListener('pageshow', function () { if (isPageHide) { location.reload() } }) window.addEventListener('pagehide', function () { isPageHide = true }) 注意： 即使页面刷新了，请求接口也可能有缓存。解决方法是在 API 链接中加上时间戳。如：../path1/path2?v=${new Date().getTime()}。 在App中新开窗口，需要原生提拱回退监听事件(A页面监听回退，执行刷新)。 History 对象。 使用 History 对象修改当前历史记录。A -> B页面时，先替换当前历史记录点，然后再打开 B 页面。 let json = { time: newDate().getTime() } window.history.replaceState(json, \"\", window.location.href + \" &t=\" + newDate().getTime()) window.location.href= url popstate 事件 function(){ window.addEventListener(\"popstate\", function(e) { location.reload() }, false) var state = { title : \"\", url : \"#\" } history.replaceState(state, \"\", \"#\") } 相关问题 页面回退不刷新 A -> B 页面，再回退到 A 页面，A页面不刷新。其原因可能是： B页面回退到A页面，移动端部分浏览器 (如iphoneX) 默认不执行更新操作。 B页面回退到A页面，执行了更新操作。但 Ajax 请求从本地缓存中读取数据，导致页面数据不更新。 App 跳转 B 页面，新开了窗口（类似于浏览器中新开了标签页） window.location 和 document.location 有什么区别？ document 对象是 window 对象的一部分，是浏览器的 html 文档 。 window.document === document window 对象的 location 属性引用的是 location 对象，表示该窗口中当前显示文档的URL；document 对象的 location 属性也是引用了 location 对象。在没有内嵌 iframe 的情况下，两者是等同的： window.location === document.location //true location.href === window.location.href === document.location.href 在嵌入 iframe 的情况下，最外层是相同的，但在 iframe 里面的 document.location 和window.location 不同的。iframe 里面的document.location 只改变 iframe 部分。 如何禁止页面回退？ 消除所有后退动作。包括 键盘、鼠标手势等产生的后退动作： //防止页面后退 history.pushState(null, null, document.URL) window.addEventListener('popstate', function () { history.pushState(null, null, document.URL) }) 参考资料 MDN Location javascript刷新页面的几种方法 window.location.href和window.open的几种用法和区别 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/04-web主题切换和个性化定制方法总结.html":{"url":"research/04-web主题切换和个性化定制方法总结.html","title":"Web主题切换和个性化定制方法总结","keywords":"","body":"web主题切换和个性化定制方法总结 切换主题 切换主题：主题是由开发者定义，一般来说只有有限的主题可选。 方法一：class 命名空间 定制不同主题，存于不同的 class 命名空间下，通过 JS 修改 body 或其他需要换主题的标签上的 class 名来实现主题切换。 该方法的关键在于如何为不同主题，生成不同的 class。如果纯手动写多个主题的 class，成本太高，而且后期维护也比较困难。 以下是两种解决方案：postcss-themes 插件、less 混合。 postcss-themes 插件（推荐） 将主题相关的变量提取到一个主题变量文件中， postcss-themes 会为使用了主题文件中变量的选择器，新添加一份带有命名空间的选择器。 /* postcss.config.js */ module.exports = { plugins: { 'postcss-themes': { themes: { // themes 可以为数组，配置多个主题 filePath: 'red_theme.css' } }, 'postcss-css-variables': {}, } } 输入 css： /* index.css */ :root { --main-color: green; } .foo { font-size: 16px; color: var(--main-color); } /* red_theme */ :root { --main-color: red; } 输出 css： .foo { font-size: 16px; color: green; } .red_theme .foo { color: red; } Less 混合 less 混合是将一组属性从一个规则集包含（或混入）到另一个规则集的方法。规则集可以通过传参生成不同的新规则集。该方案需要将所有主题相关的样式集中在一个规则集中，实际执行起来比较困难。 /*variables.less*/ .base_theme(@background: #e2e9f9, @color: #337ab7){ .class_1 { background: @background; } .class_1 a:hover{ color: saturate(@color, 20%); } .class_2 { color: @color; } } @import 'variables.less'; .default_theme { /*默认主题，经典蓝*/ .base_theme(); } .coffee_theme { /*咖啡色主题*/ .base_theme(#f5e2c9, #9f754d); } .purple_theme { /*紫色主题*/ .base_theme(#e5d3ed, #b88bcb); } JS 切换主题 JS 修改 body 或其他需要换主题的元素的 class 名。 document.body.className = `${document.body.className} ${theme_class_name}` 方法二：多个 CSS 文件 定制不同主题，每个主题生成一份 CSS 文件，然后再通过 JS 切换主题样式文件来实现。 实现步骤上如下： 创建主题变量文件，包含主题相关的变量定义； 根据不同的主题变量文件，编译生成不同主题的 CSS 文件； 通过 JS 切换主题样式文件。 其中重点是，如何根据不同的主题变量文件，编译生成不同主题的 CSS 文件。 以下是两种用 webpack 的实现方式： 多次运行 webapck，生成多个 CSS 文件 一次打包同时生成多份主题 CSS 文件比较麻烦，因此通过打包多次，每次生成一个主题对应的 css 文件来实现，而 JS 文件在这个过程中是不会改变。 // webpack.prod.conf.js module.exports = theme => { return { plugins: [ new MiniCssExtractPlugin({ filename: `[name]_${theme}.css`, }), ], resolve: { alias: { themeVars: path.join(__dirname, `../src/style/themes/theme-${theme}.css`), } } } } /*variable/color.less*/ @import \"~themeVars\" const webpack = require('webpack') const webpackConfig = require('./webpack.prod.conf') ['default', 'broker'].forEach(theme => { webpack(webpackConfig(theme), (err, stats) => {}) }) 注意： 使用 less 预处理，@import 可以直接引用 webpack.prod.conf.js 中定义的 alias，而 postcss-loader 是无法使用该 alias 的。 postcss-loader 是通过 postcss-import 来处理 @import 语句。 postcss-import 是不支持 alias 配置的，需要用另一个插件 postcss-import-alias-resolver 来实现。 // postcss.config.js const path = require('path') const aliasResolver = require('postcss-import-alias-resolver'); module.exports = { plugins: { 'postcss-import': { resolve: aliasResolver({ alias: { themeVars: path.join(__dirname, `src/style/themes`), } }) } } } /*variable/color.less*/ @import '~themeVars/theme-broker.css'; 但是，postcss.config.js 中，只能静态指定 alias，想要动态指定，需要在 webpack.prod.conf.js 中配置。实际运行时，发现 postcss-import-alias-resolver 的指定的 alias 在 webpack.prod.conf.js 中无效（？？具体原因未找到）。 最后，改用自定义 postcss-import中的 resolve 方法来实现的： // webpack.prod.conf.js module.exports = theme => { return { plugins: [ new MiniCssExtractPlugin({ filename: `[name]_${theme}.css`, }), ], module: { rules: [ { test: /\\.(css|postcss)$/, use: [ 'style-loader', 'css-loader', { loader: 'postcss-loader', options: { ident: 'postcss', plugins: (loader) => [ require('postcss-import')({ resolve: (id, basedir, importOptions) => { // 这里会将 @import \"./color.css\" 的导入文件，指向`../themes/theme-${theme}.css`。所以 color.css 可以是一个并不存在的文件。 if (id === './color.css') { return path.join(basedir, `../themes/theme-${theme}.css`) } return path.join(basedir, id) } }), // 注意，webpack的配置会覆盖postcss.config.js。 // 所以，如有其他 postcss 插件，也要移到这里 ... ] } } ] } ] } } } 运行一次 webpack， 生成多个 css 文件 （不推荐） extract-text-webpack-plugin: 多次调用插件实例，生成多个 css 文件。不过，该插件适用于 webapck 3，目前已废弃。 webpack如何extract多个css mini-css-extract-plugin：有多主题的相关讨论，但还没有可行的解决方案。 Support multiple instances of MiniCssExtractPlugin to generate multiple CSS theme output from the single CSS input JS 切换主题样式文件 JS 改变 link 标签的 href 属性 实现： 腾讯首页个性化换肤demo页面 document.getElementById('#skincolor').href = 'skin-red.css'; 注意：该方法需重新加载样式表，会带来加载延迟。样式切换不流畅，体验不太好。 JS 修改 link 标签的 disabled 属性 实现： MDN Alternative style sheets link 标签的 disabled 属性用来启用或禁用样式表。通过 JS 设置 link 标签 disabled=\"false\"，可以让默认不渲染的 CSS 开始渲染。 以上样式表都可分为3类： 无 title 属性： ，无论如何都会加载并渲染。如：reset.css。 有 title 属性： ，默认样式，CSS 文件加载并渲染。如：default.css。 有 title 属性： ，作为备选样式，CSS 文件加载，默认不渲染。如：fancy.css。 alternate 意味备用，相当于是 css 预加载进来备用，所以不会有加载换延问题。 个性化定制主题 个性化定制主题：主题是由用户定义，一般具有无限种可能，用户可以为主题变量设置任意色值。 方法一：动态创建 style 标签 该方法实现原理就是通过 JS 创建一个 style 元素，填充新样式，append 到 head 元素中，覆盖 css 文件中定义的样式。 一个简单的DEMO 一个简单的示意 .text_color { color: red; } const styleDom = document.createElement('style') styleDom.innerHTML = '.text_color { color: cyan; }' document.head.appendChild(styleDom) 该方法可以说是最简单的，也可以说是最复杂的。说简单，是因为它的实现方式直接明了；说复杂，是因为它必需逐个找到需要修改的元素的 class 名，元素越多，实现起来就越复杂。 此外，使用了 css modules 的项目，我们无法锁定需要修改的元素的 class 名。 案例分析 Element-UI 换肤： Element-UI 换肤预览 Element-UI 换肤原理 换肤实现过程： 用 Ajax 将当前页面的 CSS 文件请求回来； 处理请求回来的 CSS 数据：将需要替换的色值全部替换成新颜色值。 Element-UI 换肤的处理过程分三步： 把默认主题文件中涉及到颜色的 CSS 值替换成关键词。源码 根据用户选择的色值，生成一系列对应的新颜色值。源码 把关键词换回刚刚生成的相应的新颜色值。源码 创建 style 标签，把处理好的数据填进去，再 append 到 head 元素。相关代码 简单源码示例 function changeTheme (url, colorMap = {}) { const request = new XMLHttpRequest() request.onreadystatechange = res => { const resTarget = res.target if (resTarget.readyState !== 4) { return } if (resTarget.status === 200) { let originalStyle = resTarget.response for (let k in colorMap) { originalStyle = originalStyle.replace(new RegExp(k, 'ig'), colorMap[k]) } const styleDom = document.createElement('style') styleDom.innerText = originalStyle document.head.appendChild(styleDom) } } request.open('GET', url) request.send() } changeTheme('https://xxx.xxx.com/css_file_path/index.css', { '#508cee': '#ff5521', '#D2DFFE': '#FFDDD2' }) 方法二：LESS 在线修改变量 基于 less 写样式，为主题相关的颜色定义变量。在 HTML 中直接引入 .less 文件，再引入 less.js ，less.js 会在线将 .less 文件编译成浏览器可识别的样式，然后填充在新创建的 style 标签中。我们通过调用 less.modifyVars 方法修改主题变量实现个性化定制主题。 一个简单的DEMO LESS 在线修改变量 /**theme.less**/ @major_color: red; .text_color { color: @major_color; } less.js 在线编译 .less 文件，创建一个 style 元素，填入编译后的样式： .text_color {color: red;} JS 修改变量： window.less.modifyVars({\"@major_color\": 'cyan'}) .text_color {color: cyan;} 方法分析 引入的 .less 文件，需要在浏览器中编译，这对浏览器性能有影响，不建议在生产环境使用。 此方法仅限于用 less 的项目才能使用。sass 没有类似 less.modifyVars 的方法。 引入 .less 文件的 标签：rel 属性值必需是 stylesheet/less。 less.js 一定要在所有的 .less 文件后引用。 最后一个关键问题：如何把项目中的 less 样式（.less文件、.vue 文件中的 等）提取到一个 .less 文件中。 目前还没有找到可实现的方案。 Ant Design Pro 在线更换主题 有正在试验的方案，但目前还有问题。它的实现步骤： 合并 less：通过 antd-pro-merge-less 插件扫描 src 中所有的 less，将其合并为一个 .less 文件。 转化 css-module。 抽取 less 变量：通过 antd-theme-webpack-plugin 来做到的。它通过遍历 less 的语法树，抽取配置中所有拥有 less 变量的选择器，并且将其组合成一个 color.less 的文件。antd-theme-generator 可以查看具体实现。 实例预览：Ant Design 在线更换主题预览 最优雅的切换/自定义主题方案 CSS 变量： CSS 预设主题相关变量， 通过 JS 动态修改 CSS 变量，进而修改主题。 css 变量的设置及使用： :root { --major-color: red; } .text_color { color: var(--major-color); } JS 操作 CSS 变量： document.documentElement.style.getPropertyValue('--major-color') document.documentElement.style.setProperty('--major-color', 'purple') document.documentElement.style.removeProperty('--major-color') /* 注意：js操作css变量是在标签的style对象上，所以，对于在css文件中定义的变量，如：`:root { --major-color: red; }`，调用 getPropertyValue 方法，返回的值是空字符。 可以改用下面方法获取： */ getComputedStyle(document.documentElement).getPropertyValue('--major-color') CSS 变量最大的问题是浏览器兼容性 目前来看（2021.07），大部分主流浏览器（chrome、safari、firefox、edge等）是支持的，但是，IE 浏览器不支持。 https://caniuse.com/css-variables 总结 class 命名空间：这是个值得推荐的方案。它的唯一问题是，css 文件将多个主题的样式打包进来，文件会增大。不过，使用 postcss-themes 生成多主题样式，只会新增引用了主题相关变量的选择器，文件不会增加太多，并且，它还有个优势：切换主题不会有延迟问题。 多个 CSS 文件：相比 class 命名空间，这个方案优势在于首次加载的 CSS 文件不需要包含其他主题相关的样式。它的缺点：切换主题可能会有加截延迟；webpack 类的打包工具生成的 CSS 文件，我们通常习惯给文件名指定 hash 值，这会导致 JS 动态加载 CSS 时，无法确定正确的文件名；如果有按需加载的模块，切换主题会变得不好处理。 动态创建 style 标签：这个方案是最灵活的，可以任意修改元素的样式。其他方案都有个前提，必需先确定主题相关的变量，主题切换只能修改引用了变量的样式。它的缺点也很明显：主题切换涉及的元素越多，实现成本就越高；不适合使用了 css module 的项目；如果是基于请求已有 css 文件的数据，替换色值来实现，则会有加截延迟问题，另外，按需加载的模块也不好处理。 LESS 在线修改变量：这是个不太实用的方案。因为，在浏览器中实时编译 .less 文件，非常影响性能，不适合用于生产环境，另外，将所有主题变量相关的样式提取到一个单独的 .less 文件也比较麻烦。 css 变量方法 (推荐)：这是最完美的方案，除了不支持 IE 浏览器（目前已确定的是 IE，也可能还有些其他非主流浏览器）。 参考链接 使用 css/less 动态更换主题色（换肤功能） 一文总结前端换肤换主题 实现三方库按需引入与多主题方案 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:12:08 "},"research/05-Vue-SSR（服务端渲染）的简单实现.html":{"url":"research/05-Vue-SSR（服务端渲染）的简单实现.html","title":"Vue SSR（服务端渲染）的简单实现","keywords":"","body":"Vue SSR（服务端渲染）的简单实现 本文是在学习和运用服务端渲染时，记录实现的关键原理和主要流程，以及实际应用需要注意的一些问题。如果想快速的初步了解下服务端渲染，不妨一看；如需更深入了解，请查看 Vue SSR 指南。据我看来，官方文档中，除开发环境配置这块，其他大部分都讲得非常清晰了。 什么是服务器端渲染 (SSR)？ Vue.js 是构建客户端应用程序的框架。默认情况下，浏览器访问请求的 HTML 文件，只包含样式引入、Js 文件引入和一个 节点。HTML 的具体内容，是先加载对应的 Js 文件，再通过 Js 来创建 DOM 元素，然后挂载到 div 节点，最终渲染和绘制页面。因这些操作都是在浏览器完成的，称为客户端渲染（CSR）。 HTML文件源码结构大致如下： 标题 然而，我们也可以在服务端，先将一个 Vue 组件渲染为 HTML 字符串，然后，在浏览器访问时，直接返回包含具体内容的 HTML 字符串，浏览器只需将 HTML 字符串解析为 DOM 元素，再渲染和绘制成页面。这种称为服务端渲染（SSR）。 服务器渲染的应用程序也可以被认为是\"同构\"或\"通用\"，因为应用程序的大部分代码都可以在服务器和客户端上运行。 为什么使用服务器端渲染 (SSR)？ 与传统 SPA （Single-Page Application，单页应用程序）相比，服务器端渲染 (SSR) 的优势主要在于： 更好的 SEO：由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序需要通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。 更快的内容到达时间 (time-to-content)：无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记。你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验。 使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。 一个简单示例 // index.js const Vue = require('vue') const server = require('express')() const renderer = require('vue-server-renderer').createRenderer() server.get('*', (req, res) => { const app = new Vue({ data: { url: req.url }, template: `访问的 URL 是： {{ url }}` }) renderer.renderToString(app, (err, html) => { if (err) { res.status(500).end('Internal Server Error') return } res.end(` Hello ${html} `) }) }) server.listen(8088) 命令行运行 node index.js，在浏览器中访问 http://localhost:8088/ 即可。 其中，最关键的是如何将 Vue 组件转换为 HTML 字符串。vue-server-renderer 提供 createRenderer 和 createBundleRenderer 两个方法，分别支持将 Vue 实例和 Bundle 对象转换为 HTML 字符串。一般来说，通过 webpack 打包的 Vue 组件，输出的是 Bundle 对象。 SSR的关键步骤 改造源码结构 客户端渲染时，每个用户在自己的浏览器中使用新应用程序的实例类，创建新的上下文，用户之间互不影响。但是，服务端渲染时，Node.js 服务器运行的是一个长期进程。如果每个用户向服务器请求的是同一个实例，用户间共享上下文，就很容易导致交叉请求状态污染。因此，我们需要的是一个可以重复执行的工厂函数，再分别对客户端渲染、服务端渲染配置不同构建。 工厂函数：每个执行可以创建新的应用程序实例（包括 Vue 组件、router、store 实例） // main.js import Vue from 'vue' import AppVue from './App.vue' import { craeteRouter } from './router' import { createStore } from './store' Vue.config.productionTip = false export function createApp() { const router = craeteRouter(); const store = createStore(); const App = new Vue({ router, store, render: h => h(AppVue) }); return { App, router, store }; } 客户端渲染：只需创建应用程序，并且将其挂载到 DOM 中。 // entry-client.js import { createApp } from \"./main\"; const { App, router ,store } = createApp(); // 替换 store 中的状态 if (window.__INITIAL_STATE__) { store.replaceState(window.__INITIAL_STATE__) } router.onReady(() => { App.$mount('#app') }); 服务器渲染：使用 default export 导出函数，在每次渲染中重复调用此函数。 // entry-server.js import { createApp } from \"./main\"; const { App, router ,store } = createApp(); default export function () { return { App, router, store } } 改造构建配置（vue.config.js） vue-cli 默认创建的是纯客户端的项目配置。服务端渲染的配置大体上与纯客户端项目类似，我们可以在默认配置上，根据环境变量为服务端渲染的增加不同的配置。 客户端渲染（纯客户端）：只需指定入口文件即可。 // vue.config.js let baseConfig = { configureWebpack: { entry: './src/entry-client.js' } } module.exports = baseConfig 服务端渲染（服务器配置）：服务器配置，是用于生成传递给 createBundleRenderer 的 server bundle。 // vue.config.js ... const merge = require(\"lodash.merge\") const VueSSRServerPlugin = require('vue-server-renderer/server-plugin'); const nodeExternalsNode = require('webpack-node-externals'); baseConfig = merge(baseConfig, { outputDir: './dist/server', productionSourceMap: process.env.NODE_ENV === 'development', css: { extract: false }, configureWebpack: { entry: './src/entry-server.js', target: 'node', output: { libraryTarget: 'commonjs2' }, externals: nodeExternalsNode({ whitelist: [/\\.css$/, /\\?vue&type=style/] }), optimization: { splitChunks: false }, plugins: [ new VueSSRServerPlugin() ] }, chainWebpack: config => { const langs = [\"css\", \"postcss\", \"scss\", \"sass\", \"less\", \"stylus\"]; const types = [\"vue-modules\", \"vue\", \"normal-modules\", \"normal\"]; for (const lang of langs) { for (const type of types) { let rule = config.module.rule(lang).oneOf(type) rule.uses.clear(); rule.use().loader('null-loader'); } } } }); ... 服务端渲染（客户端配置）：客户端配置，是用于生成客户端构建清单。在 Node 中启动 Web 应用程序时，它可以自动推断和注入资源预加载 / 数据预取指令(preload / prefetch directive)，以及 css 链接 / script 标签到所渲染的 HTML。 // vue.config.js ... const merge = require(\"lodash.merge\") const VueSSRClientPlugin = require('vue-server-renderer/client-plugin'); baseConfig = merge(baseConfig, { outputDir: './dist/client', productionSourceMap: process.env.NODE_ENV === 'development', css: { sourceMap: process.env.NODE_ENV === 'development', }, configureWebpack: { entry: './src/entry-client.js', target: 'web', optimization: { runtimeChunk: { name: 'manifest' } }, plugins: [ new VueSSRClientPlugin() ] } }) ... Node.Js 启动 Web 服务 根据生成的服务端 bundle 和客户端构建清单，编译成 HTML 字符串，启动 Web 服务。 // server/index.js const path = require('path') const fs = require(\"fs\") const express = require('express') const Server = express() const serverBundle = require('../dist/server/vue-ssr-server-bundle.json') const clientManifest = require('../dist/client/vue-ssr-client-manifest.json') const template = fs.readFileSync(path.resolve(__dirname, '../src/template.html'), 'utf8') const { createBundleRenderer } = require(\"vue-server-renderer\") const renderer = createBundleRenderer(serverBundle, { runInNewContext: false, template, clientManifest }) Server.get('*', (request, response, next) => { const context = { url: request.url }; renderer.renderToString(context, (error, html) => { if (error) { next(); } else { response.end(html); } }); }, ); const rendererServerPort = 8080 Server.listen(rendererServerPort, () => { console.log(`server listening on ${rendererServerPort} port`); } ) SSR的开发环境配置 到目前为止，我们已经实现了服务端渲染的实现。可以发现，HTML字符串的生成，是基于编译后，dist 目录下的 server bundle 和客户端构建清单这两个静态文件转换的。也就是说，每次编辑过应用程序源代码之后，都必须重新编译并生成这两个文件，重启 Web 服务。这在开发过程中会影响开发效率。 在 develop 模式下，webpack 输出内容是在内存中的。为提升开发效率，我们可以启动观察模式，当源码有变化时，从内存中重新读取 server bundle 和客户端构建清单文件。 点击查看源码 vue-cli4-ssr-example。 生成客户端构建清单：在原有的【服务端渲染（客户端配置）】中加上 devServer 配置。 // vue.config.js ... baseConfig = merge(baseConfig, { ... devServer: { port: 3030, headers: { 'Access-Control-Allow-Origin': '*' } }, publicPath: 'http://localhost:' + 3030 }) ... 启动开发环境的 Web 服务： ```js // dev.js const path = require('path'); const webpack = require('webpack'); const express = require('express'); const { createBundleRenderer } = require(\"vue-server-renderer\"); const MemoryFs = require('memory-fs'); const http = require('http'); const fs = require(\"fs\") const webpackConfig = require('@vue/cli-service/webpack.config'); const rendererServerPort = 8080 const devServerPort = 3030 const MemoryFsForCompiler = new MemoryFs(); const serverBundleOutputPath = path.join(webpackConfig.output.path, 'vue-ssr-server-bundle.json'); let serverBundle; const serverCompiler = webpack(webpackConfig); serverCompiler.outputFileSystem = MemoryFsForCompiler; serverCompiler.watch({}, (error, status) => { if (error) throw error; status = status.toJson(); serverBundle = JSON.parse(MemoryFsForCompiler.readFileSync(serverBundleOutputPath, 'utf-8')); console.log('vue-ssr-server-bundle generated'); }); const htmlTempalte = fs.readFileSync(path.resolve(__dirname, '../src/template.html'), 'utf8'); const app = express(); app.get('*', async (request, response) => { if (serverBundle == undefined) { response.status(500); response.end('Server Not Ready Yet!'); } try { const renderer = createBundleRenderer(serverBundle, { runInNewContext: false, // 推荐 template: htmlTempalte, clientManifest: await getManifest(`http://localhost:${devServerPort}/vue-ssr-client-manifest.json`) }); renderer.renderToString({ url: request.url, }, (error, html) => { if (error) { response.status(404); response.end(`${request.url} Not found`); } else { response.type('html'); response.end(html); } }); } catch { response.status(500); response.end('Missing vue-ssr-client-manifest.json! Does devServer running ?') } }).listen(rendererServerPort, () => { console.log(`server listening on ${rendererServerPort} port`); } ); function getManifest(url) { return new Promise((resolve, reject) => { const client = http.get(url, (response) => { response.setEncoding('utf8'); let rawData = ''; response.on('data', (chunk) => { rawData += chunk; }); response.on('end', () => { try { resolve(JSON.parse(rawData)) } catch (e) { reject(e); } finally { client.destroy(); } }); }).on('error', reject); }); } ### 需要注意的问题 * **SSR 推荐使用：** 建议用于单页面项目，用 vue-router 管理路由、Vux 管理页面状态。多页面项目也可以用 SSR，但配置会更复杂。 * **生命周期：** SSR 中只有 `beforeCreate、created` 会被执行，而在 CSR 中所有周期都会再执行一遍。另外，在服务端代码中不要写有全局副作用的代码，如：`setInterval`，因为无法在 `beforeDestroy、destroyed `的生命周期销毁定时器。 * **尽量写通用代码：** 避免使用特定平台的 API，比如：浏览器的 `window、document、navigator` 等。特别注意第三方库的引入，有时候你并不知道引入的库能不能完全运行在 Node端/浏览器端。如果它只能运行在纯浏览器环境，可以在 `created` 阶段之后引入和执行。 * **数据预取问题：** 在 SSR 期间，如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析这些数据。 为了解决这个问题，我们采用 Vuex 管理页面状态。在服务器端，我们在渲染之前预取数据，并将数据填充到 store 中，然后，在 Vue 组件中引入这些数据。 ```js // index.vue SSR异步数据： export default { async asyncData({ store }) { return store.dispatch(\"setSsrPageData\") }, computed: { ssrPageData () { return this.$store.state.step.ssrPageData } } } // store.js export default { state: { ssrPageData: {}, }, mutations: { setSsrPageData(state, data){ state.ssrPageData = data } }, actions: { setSsrPageData: async function ({ commit }){ const res = await getAsyncData() commit('setSsrPageData', { title: res.data.title }) } }, } // entry-server.js import { createApp } from './main' const { App, store, router } = createApp() export default function createAppWithContext(context) { return new Promise((resolve, reject) => { router.push(context.url) router.onReady(async () => { const matchedComponents = router.getMatchedComponents() if (!matchedComponents.length) { return reject({ code: 404 }) } const componentWithAsyncDataTaskQueue = []; for (const matchedComponent of matchedComponents) { if (matchedComponent.asyncData !== undefined) { componentWithAsyncDataTaskQueue.push( matchedComponent.asyncData({ store }) ); } } for (const asyncTask of componentWithAsyncDataTaskQueue) { await asyncTask; } context.state = store.state; resolve(App); }, reject) }) } Cookie 问题： 当服务端数据预取跟用户信息相关时，我们通常是通过浏览器中的 Cookies 进行管理。浏览器在发送请求时，会自动把 Cookie 添加到请求中的 Header 中，而在 SSR 时，Node.Js 需要手动获取浏览器发来 Cookie，并在发送给服务端的请求 Header 中设置 Cookie。 SSR 共有3种解决 Cookies 问题的方案：一、把 Cookies 注入到 state；二、把 Cookies 注入到 global；三、将 Cookies 注入到组件的 asyncData 方法。 随着 Vue 的升级，第一种方案已经不再适用；第二种方案也有不少的限制。目前主要用到的是第三种方案： 获取浏览器 Cookie： // server/index.js Server.get('*', (request, response, next) => { const context = { url: request.url, cookie: request.headers.cookie } }) 将 Cookie 传给 asyncData 方法： // entry-server.js ... matchedComponent.asyncData({ store, cookie: context.cookie }) ... 将 Cookie 传给 actions： // index.vue export default { async asyncData({ store, cookie }) { return store.dispatch(\"setSsrPageData\", { cookie }) } } 将 Cookie 传给 api，再加到 axios 的 Headers。 // store.js export default { actions: { setSsrPageData: async function ({ commit }, { cookie } ){ const res = await getAsyncData({cookie}) commit('setSsrPageData', { title: res.data.title }) } } } Nuxt.js Nuxt.js 是一个基于 Vue.js 的通用应用框架，它预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 Nuxt.js 集成了以下组件/框架，用于开发完整而强大的 Web 应用： Vue 2 Vue-Router Vuex (当配置了 Vuex 状态树配置项 时才会引入) Vue 服务器端渲染 (排除使用 mode: 'spa') Vue-Meta 压缩并 gzip 后，总代码大小为：57kb （如果使用了 Vuex 特性的话为 60kb）。 另外，Nuxt.js 使用 Webpack 和 vue-loader 、 babel-loader 来处理代码的自动化构建工作（如打包、代码分层、压缩等等）。 参考资料 Vue SSR 指南（官方） vue-server-renderer API 参考 vue-cli4-ssr-example 再说 Vue SSR 的 Cookies 问题 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-09-15 00:10:56 "},"research/06-基于create-react-app打造代码规范化的react+ts项目.html":{"url":"research/06-基于create-react-app打造代码规范化的react+ts项目.html","title":"基于Create React App打造代码规范化的React+Ts项目","keywords":"","body":"基于create-react-app打造代码规范化的react+ts项目 Create React App 是一个官方支持的创建 React 单页应用程序的方法。它提供了一个零配置的现代构建设置。 而在实际的项目开发中，我们通常希望可以自行配置一些参数。如：webpack 的alias、typescript 的path、eslint 的rules等。本文记录了基于 create-react-app 打造 react+ts 的过程遇到的各种问题，以及对应的解决方法。 npm: 6.9.0 node: v12.2.0 react-scripts: 4.0.3 (发布新版本的 Create React App，更新 react-scripts 即可 ) 创建项目 创建 react + ts 项目： npx create-react-app my-app --typescript 安装 TypeScript 包: npm install --save typescript @types/node @types/react @types/react-dom @types/jest 将 .js、.jsx 文件重命名为 .ts、.tsx 文件（typeScript文件），运行 npm start 启动项目。 注：不需要手动创建 tsconfig.json 文件。当项目中的 src/ 路径下有TypeScript文件（.ts|tsx）时，运行 npm start 会自动创建tsconfig.json 文件。 自定义webpack CRA 项目中，webpack 的配置是封装在 react-scripts 包内。扩展 webpack 配置有以下方法： 1. npm run eject （不推荐） 它会将所有配置文件和传递依赖项（Webpack，Babel，ESLint等）复制到项目中，以便你可以完全控制它们。除 eject 之外的所有命令仍然有效，但它们将指向复制的脚本，以便你可以调整它们。 注意：这是单向操作。一旦你 eject ，你就不能回去了！ CRA 通过升级其中的 react-scripts 包来升级 CRA 的特性，而使用了 eject 命令，就再也享受不到 CRA 升级带来的好处了。因为 package 中的 scripts 的命令已经指向了项目中的配置文件，而不是指向 react-scripts 包。 2. react-app-rewired +customize-cra 安装：npm i react-app-rewired customize-cra -S 配置：在项目根目录添加 config-overrides.js 配置文件 该工具可以在不 npm run eject， 也不创建额外 react-scripts 的情况下修改 create-react-app 内置的 webpack 配置，然后你将拥有 create-react-app 的一切特性，且可以根据你的需要去配置 webpack的plugins, loaders 等。 查看更多配置 /* config-overrides.js */ module.exports = function override(config, env) { //do stuff with the webpack config... return config; } 默认情况下， config-overrides.js 文件导出单个函数，以便在开发或生产模式下自定义 webpack 配置。此外，该文件中也可以导出一个包含最多三个字段的对象，每个字段都是一个函数。如下： /* config-overrides.js */ module.exports = { // 该字段与 config-overrides.js 导出的单个函数的等效项。 // 它无法在测试模式下配置编译，也不能用于自定义开发模式下的 Webpack Dev Server。 webpack: function(config, env) { return config; }, // 该配置应用于 Jest 模式下。这意味着上述 webpack 配置在测试模式下都是无效的。 jest: function(config) { return config; }, // 在开发模式下运行时，用于生成 dev server 配置。 devServer: function(configFunction) { return function(proxy, allowedHost) { const config = configFunction(proxy, allowedHost); return config; }; }, // paths 字段用于为 create-react-app 传递到 webpack 和 jest 的路径提供覆盖。 paths: function(paths, env) { return paths; } } 使用 customize-cra。 customize-cra 用于改成 react-app-rewired 的 config-overrides.js文件。通过导入 customize-cra 功能和导出几个函数调用包裹在 override 函数中。这样，就可以很容易地修改组成create-react-app 的配置对象（webpack，webpack-dev-server，babel等）。 查看更多customize-cra api ```js / config-overrides.js / const { override, disableEsLint, addWebpackAlias, } = require(\"customize-cra\"); const path = require(\"path\"); module.exports = override( disableEsLint(), addWebpackAlias({ [\"ag-grid-react$\"]: path.resolve(__dirname, \"src/shared/agGridWrapper.js\") }) ); * 修改项目启动命令。 ```json /* package.json */ \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-scripts eject\" } 自定义 config-overrides.js 路径。 比如：您想要使用在 node_modules 中的第三方 config-overrides.js，您可以将以下内容添加到您的 package.json： \"config-overrides-path\": \"node_modules/some-preconfigured-rewire\" 3. @craco/craco craco 是另一款类似 react-app-rewired 的功能。 安装：npm i @craco/craco -S 配置：在项目根目录下添加 craco.config.js 配置文件。更看更多配置 /* craco.config.js */ const { when, whenDev, whenProd, whenTest, ESLINT_MODES, POSTCSS_MODES } = require(\"@craco/craco\"); module.exports = { reactScriptsVersion: \"react-scripts\" /* (default value) */, style: {}, eslint: {}, babel: {}, typescript: {}, webpack: { alias: { '@': path.resolve(__dirname, \"src\") }, plugins: { add: [], remove: [], }, configure: { }, // configure: (webpackConfig, { env, paths }) => { return webpackConfig; } }, jest: { }, devServer: { }, plugins: [ ] }; 修改项目启动命令 /* package.json */ \"scripts\": { \"start\": \"craco start\", \"build\": \"craco build\", \"test\": \"craco test\", \"eject\": \"react-scripts eject\" } 自定义Typescript 按上述安装方法创建项目后，运行 npm start，在 src/ 有 typescript 文件的情况下，会自动创建 tsconfig.json 文件。 你可以编辑该文件。 在建项过程中发现， 修改 tsconfig.json 文件中的 compilerOptions.paths 属性后，每次运行 npm start，该属性会被自动创建的文件覆盖。 解决方案如下： 安装： npm i @craco/craco -D 新建 tsconfig.paths.json 文件 // tsconfig.paths.json { \"compilerOptions\": { \"baseUrl\": \".\", \"paths\": { \"@/*\": [\"src/*\"] } } } 修改 tsconfig.json 文件。 // tsconfig.json { \"extends\": \"./tsconfig.paths.json\", ... } 环境变量 CRA 创建的项目可以使用环境中声明的变量，就像是在 JS 文件中本地声明的变量一样。默认情况下，项目将为你定义 NODE_ENV ，以及以 REACT_APP_ 开头的任何其他环境变量。 环境变量在构建期间嵌入。由于 Create React App 生成静态的 HTML / CSS / JS 包，因此无法在 runtime(运行时) 读取它们。项目中的环境变量，会在构建静态文件时，替换成对应的值。 console.log(process.env) // FAST_REFRESH: true // NODE_ENV: \"development\" // PUBLIC_URL: \"\" // WDS_SOCKET_HOST: undefined // WDS_SOCKET_PATH: undefined // WDS_SOCKET_PORT: undefined NODE_ENV 是一个特殊内置环境变量。当你运行 npm start 时，它总是等于 'development' ，当你运行 npm test 它总是等于 'test' ，当你运行 npm run build 来生成一个生产 bundle(包) 时，它总是等于 'production' 。你无法手动覆盖NODE_ENV。 注意：必须以 REACT_APP_ 开头创建自定义环境变量。除了 NODE_ENV 之外的任何其他变量都将被忽略。更改任何环境变量都需要重新启动正在运行的开发服务器。 自定义环境变量 有两种方式完成自定义环境变量：在 shell 中或在 .env 文件中。 在 Shell 中添加临时环境变量 定义环境变量可能因操作系统而异。 注意，这种方式对于 shell 会话是暂时的。 # Windows (cmd.exe) # 注意：变量赋值需要用引号包裹，以避免尾随空格。） set \"REACT_APP_SECRET_CODE=abcdef\" && npm start # Windows (Powershell) ($env:REACT_APP_SECRET_CODE = \"abcdef\") -and (npm start) # Linux, macOS (Bash) REACT_APP_SECRET_CODE=abcdef npm start 在 .env 中添加开发环境变量 要定义永久环境变量，请在项目的根目录中创建名为 .env 的文件： # .env REACT_APP_WEBSITE_NAME=REACT+TS项目 REACT_APP_AUTHOR=李兆 REACT_APP_SECRET_NUMBER=123456 环境变量间的引用： REACT_APP_VERSION=$REACT_APP_SECRET_NUMBER 如何使用环境变量 在 HTML 中引用环境变量 %REACT_APP_WEBSITE_NAME% 在 JS 中引用环境变量 // index.js console.log(process.env.REACT_APP_AUTHOR) 在 CSS 中引用环境变量 # .env.local REACT_APP_MAIN_COLOR=red 方法一：使用行内样式 方法二：使用 CSS in JS，即用 js 写 css，可用第三方库实现。如：Style Components、Emotion。 安装：npm i styled-components -D // index.js import styled from 'styled-components' const WrapperDiv = styled.div` color: ${process.env.REACT_APP_MAIN_COLOR} `; function App() { return css in js; } export default App; 方法三：使用 CSS 预处理器来管理全局变量。如：sass。 安装：npm install node-sass -S // craco.config.js module.exports = { style: { sass: { loaderOptions: { additionalData: \"$my-color: cyan;\" } } } } /* index.scss */ .env_variable { color: $my-color; } 其他 .env 文件 .env：默认。 .env.local：本地覆盖。除 test 之外的所有环境都加载此文件。 .env.development, .env.test, .env.production：设置特定环境。 .env.development.local, .env.test.local, .env.production.local：设置特定环境的本地覆盖。 左侧的文件比右侧的文件具有更高的优先级： npm start: .env.development.local, .env.development, .env.local, .env npm run build: .env.production.local, .env.production, .env.local, .env npm test: .env.test.local, .env.test, .env 。注意：没有 .env.local 代码规范化(Eslint\\Prettier) eslint配置 方法一：Create React App 官方给出的解决方案 添加境变量EXTEND_ESLINT为true。 修改 eslant 配置，可直接修改 package.json 配置，或者添加 eslint.js 文件。 // package.json { \"eslintConfig\": { \"extends\": [ \"react-app\", \"react-app/jest\" ], \"rules\": { 'no-console': process.env.NODE_ENV === 'production' ? 2 : 1, } }, } // eslintrc.js module.exports = { extends: [ \"react-app\", \"react-app/jest\" ], rules: { 'no-console': process.env.NODE_ENV === 'production' ? 2 : 1, }, } 方法二：修改 craco.config.js 配置。 module.exports = { eslint: { enable: true, mode: \"extends\", configure: { extends: [ \"react-app\", \"react-app/jest\" ], rules: { 'no-console': process.env.NODE_ENV === 'production' ? 2 : 1, }, }, pluginOptions: { }, }, } prettier配置 安装：npm i prettier eslint-plugin-prettier eslint-config-prettier -D 配置：在 package.json 里添加 prettier 字段，或者在项目的根目录下添加 .prettierrc 或 .prettierrc.js 或 .prettier.config.js 和 .prettierrc.toml 文件。 // package.json { ... \"prettier\": { \"printWidth\": 80, \"tabWidth\": 2, \"useTabs\": false, \"singleQuote\": true, \"semi\": false } } // .prettier.config.js module.exports = { printWidth: 80, tabWidth: 2, useTabs: false, singleQuote: false, semi: true, } 命令行： // package.json // 采用.prettier.config.js配置时，命行令中要加 --config .prettier.config.js { \"scripts\": { \"format\": \"prettier --write \\\"src/**/*.+(js|jsx|css)\\\"\", // \"format\": \"prettier --write --config .prettier.config.js \\\"src/**/*.+(js|jsx|css)\\\"\" }, } 然后，执行 npm run format即可。 整合：prettier 和 Git 整合。 安装：npm i lint-staged husky -D 配置： // package.json { ... \"lint-staged\": { \"src/**/*.{js,jsx,ts,tsx,json,css,scss,md}\": [ \"prettier --write --config .prettier.config.js \\\"src/**/*.+(js|jsx|css)\\\"\", \"git add\" ] }, \"husky\": { \"hooks\": { \"pre-commit\": \"lint-staged\" } }, } 添加 Router(路由) CRA 并未规定特定的Router(路由)解决方案，但 React Router 是最受欢迎的 Router(路由) 解决方案。 import { BrowserRouter as Router, // HashRouter as Router, Switch, Route, Link } from \"react-router-dom\"; import Home from '../home' import About from '../about' import Dashboard from '../dashboard' function App () { return ( Home About Dashboard ) } export default App React Router中的组件主要分为三类： 路由器，例如 和 使用常规URL路径。这些通常是外观最好的网址，但它们要求您的服务器配置正确。 具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面。 请注意，在部署应用程序之前，你可能需要配置生产服务器以支持客户端路由。 将当前位置存储在URL的哈希部分中，因此URL看起来类似于http://example.com/#/your/page。 由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置。 路由匹配器，例如 和 渲染 时，它会搜索其子元素 ，以查找其路径与当前URL匹配的元素。当找到一个时，它将渲染该 并忽略所有其他路由。这意味着您应该将 包含更多特定路径（通常较长）的路径放在不那么特定路径之前。 导航，例如 ， 和 添加样式 如何引入样式 添加常规 CSS 文件。即通过 import 的方式导入 .css 文件。 /**index.css**/ .app_link { color: red } import './index.css' function App() { return Learn React } export default App 添加 CSS Modules 样式表。 CRA 项目使用 [name].module.css 文件命名约定支持 CSS Modules 和常规 CSS 。 CSS Modules 允许通过自动创建 [filename]\\_[classname]\\_\\_[hash] 格式的唯一 classname 来确定 CSS 的作用域。 /**index.module.css**/ .app_module_link { color: orange; } import styles from './index.module.css'; function App() { return Learn React } export default App 最终渲染结果： Learn React 添加 Sass 样式表。 首先，安装：npm install node-sass -S，然后，将文件扩展名改为 .scss 或 .sass （建议用 .scss，书写格式更接近常规css）。 /**index.scss**/ .app_scss_link { color: $my-color; } import './index.scss' function App() { return Learn React } export default App 使用css-in-js。 // index.js import styled from 'styled-components' const LinkP = styled.p` color: deeppink; `; function App() { return Learn React } export default App 最终渲染结果： Learn React Postcss预处理器 CRA 内嵌了压缩、自动添加浏览器前缀等插件，同时，你也可以按需要引入一些 Postcss 插件。如：postcss-apply、postcss-css-variables、postcss-px2rem-exclude 等。 安装：npm i postcss-px2rem-exclude -D 配置：修改 craco.config.js，添加 postcss 插件配置 // craco.config.js module.exports = { style: { sass: { loaderOptions: { additionalData: \"$my-color: cyan;\" } }, postcss: { plugins: [ require(\"postcss-import\")({ \"path\": \"src/assets/css\" }), require(\"postcss-preset-env\")({ features: { \"custom-properties\": { preserve: false, variables: {} }, \"nesting-rules\": true } }), require(\"postcss-apply\")({}), require(\"postcss-css-variables\")({}), require(\"postcss-px2rem-exclude\")({ remUnit: 16, exclude: /node_modules|folder_name/i }), ] }, }, } 结语 CRA 项目还可以结合 redux 管理页面状态。 除了 create-react-app 外，也可以选用 dva、umi等应用框架。 dva dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。 相比于 CAR 只是多了内置的 redux 和 redux-saga，帮我们处理了数据流这方面的需求而已。如果只是想要达到这个效果的话，直接在 CAR 中增加 dva 的依赖也是可以做到的。 umi umi 是蚂蚁金服的底层前端框架，中文可发音为乌米，是一个可插拔的企业级 react 应用框架。umi 以路由为基础的，支持类 next.js 的约定式路由，以及各种进阶的路由功能，并以此进行功能扩展，比如支持路由级的按需加载。然后配以完善的插件体系，覆盖从源码到构建产物的每个生命周期，支持各种功能扩展和业务需求，目前内外部加起来已有 50+ 的插件。 参考链接 Create React App 中文文档 [译]基于create-react-app打造代码规范化的React项目 这些 CSS-in-JS 库，谁更适合你 TypeScript 中文手册 react-router-dom@5.x官方文档翻译 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/Javascript加密混淆.html":{"url":"research/Javascript加密混淆.html","title":"Javascript加密混淆","keywords":"","body":"Javascript加密混淆 为什么要对JS代码进行保护？ JS代码运行于客户端。 JS代码是公开透明的。 由于这两个原因，至使JS代码是不安全的，任何人都可以读、分析、复制、盗用，甚至篡改。因此出现了很多安全事件，典型的如：自己的原创程序代码被盗用、网站数据被篡改等等。 如果你不想让自己的代码被它人看到、不想它人了解你的代码功能，或者想降低被不怀好意的人甚至是黑客攻击。那么你应该尝试使用JS保护。 如何对Javascript代码进行保护？ 使JS代码不可读 让攻击者无法理解代码功能，也无法篡改任何功能。 使JS代码不可分析 让攻击者不能进行动态跟踪调试。 代码不可读之后，攻击者往往会进行动态跟踪调试，以期逆向还原出原始代码，或分析出程序功能。 怎么实现代码的不可读不可分析？ 代码加密：加密后的代码看似乎杂乱，但代码在执行前需要进行解密才能执行，只要找到解密函数即可还原出原始代码，所以此方式安全系数较低； 虚拟机技术：可以屏蔽JS原始关键字，但兼容性较差，无法保证在多端，多浏览器下运行； 代码混淆：使用字符串阵列化、平展控制流、多态变异、僵尸函数等手段，使代码变的不可读不可分析，达到最终保护的目的。且不影响代码原有功能。是理想、实用的JS保护方案。 JavaScript加密 密码学有一句话： 当你采用的加密模式，使得攻击者为了破解所付出的代价 远远超过其所获得的利益之时，你的加密方案就是安全的。 代码无法做到完全不可读，只能做到很难读。 只能增加逆向难度，从而提高山寨逆向成本。 造成这两点的原因是，你无法绕过浏览器的web inspector(下文简称WI)。有人会说在JS做黑盒，但其最终调用的还是浏览器提供的API。你是无法防止他人在你调用API时候拦截的。除非你的代码拥有比WI更高的API权限。否则都是没有用。 国内最知名的JS加密当属JShaman Node.js加密算法库Crypto JavaScript混淆 脱离混淆的Javascript加密是伪命题，无论怎么加密，如果不加以混淆手段保护，都没有意义。 如同传统软件的加壳保护，js混淆给底层的加密算法加了最基本的保障，在js层面来说，混淆和加密一定是相辅相成的。 由于js是动态指令码语言，在http中传输的就是原始码，逆向起来要比打包编译后的软体简单很多。暴露在外的程式码没有绝对的安全，但是在对抗中，精心设计的混淆程式码能够给破坏者带来不小的麻烦，也能够为防守者争取更多的时间，相对于破解来说，混淆器规则的更替成本要小得多，在高强度的攻防中，可以大大增加破解者的工作量，起到防御作用。从这个角度来讲，关键程式码进行混淆是必不可少的步骤。 JS混淆归结为三类： eval类型，hash类型，压缩类型 eval混淆 也是最早JS出现的混淆加密，据说第一天就被破解，修改一下代码，alert一下就可以破解了。 hash混淆 miniui 使用的JSA加密 fundebug使用的javascript-obfuscator JSA加密 和 javascript-obfuscator 的区别： 通过JSA加密混淆后生成的代码，beautifier一下，可以发现，其实没有做什么什么修改，只是做了一些变量替换。想还原也比较简单的。这里就不拿它来做代表，也没有什么人用。 通过javascript-obfuscator混淆后生成的代码，beautifier一下，分析一下可以发现，其实多了一个字典，所有方法变量，都有可能存在字典中，调用时先调用字典还原方法名变量再执行。其实入口都是变量的规则。 压缩混淆 是目前前端性能优化的常用工具，以uglify为代表。 js混淆器大致有两种 通过正则替换实现的混淆器 通过语法树替换实现的混淆器 第一种实现成本低，但是效果也一般，适合对混淆要求不高的场景。 第二种实现成本较高，但是更灵活，而且更安全，更适合对抗场景。基于语法层面的混淆器其实类似于编译器，基本原理和编译器类似，我们先对编译器做一些基本的介绍。 编译器工作流程 简单的说，当我们读入一段字串文字（source code），词法分析器会把它拆成一个一个小的单位（token），比如数字1 是一个token, 字串'abc'是一个token等等。接下来语法分析器会把这些单位组成一颗树状结构（AST），这个树状结构就代表了token们的组成关系。比如1 + 2 就会展示成一棵加法树，左右子节点分别是token - 1 和token - 2 ，中间token表示加法。编译器根据生成的AST转换到中间程式码，最终转换成机器程式码。 对编译器更多细节感兴趣的同学可以移步龙书：编译原理 混淆器工作流程 编译器需要把原始码编译成中间程式码或者机器码，而我们的混淆器输出其实还是js。所以我们从语法分析之后往下的步骤并不需要。想想我们的目标是什么，是修改原有的js程式码结构，在这里面这个结构对应的是什么呢？就是AST。任何一段正确的js程式码一定可以组成一颗AST，同样，因为AST表示了各个token的逻辑关系，我们也可以通过AST反过来生成一段js程式码。所以，你只需要构造出一颗AST，就能生成任何js程式码！ 规则设计 知道了大致的混淆流程，最重要的环节就是设计规则。我们上面说了，我们需要生成新的AST结构意味着会生成和原始码不一样的js程式码，但是我们的混淆是不能破坏原有程式码的执行结果的，所以混淆规则必须保证是在不破坏程式码执行结果的情况下，让程式码变得更难以阅读。 具体的混淆规则各位可以自行根据需求设计，比如拆分字串、拆分阵列，增加废程式码等等。 混淆器设计？ 参考：提供商业混淆服务的 jscramble的混淆规则 混淆插件 javascript-obfuscator 一个免费和高效的JavaScript混淆器(包括ES2017)。让你的代码更难复制，防止别人窃取你的成果。这个工具是一个优秀的Web UI(并且是开源的) 这个库很像在线JavaScript代码压缩网站，实际上也可以做一个在线压缩代码的网站。不过他吸引我的是他的cli工具。 ❗ 作者在Github上说了没有很多时间来维护这个项目了，使用请慎重考虑。 //源码 function aa () { console.log('aaa') } aa() //混淆后 var _cs=['\\x61\\x61\\x61']; function _f0() { console.log(_cs[0]) } _f0() uglify-js 是一款JS代码处理工具，提供了压缩，混淆和代码规范化等功能。通过以下传参数，可以对js做些混淆： mangle: { toplevel: true, // — 混淆在最高作用域中声明的变量名（默认false） eval: true, // - 混淆在eval 或 with作用域出现的变量名（默认false） properties: {} //**警告：**这能会搞崩你的代码。混淆属性名跟混淆变量名不一样，是相互独立的。会混淆对象所有可见的属性名，除了DOM属性名和JS内置的类名。 } uglify-js可以对变量名、属性、方法名进行混淆，无法对字符串进行混淆。 closure-webpack-plugin 与uglify-js类似。有对应webpack 4\\webpack 3的插件。 jscrambler jscrambler是一个商业级工具，看了很多社区的评论，这个目前是最好的，需要付费。 jsfuck（开源） jsfuck 是一个开源的js 混淆工具，原理比较简单，其实就是通过特定的字符串加上下标定位字符，再由这些字符替换源代码，从而实现混淆。而且文件体积会受很大影响。 //源码 alert('a') //转换后 [][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+........ 反调试 由于JavaScript自带debugger语法，我们可以利用死循环性的debugger，当页面打开调试面板的时候，无限进入调试状态。 把js代码转化为二进制字节码 代码可以放置其他位置（非js文件） 放到png文件中：利用HTML Canvas 2D Context获取二进制数据的特性，可以用图片存储脚本资源。 利用HTML Canvas 2D Context获取二进制数据的特性，可以用图片存储脚本资源。 放在css文件中：利用content样式能存放字符串的特性，同样可以用来存储脚本资源。 代码块预处理工具 在线加密混淆工具 https://www.jsjiami.com/ （在线） https://www.sojson.com/jsjiemi.html (在线) 参考链接： 加密基础知识四 前端JS加密传输 crypto-js js混淆加密，通过混淆Js程式码让别人(很难)无法还原 移动时代的前端加密 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/Vue如何导入TypeScript.html":{"url":"research/Vue如何导入TypeScript.html","title":"Vue如何导入TypeScript","keywords":"","body":"Vue如何导入TypeScript 什么是Typescript？ TypeScript 是微软开发一款开源的编程语言，它是 JavaScript 的一个超集，本质上是为 JavaScript 增加了静态类型声明。任何的 JavaScript 代码都可以在其中使用，不会有任何问题。TypeScript 最终也会被编译成 JavaScript，使其在浏览器、Node 中等环境中使用。由于最终运行的仍然是 JavaScript，所以 TypeScript 并不依赖于环境的支持，也并不会带来兼容性问题。 同时，TypeScript 也是 JavaScript ES6 的超集。 Vue3.0 将使用 TS 重写，重写后的 Vue3.0 将更好的支持 TS。 Google 的 Angular 2.0 也宣布采用 TypeScript 进行开发。 2019 年 TypeScript将会更加普及，能够熟练掌握 TS，并使用 TS 开发过项目，将更加成为前端开发者的优势。 为什么要用TypeScript？ TypeScript的类型注解是一种轻量级的为函数或变量添加约束的方式，它的优势在于静态类型检查。 概括来说主要包括以下几点： 静态类型检查 即你编写的代码即使没有被执行到，一旦你编写代码时发生类型不匹配，语言在编译阶段即可发现。 IDE 智能提示 在TypeScript这一类语言之前，JavaScript的智能提示基本完全依赖 IDE 提供的猜测，这种猜测可能并不正确，并且也缺乏更多的辅助信息。TypeScript不仅自己写的类库有丰富的类型信息，也可以对其他纯 JS 项目进行类型标注 (DefinitelyTyped)，便于使用者直接在 IDE 中浏览 API，效率大增。 代码重构 有时候需要修改一些变量/属性/方法名，牵涉到属性和方法的时候，很多改动是跨文件的，不像普通变量可以简单定位 scope，属性方法名的重命名对于 JS 来说异常痛苦，一方面是修改本身就不方便，另一方面是改了还不确定该改的是不是改了，不该改的是不是也改了。 而 TypeScript的静态类型系统就可以较为完美的解决这个问题。 可读性 类型就是最好的注释。对于阅读代码的人来讲，各种便利的类型一目了然，更容易明白作者的意图。 常见的变量类型定义： // 布尔值 let isDone: boolean = false; // 相当于 js 的 let isDone = false; // 变量定义之后不可以随便变更它的类型 isDone = true // 不报错 isDone = \"我要变为字符串\" // 报错 // 数字 let decLiteral: number = 6; // 相当于 js 的 let decLiteral = 6; // 字符串 let name: string = \"bob\"; // 相当于 js 的 let name = \"bob\"; // 数组 // 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组： let list: number[] = [1, 2, 3]; // 相当于 js 的let list = [1, 2, 3]; // 第二种方式是使用数组泛型，Array： let list: Array = [1, 2, 3]; // 相当于 js 的let list = [1, 2, 3]; // 在 TypeScript 中，我们使用接口（Interfaces）来定义 对象 的类型。 interface Person { name: string; age: number; } let tom: Person = { name: 'Tom', age: 25 }; // 以上 对象 的代码相当于 let tom = { name: 'Tom', age: 25 }; // Any 可以随便变更类型 (当这个值可能来自于动态的内容，比如来自用户输入或第三方代码库) let notSure: any = 4; notSure = \"我可以随便变更类型\" // 不报错 notSure = false; // 不报错 // Void 当一个函数没有返回值时，你通常会见到其返回值类型是 void function warnUser(): void { console.log(\"This is my warning message\"); } // 方法的参数也要定义类型，不知道就定义为 any function fetch(url: string, id : number, params: any): void { console.log(\"fetch\"); } 不要使用如下类型Number，String，Boolean或Object， 这些类型指的是非原始的装盒对象，它们几乎没在JavaScript代码里正确地使用过。应该使用类型number，string，and boolean。 使用非原始的object类型来代替Object 不确定的类型用Any，它是可以随便变更类型的 Vue 引入 TypeScript Vue CLI 提供了内建的 TypeScript 工具支持。如果你是新创建项目，可以查看TypeScript 支持 现有的项目，首先需要安装一些必要/以后需要的插件： # 安装vue的官方插件 npm i vue-class-component vue-property-decorator -S #ts-loader typescript 必须安装，其他的相信你以后也会装上的 npm i ts-loader typescript tslint tslint-loader tslint-config-standard -D vue-class-component：强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件。 vue-property-decorator：在 vue-class-component 上增强更多的结合 Vue 特性的装饰器 ts-loader：TypeScript为 Webpack提供了 ts-loader，其实就是为了让webpack识别.ts、 .tsx文件 tslint-loader跟tslint：我想你也会在.ts .tsx文件 约束代码格式（作用等同于eslint） tslint-config-standard：tslint 配置 standard风格的约束 配置 webpack 首先找到./build/webpack.base.conf.js。 将entry中的入口文件xx.js改成xx.ts，顺便把项目文件中的xx.js也改成xx.ts，里面内容保持不变。 找到resolve.extensions 里面加上.ts 后缀 （是为了之后引入.ts的时候不写后缀） 找到module.rules 添加webpack对.ts的解析 //webpack.base.conf.js module.exports = { entry: { 'bxs-docs': './docs/docs.ts', 'bxs-demo': './docs/demo.ts' }, ... resolve: { //默认解析扩展路径，设置完成后再引入文件后可以节约后缀名 extensions: ['.js', '.vue', '.css', '.ts', '.md'], }, module: { rules: [ { test: /\\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader' }, { test: /\\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: { appendTsSuffixTo: [/\\.vue$/], } }, ... ] }, ... } ts-loader 会检索当前目录下的 tsconfig.json 文件，根据里面定义的规则来解析.ts文件（就跟.babelrc的作用一样）。tslint-loader 作用等同于 eslint-loader 添加 tsconfig.json 接下来在根路径下创建tsconfig.json文件。这里有一份参考配置，完整的配置请点击 tsconfig.json： { // 编译选项 \"compilerOptions\": { // 输出目录 \"outDir\": \"./output\", // 是否包含可以用于 debug 的 sourceMap \"sourceMap\": true, // 以严格模式解析 \"strict\": true, // 采用的模块系统 \"module\": \"esnext\", // 如何处理模块 \"moduleResolution\": \"node\", // 编译输出目标 ES 版本 \"target\": \"es5\", // 允许从没有设置默认导出的模块中默认导入 \"allowSyntheticDefaultImports\": true, // 将每个文件作为单独的模块 \"isolatedModules\": false, // 启用装饰器 \"experimentalDecorators\": true, // 启用设计类型元数据（用于反射） \"emitDecoratorMetadata\": true, // 在表达式和声明上有隐含的any类型时报错 \"noImplicitAny\": false, // 不是函数的所有返回路径都有返回值时报错。 \"noImplicitReturns\": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 \"importHelpers\": true, // 编译过程中打印文件名 \"listFiles\": true, // 移除注释 \"removeComments\": true, \"suppressImplicitAnyIndexErrors\": true, // 允许编译javascript文件 \"allowJs\": true, // 解析非相对模块名的基准目录 \"baseUrl\": \"./\", // 指定特殊模块的路径 \"paths\": {}, // 编译过程中需要引入的库文件的列表 \"lib\": [ \"dom\", \"es2015\", \"es2015.promise\" ] } } 添加 tslint.json 在根路径下创建tslint.json文件。这里就很简单了，就是 引入 ts 的 standard 规范 { \"extends\": \"tslint-config-standard\", \"globals\": { \"require\": true } } 让 ts 识别 .vue 由于 TypeScript 默认并不支持 *.vue 后缀的文件，所以在 vue 项目中引入的时候需要创建一个 vue-shim.d.ts 文件，放在项目对应使用目录下，例如 src/vue-shim.d.ts declare module \"*.vue\" { import Vue from \"vue\"; export default Vue; } //全局变量/方法声明 declare global { interface Window { SystemJS: any; // 如果不确定类型, 可定义为any } } 意思是告诉 TypeScript *.vue 后缀的文件可以交给 vue 模块来处理。 而在代码中导入 *.vue 文件的时候，需要写上 .vue 后缀。原因还是因为 TypeScript 默认只识别 *.ts 文件，不识别 *.vue 文件： import abcd from 'components/abcd.vue' 改造 .vue 文件 import .vue 的文件的时候，要补全 .vue 的后缀，否则会提示语法错误或找不到模块 在script 标签上加上 lang=\"ts\", 意思是让webpack将这段代码识别为typescript 而非javascript vue-class-component：对 Vue 组件进行了一层封装，让 Vue 组件语法在结合了 TypeScript 语法之后更加扁平化。主要是配置以下属性： components，注册子组件 filters，过滤器 directives，注册或获取全局指令。 ... vue-property-decorator ：在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器： @Emit @Inject @Model @Prop @Provide @Watch Vue常见选项的转换 template、style模块不需要改，只需对script进行转换。 import Abcd from './Abcd.vue' import { Vue, Component, Emit, Inject, Model, Prop, Provide, Ref, Watch, PropSync } from 'vue-property-decorator' //或者 //import Vue from 'vue' //import Component, { mixins } from 'vue-class-component' //import { Emit, Inject, Model, Prop, Provide, Watch, PropSync, Ref } from 'vue-property-decorator' // 一定要用Component修饰。详情查看下一章节 @Component({ components: { Abcd } }) //Demo相当于原来的name: 'Demo' export default class Demo extends Vue { //data,直接写 count: number = 0 desc: string = '123' private tx: string = '' //用 public, private 等修飾詞來決定能不能從外部 (別的 class) 存取 // @Prop(options: (PropOptions | Constructor[] | Constructor) = {}) // @Prop装饰器接收一个参数，这个参数可以有三种写法： // Constructor，例如String，Number，Boolean等，指定 prop 的类型； // Constructor[]，指定 prop 的可选类型； // PropOptions，可以使用以下选项：type，default，required，validator。 @Prop() propA: number = 1 // readonly是typeScriptr的属性，指定为只读 // 感叹号是非null和非undefined的类型断言。如果不加，TypeScripts可能会报错\"从未被初始化过\" @Prop({ type: [String, Number], //构造器 default: 'default value', //默认值 required: true, //必传 validator() {} //检验器 }) readonly propA!: string | number //类型为Object,设置为any @Prop({ default: () => {B return {} } }) propB: any // @PropSync(propName: string, options: (PropOptions | Constructor[] | Constructor) = {}) // @PropSync装饰器与@prop用法类似，二者的区别在于，@PropSync 装饰器接收两个参数： // propName: string 表示父组件传递过来的属性名； // options: Constructor | Constructor[] | PropOptions 与@Prop的第一个参数一致； // @PropSync 会生成一个新的计算属性。 // @PropSync需要配合父组件的.sync修饰符使用 @PropSync('name', { type: String }) syncedName!: string // methods 直接在此定义 private add() { this.number++ } // 生命周期直接定义为同名屬性 created () {} mounted () {} // 计算属性 get msg () { return 'computed ' + this.demo } // @Watch(path: string, options: WatchOptions = {}) @Watch('child', { immediate: true, deep: true }) onChildChanged (val: string, oldVal: string) { if (val !== oldVal) { console.log(val) } } } 以上代码等价与： export default { name: \"Demo\", components: { Abcd }, data () { return { count: 0, desc: '123', private tx: '' } }, props: { number: { type: Number, default: 1 }, propA: { type: [String, Number], //构造器 default: 'default value', //默认值 required: true, //必传 validator() {} //检验器 }, propB: { type: Object, default: () => {B return {} } }, // @PropSync中定义的 props: { name: { type: String } } }, created () {}, mounted () {}, computed: { // @PropSync生成的计算属性 syncedName: { get() { return this.name }, set(value) { this.$emit('update:name', value) } }, msg: { return 'computed ' + this.demo } }, watch: { child: { immediate: true, deep: true, handler: 'onChildChanged' } }, methods: { onChildChanged (val: string, oldVal: string) { if (val !== oldVal) { console.log(val) } } } } @Component .vue文件中一定要用Component修饰，参数可不传。 @Component配置 vue-property-decorator不支持的属性，如: components，filters，directives等 test import Abcd from './Abcd.vue' import Component from 'vue-class-component' @Component({ components: { Abcd }, filters: {}, directives: { demo: { bind(el:any, binding:any, vnode:any, oldVnode: any) { } } } }) export default class App extends Vue {} Mixins 在TypeScript中, 我们可以这么写： // 定义要混合的类 mixins/index.ts import {Vue, Component} from 'vue-property-decorator' // 一定要用Component修饰 @Component export default class myMixins extends Vue { mixinVal: string = 'Hello Mixin' } 然后, 在其他组件中使用它： import Vue from 'vue' import Component, { mixins } from 'vue-class-component' import mixinDemo from './mixin' @Component() export default class App extends mixins(mixinDemo) { mounted () { window.console.log('mixinVal => ', this.mixinVal) } } model model是vue中的一个选项（用得比较少），它允许一个自定义组件在使用 v-model 时定制 prop 和 event。默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。 import { Vue, Component, Model } from 'vue-property-decorator' @Component export default class YourComponent extends Vue { @Model('change', { type: Boolean }) readonly checked!: boolean } 等价于： export default { model: { prop: 'checked', event: 'change' }, props: { checked: { type: Boolean } } } $emit 由@Emit修饰的函数，会在它们的原始参数之后，返回一个值。如果返回值是Promise，则在Promise执行后，再执行$emit。 如果事件的名称没有通过事件参数提供，则使用函数名。在这种情况下，camelCase名称将转换为kebabo -case。 如果@emit 对应的方法，还有别的参数，比如点击事件的 event，会在返回值之后。 也就是第三个参数。 import { Vue, Component, Emit } from 'vue-property-decorator' @Component export default class YourComponent extends Vue { count = 0 @Emit() addToCount(n: number) { this.count += n } @Emit('reset') resetCount() { this.count = 0 } @Emit() returnValue() { return 10 } @Emit() onInputChange(e) { return e.target.value } @Emit() promise() { return new Promise(resolve => { setTimeout(() => { resolve(20) }, 0) }) } } 等价于： export default { data() { return { count: 0 } }, methods: { addToCount(n) { this.count += n this.$emit('add-to-count', n) }, resetCount() { this.count = 0 this.$emit('reset') }, returnValue() { this.$emit('return-value', 10) }, onInputChange(e) { this.$emit('on-input-change', e.target.value, e) }, promise() { const promise = new Promise(resolve => { setTimeout(() => { resolve(20) }, 0) }) promise.then(value => { this.$emit('promise', value) }) } } } ref ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。 @Ref(refKey?: string)。refKey值可以为String，如果省略传输参数，那么会自动将属性名作为参数。 @Ref与@Emit的区别：@Emit在不传参数的情况下会转为 dash-case，而 @Ref不会转，为原属性名。 import { Vue, Component, Ref } from 'vue-property-decorator' import AnotherComponent from '@/path/to/another-component.vue' @Component export default class YourComponent extends Vue { @Ref() readonly anotherComponent!: AnotherComponent @Ref('aButton') readonly button!: HTMLButtonElement } 等价于 export default { computed() { anotherComponent: { cache: false, get() { return this.$refs.anotherComponent as AnotherComponent } }, button: { cache: false, get() { return this.$refs.aButton as HTMLButtonElement } } } } 另外还有些：@Inject、@Provide，不常见，这里不例举了。。。 总结 vue+webpack导入typeScript，实践过程其实并不复杂： 首先要对typescript有个初步了解，这个其实很简单，无非是对变量、函数、对象属性加了类型控制，可以查看前文中【常见的变量类型定义】，更详情的查看TypeScript 中文手册； 然后是将typescript安装到项目，新增一些配置文件，在webpack中将其引入； 最后是vue中的一些选项：data、prop、created、methods、watch、computed等的写法转换。 参考链接 Vue 如何導入 TypeScript Vue & TypeScript 初体验 vue + typescript 项目起手式 TypeScript 中文手册 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/移动端PDF预览.html":{"url":"research/移动端PDF预览.html","title":"移动端PDF预览","keywords":"","body":"移动端PDF预览 微信内置浏览器预览pdf文件，不同操作系统的表现不同： IPhone：基本可以预览各式各样的文件格式。微信自带的预览功能（不能分享，页面是微信自己的，改不了），可以直接预览PDF文件。如果图文复杂的word，微信预览也会有点错乱。 Android：打开PDF文件，会跳转到浏览器下载页面。 解决方案 通过PDF.JS来实现PDF文件的在线预览（无需下载其他插件）。其原理是将PDF文件转换成canvas/svg，在html页面上展示。 即自己开发一个页面，调用PDF.JS提供的接口，以PDF文件的地址为参数，接收接口返回的canvas或svg数据。这种自己开发的页面，还可以自行增加微信转发功能。 word文件的预览：服务端将word转成PDF文件，当然，也可以直接转换成图片。 前端我暂时没找到好的将word转换成PDF办法。服务端用linux转的话，如果图文比较复杂，会出现图文错乱的问题。 可以通过购买Window系统的服务器来转换（坑），也可以在阿里云市场购买服务（👀不太推荐，还是有点小贵的） PDF.JS pdf.js是基于HTML5技术构建的，用于展示可移植文档格式的文件(PDF)，它可以在现代浏览器中使用且无需安装任何第三方插件。 有以下两种实现方法： script标签引入方式 PDFJS.getDocument('PDF文件路径').then(pdf => { this.renderPageAsync(pdf, pdf.numPages) }) async function renderPageAsync(pdf, numPages) { for (let i = 1; i 使用npm的方式 安装：npm install pdfjs-dist -S import PDFJS from 'pdfjs-dist'; PDFJS.GlobalWorkerOptions.workerSrc = 'pdfjs-dist/build/pdf.worker.js'; 这两个文件包含了获取、解析和展示PDF文档的方法，但是解析和渲染PDF需要较长的时间，可能会阻塞其它JS代码的运行。 为解决该问题，pdf.js依赖了HTML5引入的Web Workers——通过从主线程中移除大量CPU操作（如解析和渲染）来提升性能。 PDF.js的API都会返回一个Promise，使得我们可以优雅的处理异步操作。数据返回后的渲染方法，与上方renderPageAsync方法类似。 PDFh5 pdfh5.js 是基于pdf.js和jQuery，在移动端预览PDF的插件。 支持手势捏合缩放、支持canvas、svg两种渲染模式、支持ajax、fetch两种请求方式、支持懒加载。 web/h5/移动端PDF预览手势缩放插件。支持canvas、svg两种渲染模式，支持ajax、fetch两种请求方式。支持懒加载。 有以下两种实现方法： script标签引入方式 需下载pdfh5项目下所有文件，包css、js、bcmap等。 new window.Pdfh5('#pdf_viewer', { pdfurl: 'pdf文件路径', cMapUrl: '//res.winbaoxian.com/pdfjs/web/cmaps/', renderType: 'svg' }) 使用npm的方式 安装：npm install pdfh5 -S import Pdfh5 from \"pdfh5\"; export default { ... data: { return { pdfh5: null } }, mounted() { this.pdfh5 = new Pdfh5(\"#pdf_viewer\", { pdfurl: \"\" //pdf文件路径 }); this.pdfh5.on(\"complete\", function (status, msg, time) { //监听完成事件 }) } } @import \"pdfh5/css/pdfh5.css\"; 手机兼容性 机型 编号 系统版本 备注 lenovo（白色） 08-201600-021 4.3 异常。页面一直在加载状态 oppo(深蓝) 08-201600-034 4.4.4 正常 vivo X27 - 9 正常 iphone 8 - 12.4 正常 小米 note3 08-201703-191 5.1.1 正常 注意问题 跨域问题 本地开发：webpack中添加代理 devServer: { open: false, port: 8080, // 自定义修改8080端口 proxy: { // 代理跨域 '[/pdf文件存储目录]': { target: 'https://img.xxxxx.com', changeOrigin: true } } } 修改服务器(nginx)配置 后端提供api，将pdf文件转成byte[]，然后用pdf.js解析data 版本问题 引入1.8.**版本，采用svg模式，部分手机会(如：小米 note3)有bug。 引用最新pdf.js版本 乱码问题 pdf文件因字体、编码的问题，可能出会现乱码问题，需引入一些资源文件。 //缺少GBK-EUC-H.bcmap，加载错误 https://pbf.winbaoxian.com/planBook/planbookAccessories/pdf-viewer/index.html?file=https://img.winbaoxian.com/static/app-zx-rule-pdf/allrule/tempDir/%E5%85%89%E5%A4%A7%E6%B0%B8%E6%98%8E%E4%BA%BA%E5%AF%BF%E4%BF%9D%E9%99%A9%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8%E5%85%89%E5%A4%A7%E6%B0%B8%E6%98%8E%E5%85%89%E6%98%8E%E8%B4%A2%E5%AF%8C%E9%87%8D%E5%A4%A7%E7%96%BE%E7%97%85%E4%BF%9D%E9%99%A9%E6%9D%A1%E6%AC%BE_20170622064151.pdf //解决方法 new window.Pdfh5('#pdf_viewer', { pdfurl: 'pdf文件路径', cMapUrl: '资源文件夹', //默认是相对路径'./js/cmaps/' //为减少本地项目体积，已上传到cdn：'//res.winbaoxian.com/pdfjs/web/cmaps/' }) bcmap 一词代表 二进制cmap。 CMaps(字符映射)是PostScript和其他Adobe产品中使用的文本文件，用于将字符代码映射到CID字体中的字符字形。 请参阅Adobe的此文档了解哪些CID字体适合使用。它们主要用于处理东亚书写系统。(此技术是一项传统技术，因此不应在现代工具创建的pdf中使用)。pdfjs想要显示这样的CID字体时，它需要CMap文件。 CDN 跨域问题 跨域配置在某些节点没有启效 运维强制推送一遍，目前问题已解决。 由于CDN的特性会缓存源站的响应 阿里云已帮忙解决 建议：上传PDF文件后，先在链接中预览下 内容不满一页 svg模式下，字体大小的原因，在pc端，内容显示可能会不满一页。 改用canvas模式 参考链接 PDF.js实现个性化PDF渲染（文本复制） 移动端展示pdf(在线打开pdf)-pdfh5.js、pdf.js © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"research/纯CSS绘制箭头.html":{"url":"research/纯CSS绘制箭头.html","title":"纯CSS绘制箭头","keywords":"","body":"纯CSS绘制箭头 用CSS即可绘制出各种箭头，无需裁剪图片，甚至没有用到 CSS3 的东西。对浏览器支持良好。 边框箭头 原理非常简单，通过截取border的部分“拐角”实现 .box_01 { padding: 10px 0; text-align: center; } .box_01 .item_01 { display: inline-block; width: 80px; height: 80px; margin: 20px 0; background: rgba(255, 0, 0, 0.1); border-color: red; border-width: 0 0 1px 1px; border-style: solid; transform: rotateZ(-45deg); } 查看DEMO 实心箭头 当元素宽、高为零，且其他边为透明颜色时，可以形一个三角形。改变各个边的宽度，即通过调整“边框”厚度可以配置出任意角度 .box_01 .item_02 { display: inline-block; width: 0; height: 0; border: 50px solid transparent; border-top-color: #0dd; } 查看DEMO 90°之外的箭头 常见的箭头设计是大于90°的，在上面例子的基础上，“压扁”或“拉长”矩形不就可以了吗?而“压扁”或“拉长”需要用skew()就能实现，只不过需要做些角度的计算。 按照width: 100px;角度120°的需求来定义边长、角度两个变量。height = width * cos(30°) = width * sin(60°)。 .box_01 .item_03 { display: inline-block; width: 100px; height: 86px; transform: rotate(-30deg) skewX(30deg); background: #e4ffe7; border-bottom: 1px solid #00ff22; border-left: 1px solid #00ff22; } 查看DEMO .box_04 { padding: 0; position: relative; height: 80px; } .box_04 .item_04 { position: absolute; left: 40%; width: 10px; height: 40px; background: #f50; } .box_04 .item_04:nth-child(1) { top: 0; transform: skewX(30deg); } .box_04 .item_04:nth-child(2) { bottom: 0; transform: skewX(-30deg); } 查看DEMO 终极实现方法 transform: matrix实现任意大小，任意方向， 任意角度的箭头 。 先把div 旋转45度， 让它成为一个 菱形 然后再伸缩，达到任意的角度， 这样就可以得到一个 任意角度的箭头。由于用到了旋转和伸缩两种变换，所以需要使用 transform: matrix(a,b,c,d,e,f) 这个变换矩阵。 .box_01 .item_05 { display: inline-block; width: 40px; height: 40px; margin-top: 20px; border-top: 2px solid #f50; border-right: 2px solid #f50; transform: matrix(0.7071067811865475, 0.7071067811865476, -0.7071067811865476, 0.7071067811865475, 0, 0); } 查看DEMO (没看懂。感兴趣的可以点击下方链接查看。lizh) 参考链接 css箭头 使用css实现任意大小，任意方向， 任意角度的箭头 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:10:31 "},"research/网站性能测量和优化方法.html":{"url":"research/网站性能测量和优化方法.html","title":"网站性能测量和优化方法","keywords":"","body":"网站性能测量和数据统计 以用户为中心的性能指标 网页的性能，以及网页应用的运行速度不能仅用加载时间来评估。加载时间会因为用户不同而有很大的变化，具体取决于用户的设备功能以及网络状况。 但事实是，随时都有可能发生性能不佳的情况，不只限于加载期间。 应用无法迅速响应点按或点击操作，以及无法平滑滚动或产生动画效果的问题与加载缓慢一样，都会导致糟糕的用户体验。 用户关心的是总体体验，我们开发者也应如此。 所有这些性能误解有一个共同的主题，即开发者都将注意力集中在对于用户体验帮助不大甚至全无帮助的事情上。 同样地，加载时间或 DOMContentLoaded 时间等传统性能指标极不可靠，因为加载发生的时间可能与用户认为的应用加载时间对应，也可能不对应。 当用户导航到网页时，通常会寻找视觉反馈，以确信一切符合预期。 是否发生？ 导航是否成功启动？服务器是否有响应？ 是否有用？ 是否已渲染可以与用户互动的足够内容？ 是否可用？ 用户可以与页面交互，还是页面仍在忙于加载？ 是否令人愉快？ 交互是否顺畅而自然，没有滞后和卡顿？ 为了解页面何时为用户提供这样的反馈，我们定义了多个新指标： 首次绘制与首次内容绘制。 Paint Timing API 定义两个指标：首次绘制 (FP) 和 首次内容绘制 (FCP)。 这些指标用于标记导航之后浏览器在屏幕上渲染像素的时间点。 这对于用户来说十分重要，因为它回答了以下问题： 是否发生？ 这两个指标之间的主要差别在于，FP 标记浏览器渲染任何在视觉上不同于导航前屏幕内容之内容的时间点。 相比而言，FCP 标记的是浏览器渲染来自 DOM 第一位内容的时间点，该内容可能是文本、图像、SVG 元素。 首次有效绘制和主角元素计时 首次有效绘制 (FMP) 指标能够回答“是否有用？”这一问题。 虽然“有用”这一概念很难以通用于所有网页的方式规范化（因此尚不存在任何规范），但是网页开发者自己很清楚其页面的哪些部分对用户最为有用。 网页的这些最重要部分通常称为主角元素。 耗时较长的任务 对于用户而言，任务耗时较长表现为滞后或卡顿，而这也是目前网页不良体验的主要根源。 可交互时间 可交互时间* (TTI) 指标用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点。 应用可能会因为多种原因而无法响应用户输入： 页面组件运行所需的 JavaScript 尚未加载。 耗时较长的任务阻塞主线程（如上一节所述）。 TTI 指标可识别页面初始 JavaScript 已加载且主线程处于空闲状态（没有耗时较长的任务）的时间点。 下表概述刚刚列出的各个指标如何对应到我们希望优化的体验： 体验 指标 是否发生？ 首次绘制 (FP)/首次内容绘制 (FCP) 是否有用？ 首次有效绘制 (FMP)/主角元素计时 是否可用？ 可交互时间 (TTI) 是否令人愉快？ 耗时较长的任务（在技术上不存在耗时较长的任务） 性能分析工具 PageSpeed Insights PageSpeed Insights 能够针对移动设备和桌面设备生成网页的实际性能报告，并能够提供关于如何改进相应网页的建议。 gtmetrix 查看您网站的效果，揭示网站运行缓慢的原因，并发现优化机会。 通过配置的监视来跟踪页面性能，并通过交互式图形将其可视化。 监控页面并每天，每周或每月进行测试以确保最佳性能 使用3个可用的图表可视化性能：页面加载时间，页面大小和请求计数以及PageSpeed和YSlow得分 缩放，平移和设置日期范围以查找特定的性能历史记录 在图形上注释感兴趣的区域并提供数据上下文 根据PageSpeed / YSlow得分，页面加载时间，总页面大小等，在多种情况下设置警报 用户注册后，可以设置cookie解决登录问题 数据统计工具 Google Analytics（分析）使用入门 Omniture 大前端神器安利之 Puppeteer 实现：在node中引用puppeteer，获取网页的performance.timing，将数据存入mysql。 设置cookie解决登录问题 const browser = await puppeteer.launch({ devtools: true, headless: false, defaultViewport: { width: 375, height: 667 } }) const browserPage = await browser.newPage() await browserPage.setCookie({ name: 'token', value: '', domain: '.abc.com', path: '/', expires: 1640995200000, httpOnly: false, secure: false, sameSite: \"Strict\" }); chrome 网速预设值 Preset download(kb/s) upload(kb/s) RTT(ms) GPRS 50 20 500 Regular 2G 250 50 300 Good 2G 450 150 150 Regular 3G 750 250 100 Good 3G 1000 750 40 Regular 4G 4000 3000 20 DSL 2000 1000 5 WiFi 30000 150000 2 Lighthouse 使用 Lighthouse 对网站进行测评后，我们会得到一份评分报告，它包含了性能（Performance），PWA（Progressive Web App），访问无障碍（Accessibility），最佳实践（Best Practice），搜索引擎优化（SEO）等几个部分。 影响评分的性能指标 性能测试指标分成了 Metrics，Diagnostic，Opportunities 三部分。通常情况下，只有 Metrics 部分的指标项会对分数产生直接影响，Lighthouse 会衡量以下性能指标项： 首次内容绘制（First Contentful Paint） 即浏览器首次将任意内容（如文字、图像、canvas 等）绘制到屏幕上的时间点。 算法-首次有效渲染时间(Time to First Meaningful Paint) 首次有效绘制（First Meaningful Paint） 衡量了用户感知页面的主要内容（primary content）可见的时间。对于不同的站点，首要内容是不同的，例如：对于博客文章，标题及首屏文字是首要内容，而对于购物网站来说，图片也会变得很重要。 首次 CPU 空闲（First CPU Idle） 即页面首次能够对输入做出反应的时间点，其出现时机往往在首次有效绘制完成之后。该指标目前仍处于实验阶段。 可交互时间（Time to Interactive） 指的是所有的页面内容都已经成功加载，且能够快速地对用户的操作做出反应的时间点。该指标目前仍处于实验阶段。 速度指标（Speed Index） 衡量了首屏可见内容绘制在屏幕上的速度。在首次加载页面的过程中尽量展现更多的内容，往往能给用户带来更好的体验，所以速度指标的值约小越好。 输入延迟估值（Estimated Input Latency） 这个指标衡量了页面对用户输入行为的反应速度，其基准值应低于 50ms。 性能优化方案 懒加载(动态加载) 懒加载或者按需加载，是一种很好的优化网页或应用的方式。尤其是内容较多的页面。减少页面初始化时，需要加载的JS文件体积 这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。 export default { ... components: { Abc: () => import('./abc.vue') }, ... } https://juejin.im/post/59bf501ff265da06602971b9 Vue路由和组件的懒加载 按需加载 使用babel-plugin-component实现按需引入、打包。过滤无用模块，减少JS文件体积 修改.babelrc配置： //.babelrc { ... \"plugins\": [ \"transform-runtime\", [ \"component\", [ { \"libraryName\": \"mint-ui\", \"style\": true }, { \"libraryName\": \"bxs-ui-vue\", \"libDir\": \"lib\", \"style\": \"index.css\" } ] ] ], ... } 外部扩展(externals) 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖(external dependencies)。 //html文件引入js //webpack.base.conf.js module.exports = { ... externals: { vue: 'Vue' }, ... } 静态方件上传到CDN //webpack.prod.conf.js const AliOSSPlugin = require('webpack-alioss-plugin') webpackConfig.plugins.push(new AliOSSPlugin({ project: '', // 项目名(用于存放文件的直接目录) })) 骨架屏 page-skeleton-webpack-plugin(饿了么) Page Skeleton 是一款 webpack 插件，该插件的目的是根据你项目中不同的路由页面生成相应的骨架屏页面，并将骨架屏页面通过 webpack 打包到对应的静态路由页面中。 有以下特点： 支持多种加载动画 针对移动端 web 页面 支持多路由 可定制化，可以通过配置项对骨架块形状颜色进行配置，同时也可以在预览页面直接修改骨架页面源码 几乎可以零配置使用 测试结果（lizh）： 骨架元素的结构跟实际的页面有差异 骨架页面元素的大小无法自适应 即无法参数配置html的fontSize值 只适用vue-router项目（单页面项目） 注入的js是根目录的，不是当前页面的；且生成文件路径的跟现有不一样(planbookInput项目) 不适用页面内容不固定的页面 比如：有些页面需要根据URL中的传参，展示不同内容。生成骨架屏时无法预知 vue-skeleton-webpack-plugin(百度) 基于 Vue 的 webpack 插件，为单页/多页应用生成骨架屏 skeleton，减少白屏时间，在页面完全渲染之前提升用户感知体验。 有以下不足： 需要手动去写骨架屏的样式 骨架屏样式在不同尺寸下的响应式问题 在界面改动之后也需要手动修改对应的骨架屏 骨架页面的组件无法热更新 (官方说法是已经支持了，没找到原因) draw-page-structure(京东) 提供两种方法来盛放生成的骨架屏节点： 配置 output.filepath，如果配置的是目录，会写入到该目录里的 index.html (没有的话我们会创建)文件里； 自定义写入的方式 writePageStructure: (outputHtml: string) => void;； 如果前面两种方式您都没有提供，那么将会在您当前目录下创建 index.html ，并将骨架屏节点写入； 有以下不足： 登录问题，解决方法不是很友好 (查看解决方法)。 生成的样式，不太美观 Vue SSR 服务端渲染 什么是服务器端渲染 (SSR)？ Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记\"激活\"为客户端上完全可交互的应用程序。 服务器渲染的 Vue.js 应用程序也可以被认为是\"同构\"或\"通用\"，因为应用程序的大部分代码都可以在服务器和客户端上运行。 这里说的渲染，就是指生成 HTML 文档的过程。简单来说， 浏览器端渲染，指的是用 JS 去生成 HTML，例如 React, Vue 等前端框架做的路由。 服务器端渲染，指的是用后台语言通过一些模版引擎生成 HTML，例如 Java 配合 VM 模版引擎、NodeJS配合 Jade 等，将数据与视图整理输出为完整的 HTML 文档发送给浏览器。 为什么使用服务器端渲染 (SSR)？ 与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于： 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。 也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。 无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。 使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。 更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。 是否真的需要使用服务器端渲染 (SSR)？ 在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。 这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。 如何看一个网页是否是服务器端渲染？ 简单的方式是在 Chrome 浏览器打开控制台/开发者工具，查看 Network 中加载的资源。浏览器端渲染，html文档的body节点中只有一个div节点和css/js文件引用。其他节点是在浏览器中，js生成的。 参考链接 蚂蚁金服如何把前端性能监控做到极致? 一种自动化生成骨架屏的方案 前端骨架屏方案小结 Vue SSR 指南 带你走近Vue服务器端渲染（VUE SSR） © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"tech/01-内网穿透（web服务、远程桌面）.html":{"url":"tech/01-内网穿透（web服务、远程桌面）.html","title":"内网穿透（Web服务、远程桌面）","keywords":"","body":"内网穿透（web服务、远程桌面） 内网穿透 内网，其实就是在公司或者是家庭内部，建立的一种局域网络或者是办公网络，从而实现多台电脑之间可以进行资源的共享，包括设备、资料、数据等。 外网，则是由一个网关与其它的网络系统连接，相对于内网而言，这种网络系统称之为外部网络，也就是我们经常说到的互联网。 内网穿透就是别人通过外网能够访问到我们本地的服务器，也称为内网穿透动态域名解析服务（nat-DDNS）是一种基于动态域名服务（DDNS）和网络地址转换（nat）的服务器内外网动态映射方法。 我们在做开发时，搭建的本地服务器只能供我们自己电脑的浏览器访问，或者处于同一个wifi下的手机访问，但是我们如果想让别人访问到我们的本地服务器。 我们就要做内网穿透了。 内网穿透的原理 内网穿透是我们在进行网络连接时的一种术语，也叫做NAT穿透，即在计算机是局域网内的时候，外网与内网的计算机的节点进行连接时所需要的连接通信。内网穿透的功能就是，当我们在端口映射时设置时，内网穿透起到了地址转换的功能，也就是把公网的地址进行翻译，转成为一种私有的地址，然后再采用ADSL（Asymmetric Digital Subscriber Line，非对称数字用户线路，是宽带接入技术的一种）的宽带路由器，将一个动态或者是固定的公网IP，最后ADSL在交换机上，这样所有的电脑都可以共享上网。内网穿透除了可以实现内网之间机器的网络通信功通之外，还可以解决UDP中出现的数据传输不稳定问题。 NAT（网络地址转换） NAT（Network Address Translation，网络地址转换）属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 NAT工作原理： 当私有网主机和公共网主机通信的IP包经过NAT网关时，将IP包中的源IP或目的IP在私有IP和NAT的公共IP之间进行转换。 如下图所示，NAT网关有2个网络端口，其中公共网络端口的IP地址是统一分配的公共 IP，为202.20.65.5；私有网络端口的IP地址是保留地址，为192.168.1.1。 客户机发起请求：私有网中的主机192.168.1.2向公共网中的主机202.20.65.4发送了1个IP包Dst=202.20.65.4,Src=192.168.1.2。（src = source，源；dst = destination，目的） NAT网关将私网IP转为公网IP：当IP包经过NAT网关时，NAT Gateway会将IP包的源IP转换为NAT Gateway的公共IP并转发到公共网，此时IP包Dst=202.20.65.4，Src=202.20.65.5中已经不含任何私有网IP的信息。 服务端响应：Web Server发出的响应IP包Dst= 202.20.65.5,Src=202.20.65.4发送到NAT Gateway。 NAT网关将公网IP转为私网IP：NAT Gateway会将IP包的目的IP转换成私有网中主机的IP，然后将IP包Des=192.168.1.2，Src=202.20.65.4转发到私有网。对于通信双方而言，这种地址的转换过程是完全透明的 NAT网关连接跟踪：NAT Gateway在收到响应包后，就需要判断将数据包转发给谁。此时如果子网内仅有少量客户机，可以用静态NAT手工指定；但如果内网有多台客户机，并且各自访问不同网站，这时候就需要连接跟踪connection track。 在NAT Gateway收到客户机发来的请求包后，做源地址转换，并且将该连接记录保存下来，当NAT Gateway收到服务器来的响应包后，查找Track Table，确定转发目标，做目的地址转换，转发给客户机。 NAT网关端口转换：如果Client A和Client B同时访问Web Server，那么当NAT Gateway收到响应包的时候，就无法判断将数据包转发给哪台客户机。 NAT Gateway会在Connection Track中加入端口信息加以区分。如果两客户机（端口不同）访问同一服务器，那么在Track Table里加入端口信息即可区分，如果两客户机端口正好相同，那么在实行NAT的同时对源端口也要做相应的转换。 NAPT原理（网络地址端口转换） NAPT（Network Address Port Translation，网络地址端口转换），是NAT的进一步扩展，在NAT进行IP地址转换的同时进行Port的转换。 内网穿透工具 工具名称 模式 支持模式 教程文档 说明 Frp 免费 TCP、http(s)、udp 官网 推荐 Sunny-Ngrok 免费/收费 TCP、http(s)、udp 官网 推荐 Ngrok 免费/收费 TCP、http(s)、Websocket 官网 速度慢 Natapp 免费/收费。 TCP、http(s)、wss 官网 免费需实名认证 其他：小米球（免费/收费）、echosite（收费）、Ssh、autossh（免费）、花生壳（免费模式，不技持web访问）。 Frp 安装使用 Window安装过程 查看官网教程 Sakura frp账号注册。在官网https://www.natfrp.com/注册，成功后会跳转到 管理面板，在左侧栏点击软件下载，win10选第一个就好了。 创建并启动隧道。 打开刚才下载的软件，点击安装SakuraLauncher.exe，在界面中输入访问密钥进行登陆。密钥在官网的管理面板查看。 登陆完成后，点左边菜单栏的隧道，点击新建隧道。也可以在官网中创建隧道，创建后，需要重启SakuraLauncher.exe，才能在软件隧道列表中看到。 本地ip：通常可以填127.0.0.1。window通过cmd运行ipconfig查看。 查看本地IP地址：按win+r，输入cmd按enter，输入ipconfig 端口：远程桌面的端口默认是3389（左侧TCP端口监听列表中，如果没有3389，说明远程桌面服务没启，需要手动启动下）。其他，如启动web服务localhost:3000，则填3000。 启动远程桌面端口：输入services.msc按enter，找到 remote desktop services，右击选择启动。或者计算机 -> 管理 -> 服务和应用程序 -> 服务 -> Remote Desktop Services，启动远程服务。 隧道名称：可不填，会产生一个随机的名称 隧道类型：远程桌面选择TCP，web服务也可以选择TCP。如果选http\\https类型，需要有备案过的域名。 远程端口：可以自己指定，范围是10240~65535，不能和已有的重复。默认0，会随机分配一个。 服务器：一般没有特殊需求可能随便选。如果是web服务，则需要查看服务器是否支持建站。官网查看隧道类型介绍 点击开启刚才的隧道，会弹出日志信息。这个日志信息上面的IP或者服务器域名+端口，是用于远程桌面连接、web页面访问的地址。 Mac安装过程 查看官网教程 下载frpc_darwin_amd64文件。 用 root 权限执行自动安装的脚本：sudo bash 。 根据安装后的提示，启动隧道： -f : 我在自动安装过程中，执行命令sudo bash 出错了；后来试了sudo wget -O- https://getfrp.sh也不行，是mac的wget不支持https协议；最后，我是将文件下载到本地，再用bash执行。 创建http(s)隧道 必需自己要有可用的域名。如果没有，就创建tcp隧道，一样可以访问web页面。 不是所有服务器都支持建站，具体需查看服务器的描述。 通过所选服务器的域名或ip + 端口来连接或访问（无论是web服务，还是远程桌面连接）。 Sunny-Ngrok 注册账号 下载客户端。解压后有两个文件：sunny.exe和Sunny-Ngrok启动工具.bat。 购买（有免费服务器）、开通隧道 命令行启动隧道： 方法一：通过 cmd命令行进到 sunny.exe所在的目录执行，运行：sunny.exe clientid 隧道id或者sunny.exe clientid 隧道id,隧道id（多个隧道同时启动）。 方法二：通过 Sunny-Ngrok启动工具.bat 启动，直接输入隧道id就好了 Ngrok 下载 -> 解压 -> 安装：在Linux或OSX上，您可以使用以下命令从终端解压缩ngrok。在Windows上，只需双击 ngrok.zip。 注册账号：运行此命令会./ngrok身份验证令牌，将您的身份验证令牌添加到您的 ngrok.yml文件中。连接帐户将在仪表板上列出您打开的隧道，为您提供更长的隧道超时时间，以及更多。访问信息中心以获取您的身份验证令牌。 启动：命令板中试执行./ngrok help，查看是否安装成功；运行./ngrok http 80启动80端口的http隧道。 恢复window 10远程桌面功能 如果window 10是家庭版，则不支持远程桌面，需要安装 RDP Warp 恢复Win10家庭版系统的远程桌面访问功能。 下载RDP Warp。项目地址：https://github.com/stascorp/rdpwrap，在页面的`Release`找到下载页面，下载`zip`文件，解压。 首先运行RDPCheck.exe，这是一个测试程序，会尝试建立一个和本机之间的远程连接。如果连接成功，那么说明你的主机是支持完整的远程桌面连接功能的，也就不需要进行后续操作了。如果失败，那么接着以管理员身份运行install.bat，执行安装。 安装程序结束之后，运行RDPConf.exe，查看目前的远程桌面服务的运行状态。 如果Wrapper state：Not installed，是没有安装成功，可能是被杀毒软件拦截了。 如果Listener state一项是红色的，显示not listening [not supported]，这是因为其中一个文件无效引起的，我们可以手动加下。 解决方法： 以管理员权限运行 Powershell/CMD 运行命令 net stop termservice，关闭Remote Desktop Services服务 下载rdpwrap.ini文件，将下载到的文件替换到 C:\\Program Files\\RDP Wrapper文件夹。注意：rdpwrap.ini有可能对你的电脑无效，这跟window系统版本有关，你可以从网上找其他rdpwrap.ini文件。 运行命令 net start termservice，恢复 Remote Desktop Services 服务 运行update.bat，再运行RDPConf.exe查看。成功的话。 Diagnostics里面的三个状态都是绿的，那么远程桌面连接功能已经恢复了。 远程桌面连接 内网的连接，直接输入被控电脑的本地ip即可；外网需要先做内网穿透。 远程桌面连接（主控电脑）： window 7：Windows -> 附件 -> 远程桌面连接 -> 输入被控电脑的本地IP或内网穿透后的ip window 10：单击搜索 -> 远程桌面连接 -> 打开 -> 输入被控电脑的本地IP或内网穿透后的ip mac： ？？ 允许连接远程桌面（被控电脑）： window的远程桌面连接，可以使用自带的远程桌面连接；mac需要借助microsoft remote desktop类的工具实现。 window 7：计算机 -> 右击，选择【属性】 -> 远程设置 -> 远程，设置允许远程控制。 window 10：开始 -> 设置 -> 系统 -> 远程桌面， 远程桌面连接，需要注意： 被控电脑正常运行 被控电脑启动了远程桌面服务，且设置为允许远程桌面服务。 需要被控电脑的登录账号和密码。有些电脑，如果有没密码，是不允许远程桌面连接的，如：window 7。 有些电脑的防火墙或杀毒软件，可能会影响远程桌面连接服务。 microsoft remote desktop 下载安装： mac：https://microsoft-remote-desktop-connection.softonic.cn/mac window：https://remote-desktop-windows-10.softonic.cn/download 添加被控制 PC 的 IP 、登录账号、密码。 teamviewer TeamViewer 是全面的远程访问、远程控制及远程支持解决方案，几乎适用于所有桌面和移动平台，包括 Windows、macOS、Android 及 iOS。 使用流程如下： 下载：https://www.teamviewer.cn/cn/products/teamviewer/，安装软件**（主控和被控PC都必需安装）**。 注册账号。 输入伙伴的ID（被控电脑的teamviewer ID）。 参考链接 网络地址转换NAT原理 NAPT和NAT的工作原理及其区别 可以实现内网穿透的几款工具 超全内网穿透工具,github项目及方法 Win10（家庭版）内网穿透实现远程桌面访问 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:14:36 "},"tech/04-sublime3插件篇.html":{"url":"tech/04-sublime3插件篇.html","title":"Sublime3插件篇","keywords":"","body":"sublime3 插件篇 插件管理工具 错误安装(不可用) 按Ctrl + `(此符号为tab按键上面的按键) 调出console，粘贴以下代码到命令行并回车： import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 遗憾的是：Sublime text 3已经不支持Package Control安装插件了！ 正确安装（可用） 手动下载一个package control的包：https://github.com/wbond/package_control。 下载解压后，将解压文件重新命名为：Package Control，拷贝到sublime 的packages目录下。可以直接菜单栏Perferences -->Browse Packages打开。 严格按照上面明明，首字母记住要大些！！！ 重启sublime，点击菜单栏Perferences，会发现多了Package Settings 和Package Control这两个菜单，这就说明 Package Control安装成功了。 尝试下安装一个插件，如Emmet。Ctrl +Shift+P 打开控制台，输入install，选择Install Package。此时要等待一会，因为Package Control 正在加载插件列表。 但是很不幸，又失败了！控制台提示无法访问https://packagecontrol.io/channel_v3.json。这个应该也是被墙了... 不过，别慌！这是可以解决的。 打开Package Settings-->Package Control --> Settings User，加入如下内容： \"channels\": [ \"http://cst.stu.126.net/u/json/cms/channel_v3.json\"] http://cst.stu.126.net/u/json/cms/channel_v3.json是个国内的战点 常用插件列表 官网插件库 用Package Control安装插件的方法：按下Ctrl+Shift+P调出命令面板，输入install调出Install Package选项，然后在列表中选中要安装的插件。 注意：安装插件时保持网络畅通，避免插件由于网络原因奔溃 Emmet（原名 Zen Coding） 一种快速编写html/css的方法。 安装Emmet的同时，也会自动安装其依赖PyV8 binary库，安装PyV8库会用较长时间，可以在Sublime左下角看到安装进程状态。 html5 支持hmtl5规范的插件包。 使用方法：新建html文档 -> ! -> 敲击Tab键 -> 自动补全html5规范文档。 javascript-API-Completions 支持Javascript、JQuery、Twitter Bootstrap框架、HTML5标签属性提示的插件，是少数支持sublime text 3的后缀提示的插件，HTML5标签提示sublime text 3自带，不过JQuery提示还是很有用处的，也可设置要提示的语言。 JSFormat JS代码格式化插件。 使用方法：使用快捷键ctrl+alt+f SublimeLinter 一个支持lint语法的插件，可以高亮linter认为有错误的代码行，也支持高亮一些特别的注释，比如“TODO”，这样就可以被快速定位。（IntelliJ IDEA的TODO功能很赞，这个插件虽然比不上，但是也够用了吧） BracketHighlighter 类似于代码匹配，可以匹配括号，引号等符号内的范围。 使用方法：系统默认为白色高亮，可以使用链接所述方法进行自定义配置 Alignment 代码对齐，如写几个变量，选中这几行，Ctrl+Alt+A，哇，齐了。 Ctags 函数跳转，我的电脑上是Alt+点击 函数名称，会跳转到相应的函数 DocBlockr 注释插件，生成幽美的注释。标准的注释，包括函数名、参数、返回值等，并以多行显示，省去手动编写。 SideBarEnhancements 侧栏右键功能增强，非常实用 DocBlockr 支持对函数、变量的快捷注释 FileHeader 新建文件时，增加文件头注释 常见问题 设置默认浏览器和快捷键 安装插件 SideBarEnhancements 选择浏览器打开 html：在左侧栏中，右键 html 文件，单击右键菜单栏中 Open In Browser，选择浏览器 设置默认浏览器和快捷键：preferences -> Package Settings -> Side Bar -> Setting User，添加设置： [ { \"keys\":[\"f10\"], \"command\":\"side_bar_files_open_with\", \"args\":{ \"paths\":[], \"application\":\"C:/Users/lizhao/AppData/Local/Google/Chrome/Application/chrome.exe\", \"extensions\":\".*\" } } ] © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-11 21:15:33 "},"tech/05-Charles安装及使用.html":{"url":"tech/05-Charles安装及使用.html","title":"Charles安装及使用","keywords":"","body":"Charles安装及使用 Charles 是macOS 上的最常用的抓包工具。 抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 Charles 主要的功能 截取 Http 和 Https 网络封包。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟慢速网络，主要是模仿手机上的2G/3G/4G的访问流程。 支持本地映射和远程映射。比如你可以把线上资源映射到本地某个文件夹下，这样可以方面的处理一些特殊情况下的 bug 和线上调试（网络的css，js等资源用的是本地代码，这些你可以本地随便修改，数据之类的都是线上的环境，方面在线调试）； 可以抓手机端访问的资源（如果是配置HOST的环境，手机可以借用 host 配置进入测试环境） 支持SSL代理。可以截取分析SSL的请求。 支持端口映射。 支持反向代理。 支持SOCKS Charles的安装 安装 JDK。Charles由Java开发，需要先安装好 JDK。?? 查看是否安装：命令提示符中，输入java -version 查看安装路径：命令提示符中，输入 java -verbose 安装Charles：下载安装包 -> 安装。 破解：Charles 是付费软件，网上也有破解版下载。也可以用网上热心网友提供的信息完成注册：Help -> registered Registered Name: https://zhile.io License Key: 48891cf209c6d32bf4 设置系统代理 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用 Charles 的第一步是将其设置成系统的代理服务器。启动软件，设置步骤如下： window：proxy -> WindowsProxy mac：proxy -> macOS Proxy 代理服务器设置： proxy -> Proxy Settings，设置端口等参数，端口一般默认 8888。 proxy -> Enable transparent HTTP proxying，允许代理 HTTP 请求。 proxy -> SSL Proxying Settings，设置允许抓取 https 请求。 勾选 Enable SSL Proxying，添加一条 Location规则： 此后，就可以看见源源不绝的网络请求出现在Charles的界面中。 需要注意的是：Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成系统的代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。 Window（10）：启动chrome -> 右上角竖排的三个。。。 -> 设置 -> 系统 -> 打开您计算机的代理设置，或者 windows开始 -> 设置 -> 网络和internet -> 代理。 Mac：启动chrome -> 右上角竖排的三个。。。 -> 设置 -> 系统 -> 打开您计算机的代理设置 或者 系统偏好设置 -> 网络偏好设置 -> 高级 -> 代理。将网页代理(HTTP) 和 安全网页代理(HTTPS) 的网页代理服务器的IP和端口设置与Charles 一致，如：127.0.0.1 、8888。 设置移动端代理 首先，手机和电脑要使用同一wifi，然后再配置移动端设备的代理服务器信息。 以 iPhone 为例：设置 -> 无线局域网 -> 当前连接的 wifi 名 -> 右边的详情键，将最底部的【代理】一项，切换成【手动】，然后填上 Charles 运行所在的电脑的 IP 和 端口号： 主机名：查看help -> Local IP Addresses 端口：查看Proxy -> Proxy Settings 安装证书。具体可查看下文【移动端证书安装】 打开任意需要网络通讯的程序，可以看到 Charles 弹出请求连接的确认菜单。点击 “Allow” 即可完成设置。 系统证书安装 安装证书：help -> SSL Proxying -> Install Charles Root Certificate。 即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息。如果你想对截取某个网站上的所有 Https 网络请求，可以在该请求上右击，选择 SSL proxy。 设置了 SSL proxy，Chrome 浏览器访问 https 地址，提示隐私设置错误，出现“您的连接不是私密连接”： 原因： Charles 安装的证书，没有添加到受信任根证书列表中。 解决： 重新安装证书，并将证书添加到受信任根证书列表中，操作：Help -> SSL Proxying -> install charles root certificate。在安装过程中，需要指定证书的存放位置。 浏览器证书安装 chrome 访问网站，抓取的数据，可能会出现 ，原因是浏览器没有安装证书，无法抓取 https 请求。 安装过程如下： 安装证书：Help -> SSL Proxying -> Install Charles Root Certificate on a Mobile Device or Remote Browser，会有如下提示： 根据提示，在浏览器地址栏输入 chls.pro/ssl 下载证书。 在浏览器上安装证书，以 chrome 为例。在浏览器中输入：chrome://settings，访问 隐藏设置和安全性 -> 更多 -> 管理证书 如果证书安装后，还是会出现 ，可能是浏览器没有信任某种请求方式。比如：methods: connect。 移动端证书安装 IOS客户端 打开Charles，选择help→SSL Proxying→Install Charles Root Certificate on a Mobile Device or Remote Browser 移动端设备设备好代理后，打开safari，访问 chls.pro/ssl 下载证书。如果无法访问 chls.pro/ssl，尝试用 http://chls.pro/ssl 或 https://chls.pro/ssl。 证书下载下来是一个*.pem的文件，我们需要重命名为*.crt文件，不然无法安装。有的浏览器直接下载下来就是*.crt 文件，看运气。 点击文件安装证书。手机弹出提示：此网站正尝试打开“设置”已向您显示一个配置描述文件。您要允许吗？忽略|允许，选择允许，安装描述文件，并信任 iOS10.3以上的手机需要在：设置→ 通用 → 关于本机 → 证书信任设置→ charles proxy CA证书，打开信任即可 Android客户端 Android机，可能无法自动安装，可以手动安装。安卓手机类型众多，所以有些不太一样。 以oppo R11为列：设置 -> 其他设置 -> 安全与隐私 -> 从存储设备安装证书，找到下载好的证书文件。 方法一： 打开Charles，选择help→SSL Proxying→Install Charles Root Certificate on a Mobile Device or Remote Browser 设置手机代理，打开浏览器，输入网址：chls.pro/ssl 手机弹出提示：安装配置描述文件。您要允许吗？忽略|允许，选择允许，即可 方法二： 打开Charles，选择help -> SSL Proxying -> Save Charles Certificate，将证书导入到手机中 导入后直接点击安装证书即可 如果提示无法打开，需要进入手机设置 -> 更多设置 -> 系统安全 -> 从存储设备安装 -> 选择charles.pem，点击高级，安装证书即可。 Charles使用 过滤网络请求 对网络请求进行过滤，有以下几种办法： 方法一：在主界面的中部的 Filter栏中填入需要过滤出来的关键字。适用临时性的封包过滤。 方法二：在 Charles 的菜单栏选择Proxy -> Recording Settings，然后选择 Include栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。适用经常性的封包过滤。 方法三：在想过滤的网络请求上右击，选择 Focus。这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。 模拟慢速网络 在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。 在 Charles 的菜单上，选择 Proxy -> Throttle Setting 项，在之后弹出的对话框中，我们可以勾选上 Enable Throttling ，并且可以设置 Throttle Preset的类型。 如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 Only for selected hosts 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。 修改网络请求内容 有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 Edit，即可创建一个可编辑的网络请求。 可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 Execute即可发送该修改后的网络请求。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如图： 给服务器做压力测试 我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力。 我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项，如下所示： 接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。 悄悄说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。 有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。 根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是： Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。 Rewrite 功能适合对网络请求进行一些正则替换。 Breakpoints 功能适合做一些临时性的修改。 Map 功能 Charles 的 Map 功能分 Map Remote 和Map Local两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。 Map Remote 在 Charles 的菜单中，选择 Tools -> Map Remote 即可进入到相应功能的设置页面。 对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。如：可将所有 192.168.188.98:9600（本地服务器）的请求重定向到了 192.168.190.47（其他服务器）。 Map remote可解决跨域问题。 使用localhost接口，不会被拦截，可改用192.168.xxx.xxx 如果是通过cookie 中的token判断登录，需要手动在cookie中设置token Map Local 在 Charles 的菜单中，选择 Tools -> Map Local即可进入到相应功能的设置页面。 对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的Save Response… 功能，将请求结果保存到本地，然后稍加修改，成为我们的目标映射文件。 将一个指定的网络请求通过 Map Local 功能映射到了本地的一个经过修改的文件中。如图： 实际应用：调试线上bug。线上数据导致报错，测试环境或本地无法重现，而线上的js是压缩过的，debug比较困难。这时候，可以访问线上出错的页面，然后将js、css文件重定向到本地文件。 Map Local 在使用的时候，有一个潜在的问题，就是其返回的 Http Response Header 与正常的请求并不一样。这个时候如果客户端校验了Http Response Header中的部分内容，就会使得该功能失效。解决办法是同时使用 Map Local 以下面提到的 Rewrite 功能，将相关的 Http 头 Rewrite 成我们希望的内容。 Rewrite 功能 Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。 Breakpoints 功能 上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。 Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。 在 proxy -> Breakpoint Settings ，完成配置。接口调用会进入暂停状态，可以修改请求信息，完成后点击 Execute则可以让网络请求继续进行。 注意：使用 Breakpoints 功能将网络请求截获并修改过程中，整个网络请求的计时并不会暂停，所以长时间的暂停可能导致客户端的请求超时。 正向代理和反向代理 正向代理 用户想从服务器拿资源数据，但是只能通过proxy服务器才能拿到，所以用户A只能去访问proxy服务器然后通过proxy服务器去服务器B拿数据，这种情况用户是明确知道你要访问的是谁。 最典型的案例是翻墙 反向代理 其实就是客户端去访问服务器时，他并不知道会访问哪一台，感觉就是客户端访问了Proxy一样，而实则就是当proxy关口拿到用户请求的时候会转发到代理服务器中的随机（算法）某一台。而在用户看来，他只是访问了Proxy服务器而已。 典型的例子就是负载均衡 反向代理配置 Charles 的反向代理功能允许我们将本地的端口映射到远程的另一个端口上，在 proxy -> reverse proxies。例如，在下图中，我将本机的 9800 端口映射到了远程9600端口上了。 设置外部代理，解决与翻墙软件的冲突 shadowsocks 类的代理软件，会对 charles 造成影响。 Charles 的原理是把自己设置成系统的代理服务器，但是在中国，由于工作需要，我们常常需要使用 Google 搜索，所以大部分程序员都有自己的翻墙软件，而这些软件的基本原理，也是把自己设置成系统的代理服务器，来做到透明的翻墙。 为了使得两者能够和平共处，我们可以在 Charles 的 External Proxy Settings 中，设置翻墙的代理端口以及相关信息。同时，我们也要关闭相关翻墙软件的自动设置，使其不主动修改系统代理，避免 Charles 失效。 常见问题 https链接无法访问 没有开启 SSL Proxying Setting -> enable SSL Proxying，或者其中的 location 规则没加 系统证书没有安装到根证书信任列表中。 解决方法，可以查看上文【系统证书安装】。 抓包数据中，出现 证书没有安装，或者证书没有添加到信任列表中。 解决方法，查看 【浏览器证书安装】、【移动端证书安装】。 参考资料 Charles安装与使用 踩坑记：Charles 打不开 HTTPS ，显示您的连接不是私密连接 Charles问题之Windows10下抓取https包，出现unknown © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:16:35 "},"tools/Git/":{"url":"tools/Git/","title":"Git","keywords":"","body":"README Git © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-16 00:44:13 "},"tools/Git/01-Git安装、使用及常用命令.html":{"url":"tools/Git/01-Git安装、使用及常用命令.html","title":"Git安装、使用及常用命令","keywords":"","body":"Git安装、使用及常用命令 Git是什么？ Git是一个分布式版本管理系统，是为了更好地管理Linux内核开发而创立的。 Git可以在任何时间点，把文档的状态作为更新记录保存起来。因此可以把编辑过的文档复原到以前的状态，也可以显示编辑前后的内容差异。 而且，编辑旧文件后，试图覆盖较新的文件的时候（即上传文件到服务器时），系统会发出警告，因此可以避免在无意中覆盖了他人的编辑内容。 Git安装 可以网上搜索\"git\"下载安装。下载git windows版 git init 如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。 如果你还没这样做过，那么不同系统上的做法有些不同： 在 Linux 上：$ cd /home/user/my_project； 在 macOS 上：$ cd /Users/user/my_project； 在 Windows 上：$ cd /c/user/my_project。 git init命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 git clone 执行如下命令以创建一个本地仓库的克隆版本： git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： $ git clone [url,如https://github.com/1927344728/xxxx] $ git clone [url,如https://github.com/1927344728/xxxx] [myDirectory] //自定义本地仓库的名字 这会在当前目录下创建一个名为 “xxxx” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 git@github.com:1927344728/xxxx 。 git clone特别慢是因为github.global.ssl.fastly.net域名被限制了。git clone速度太慢的解决办法 开始 clone，如果仓库太大，可以在 git clone 中加入参数 --depth=1，只拉取最近的一个 revision。 git clone --depth=1 https://github.com/xxxx/xxxx.git 如果后面想看历史的版本，那么也很好办，使用 git fetch 即可。 git fetch --unshallow 对于远程私有项目，需要输入账号和密码。为了避免每次下载和上传都输入，可以使用ssh协议。 git add 暂存一个文件: git add -N filename.x 暂存一个文件的一部分: git add --patch filename.x。 git commit 暂存的内容添加到上一次的commit: git commit --amend -m \"\" 合并多个分支： git reset --soft master git commit -am \"新提交信息\" 或者 //交互式rebase git rebase -i / 编辑和删队已提交分支： 从一个提交(commit)里移除一个文件： git checkout HEAD^ myfile git add -A git commit --amend 删除最后一次提交(commit)： git reset HEAD^ --hard git push -f [remote] [branch] 如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做 git diff git diff [上一分支]..[当前分支] -- . ':![排除的文件夹]' git log 查看commit信息。 推荐：git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit --date=relative 别名：git config --global alias.lg \"log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit --date=relative\" //一行情书版 git log --oneline 图文并茂版 这次命令使用三个参数 --oneline， --decorate 和 --graph 。 –oneline 刚才就是哪个一句话情书的。 –graph 选项会绘制一个 ASCII 图像来展示提交历史的分支结构。 –decorate 是用来可以显示出指向提交的指针的名字，也就是 HEAD 指针, feature/test等分支名称，还有远程分支，标签等 //展示前n条数据 git log -n //展示简要的每次提交行数的变化，及其他基本信息。 git log –stat //展示每次提交详细的代码变化 git log -p //按提交的创建者分类 git shortlog git log –pretty=format:\"\" git log --pretty=format:\"%h %s\" #个人log配置个性化输出命令 git log --pretty=format:\"%H %cd *%an*:%s(%ar)\" --graph 展示历史最后2次提交的commit id 和 提交注释信息 git log -2 --pretty=format:\"%h - %ad, %ar : %s\" %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 //搜索参数为提交的创建者和提交者，而且是支持正则表达式的，可以发挥的余地很多 git log --author= git log --committer= //示例 git log --author=lizh //关于按时间搜索。格式：2020.3.1、2020.03.01 git log --since= git log --after= git log --until= git log --before= //示例 git log --since=\"2020.03.01\" --until=\"2020.03.05\" //搜索提交信息,也支持正常表达式 git log --grep= //示例。 git log --grep=\"aaa\\|bbb\" //提交信息包含aaa或bbb //搜索修改具体文件 git log [\\--] //示例 git log src/aaa/bbb.vue git log -- src/aaa/bbb.vue //查看某个字符串/正则表达式的变动历史提交 git log -S git log -G //示例 git log -S 'aa' git log -G '^aa' //选择只看合并提交，或者非合并提交 git log --merges git log --no-merges git reflog 可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录，而且跟进结果可以回退道某一个修改。 git stash git stash //暂存所有改动 git stash -u //暂存所有改动，-u来排队一些文件 git stash push file.js, file2.js //暂存提定文件 git stash save //暂存时记录消息 git stash push -m //暂存时记录消息 git stash list //暂存stash记录 $ git stash apply \"stash@{n}\" //使用某个记录 git stash pop //显示暂存内容，并删队暂存记录 git checkout 未暂存的内容移动到一个新分支: git checkout -b my-branch git reset 和 git revert git reset，直接删除指定的commit，不保留痕迹 返回上一commit: git reset HEAD^ 重置某一文件：git reset filename --soft 回退后修改的代码被保留并标记为add的状态（git status 是绿色的状态） --mixed 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作。 --hard 重置索引和工作树，并且分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。 --merge 和--hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】 --keep 和--hard类似，执行reset之前改动文件如果是分支修改了的，会提示你修改了相同的文件，不能合并。如果不是分支修改的文件，会移除缓存区。 git revert , 是用一次新的commit来回滚之前的commit 组合多个提交： 假设你的工作分支将会做对于 master 的pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 所有 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后: git reset --soft master git commit -am \"New awesome feature\" 如果你想要更多的控制, 想要保留时间戳, 你需要做交互式rebase (interactive rebase): git rebase -i master 如果没有相对的其它分支， 你将不得不相对自己的HEAD 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于HEAD~2 进行rebase， 组合最近3次提交(commit), 相对于HEAD~3, 等等。 git rebase -i HEAD~2 安全合并(merging)策略 git merge --no-ff --no-commit my-branch 将一个分支合并成一个提交(commit) git merge --squash my-branch 检查是否分支上的所有提交(commit)都合并(merge)过了 git log --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll 或者 git log master ^feature/120-on-scroll --no-merges 远程仓库命令 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 点击查看创建本地Git仓库和远程Git仓库，本文只记录常用命令 现在把本地仓库和远程仓库关联起来： git remote add origin git@git.winbaoxian.com:lizhao/gitbook.git 远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 删除远程仓库：git remote rm origin 远程仓库是否连接： ssh -T git@git.winbaoxian.com 是否创建了公有密钥：ls ~/.ssh 生成密钥：ssh-keygen -t rsa -f ~/.ssh/ellacf -C \"邮箱\" -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。 配置信息 检查已有的配置信息: git config --list 修改信息：git config --global user.name 分支管理 关联远程分支： git branch --set-upstream-to=origin/master master 关联远程分支：git push -u origin master 我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 创建并关联远程：git checkout -b [branch] origin/[branch] 删除远程分支：git push origin --delete 删除本地分支：git branch -D 本地创建远程追踪分支：git remote update 删除本地中那些失效的远程追踪分支：git remote prune origin npm install报错 npm cache clean --force 文件管理删除 删除未跟踪文件：git clean -f 删除未跟踪文件及目录：git clean -fd 删除未跟踪文件及目录( gitignore里的也一起删掉)：git clean -xfd git clean -nxfd、git clean -nf、git clean -nfd 。加上 -n 参数来先看看会删掉哪些文件 alias 配置文件 Bash：其配置文件可能是 /etc/bashrc、~/bash_profile 或者 /etc/profile ~/.gitconfig zsh: ~/.zshrc、~/.oh-my-zsh/plugins/git/git.plugin.zsh .gitignore文件 在Git工作区的根目录下创建.gitignore文件，然后把要忽略的文件夹/文件名填进去。这样当你使用git add .的时候这些文件就会被自动忽略掉。 # general *~ *.log tmp dump **/.DS_Store .svn/ .idea/ .metadata/ .project Thumbs.db *.iml #node **/node_modules/ #bower **/bower_components _book #sublime project config file **/*.sublime-project **/*.sublime-workspace 推荐链接 git - 简明指南（入门推荐） Git教程- 廖雪峰的官方网站 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-07-25 19:11:14 "},"tools/Git/02-git-clone速度太慢的解决办法.html":{"url":"tools/Git/02-git-clone速度太慢的解决办法.html","title":"Git Clone速度太慢的解决办法","keywords":"","body":"git clone速度太慢的解决办法 git clone或者git push特别慢，并不是因为 http://github.com 的这个域名被限制了。而是 http://github.global.ssl.fastly.Net 这个域名被限制了。 解决方法如下： hosts文件绑定映射(亲测有效) 最初用户从浏览器中输入 github.com 网址时，浏览器并不知道这个域名对应的真实 ip 地址，先问问自己电脑认识不认识这个域名的门牌号，如果本机不认识会接着往上问，当地运行商也不认识这个域名的话，继续问上级，直到问出来 github.com 的门牌号是 140.82.113.4 为止! 如此繁琐的问路过程被称之为 DNS 寻址，如果问路的时间都占用很久，那么访问网站的速度自然会很慢。 所以，如果我们直接告诉浏览器目的地，那么浏览器也就不会一步一步去费劲问路了，这在一定程度上也就优化了访问网站的速度。 获取IP 提供两个查询域名解析的网站： https://www.ipaddress.com/ http://tool.chinaz.com/dns/ github.global.ssl.fastly.net github.com 就近CDN加速 大型网站服务器都不会是只有一台服务器，而是多台服务器组成的集群一起对外提供服务。 全世界都在使用 github ，如果每一次访问网站时走的都是美国服务器，即使浏览器知道目的地，但是距离太多遥远还是会很慢。 因此，如果能够就近访问 github 网站就能大幅提高访问速度了，幸运的是，网络上同样有现成的工具来帮助我们查看就近的网站地址。http://tool.chinaz.com/dns/ 修改hosts文件 Windows上的hosts文件路径在C:\\Windows\\System32\\drivers\\etc\\hosts Linux的hosts文件路径在：sudo vim /etc/hosts 在hosts文件末尾添加两行(对应上面查到的ip) 199.232.69.194 github.global.ssl.fastly.net 140.82.113.4 github.com 保存更新DNS Winodws：打开CMD，输入ipconfig /flushdns（刷新）、ipconfig /displaydns（查看） Linux：在终端输入sudo /etc/init.d/networking restart 通过修改本机的 hosts 文件来绕过 dns 解析，这种方法仅仅适用于能够访问网站只不过是访问速度慢这一现象。 hosts文件用记事本打开，一般需要管理员权限才能修改；可以将hosts文件复制出来，修改完成后，再替换到etc文件夹中；也可以修改hosts的权限：右键hosts–>属性–>安全->编辑，添加【写入】权限。 需要打开shadowsock等代理软件。原速度：10Kib/s左右，设置后100Kib/s以上 设置Git http[s].proxy 打开SS代理(Shadowsocks) 设置全局代理 git config --global http.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 ##请注意：需要查看自己的端口是不是也是1080，可以打开你的SS查看代理设置## 输入git clone https://github.com/xxxx/xxxx.git，利用代理进行下载。 请注意，这里指的是https协议，也就是git clone https://www.github.com/xxxx/xxxx.git, 对于SSH协议git clone git@github.com:xxxx/xxxx.git依旧是无效的 不推荐直接用全局代理 因为如果挂了全局代理，这样如果需要克隆coding之类的国内仓库，会奇慢无比。建议使用这条命令，只对github进行代理，对国内的仓库不影响 git config --global http.https://github.com.proxy https://127.0.0.1:1080 git config --global https.https://github.com.proxy https://127.0.0.1:1080 同时，如果在输入这条命令之前，已经输入全局代理的话，可以输入进行取消 git config --global --unset http.proxy git config --global --unset https.proxy 通过【码云】等国内代码管理网站导入 注册【码云】 通过【码云】【从github导入已有项目】 git clone【码云】中的项目 重置本地接收缓存 git config --global http.postBuffer 524288000 git 文档中已有对该字段的说明，大意是：HTTP/1.1 协议的 transfer-encoding:chunked 头会将数据切块传输，每块数据一般默认不超过 1MB。通过 http.postBuffer 可以重置本地接收缓存的大小，也即每块数据的尺寸上限。一般不推荐将这个值设置太大，因为这会显著地提高内存的消耗量。 官方文档警告不要将该值设置太大。把缓存区设定成了 524288000 bytes（500MB）。这意味着，即使是 clone 一个 50 MB的小项目，在数据传输完之前，git 也会在内存开辟一个 500MB 的缓冲区。不是经常 clone项目还好，否则对内存相当不友好。建议可以改小些，譬如 10MB(10485760)，即提升了速度，也没有造成太大的浪费。 git config --global http.postBuffer 10485760 代理Git -> connect.exe 找到 .ssh 文件夹 比如 C:\\Users\\[用户名]\\.ssh ，在里面新建一个空白文件，取名 config。注意不是 config.txt ！ 修改 config 文件 在 config 文件里写上一行： ProxyCommand \"C:\\Program Files\\Git\\mingw64\\bin\\connect.exe\" -S 127.0.0.1:1080 %h %p 这里 git 的安装路径和后面的代理自己看着填，不要试着用相对路径，保证要吃亏。因为 Program Files 文件夹中间带一个空格，所以这里需要把整个路径给引号引起来。 后面的代理的话，-S 指是 socks 代理，默认是 socks5，后面的 %h %p 意思是 Host 和 Port，必须得写上，我也不知道为什么要这么设计。 如果要使用 HTTP 代理，就写 -H，更多代理类型（比如 socks4）请参这个。 以上写法是针对全局的，如果想只针对某个网站的话，就这么写： Host github.com ProxyCommand \"C:\\Program Files\\Git\\mingw64\\bin\\connect.exe\" -S 127.0.0.1:1080 %h %p Host gitlab.com ProxyCommand \"C:\\Program Files\\Git\\mingw64\\bin\\connect.exe\" -S 127.0.0.1:1080 %h %p 补充一点Windows上用connect.exe的坑。 此程序必须写完整路径，即使在Path里也不可以只写connect.exe。这是个BUG，在 ProxyCommand incorrectly requires an absolute path · Issue #1185 · PowerShell/Win32-OpenSSH 中已经被修了。 使用-H可不用输入密码。 在程序路径两边加上引号：ProxyCommand \"c:\\tools\\connect.exe\" -H 127.0.0.1:1080 %h %p，git clone/pull/push等是能生效的，但ssh -T git@github.com会报： CreateProcessW failed error:87 posix_spawn: Unknown error 必须去掉引号：ProxyCommand c:\\tools\\connect.exe -H 127.0.0.1:1080 %h %p。这样ssh -T，以及一般的ssh连接，包括VSC的Remote - SSH才会成功。而git命令却会失败： /bin/sh: line 0: exec: c:toolsconnect.exe: not found ssh_exchange_identification: Connection closed by remote host fatal: Could not read from remote repository. Please make sure you have the correct access rights 看信息是反斜杠都没了，所以应用斜杠，引号仍不能加： Host github.com Ciphers aes128-gcm@openssh.com ProxyCommand c:/tools/connect.exe -H 127.0.0.1:1080 %h %p 使用github的镜像 (亲测有效) git clone https://github.com/xxxx/xxxx.git 替换成git clone https://github.com.cnpmjs.org/xxxx/xxxx.git 亲测：替换前大约10KiB/s，替换后大约500~800KiB/s。 第一次clone要登录，使用github.com的账号密码即可。 参考链接： 加快git clone 几十倍速度的小方法 （30KB vs 2M） https://www.zhihu.com/question/27159393 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:09:43 "},"tools/Git/03-Git常见问题.html":{"url":"tools/Git/03-Git常见问题.html","title":"Git常见问题","keywords":"","body":"Git常见问题 Git Bash中文乱码 Git status不能显示中文 git status 查看有改动但未提交的文件时总只显示数字串(八进制的字符编码)，显示不出中文文件名。 修改git 配置文件： 编辑 %GIT_HOME%\\etc\\gitconfig 文件，也有些 windows 系统是存放在C:\\Users\\Administrator\\.gitconfig路径或安装盘符:\\Git\\mingw64\\etc\\gitconfig，在文件末尾增加以下内容： [core] quotepath = false # status引用路径不再是八进制（反过来说就是允许显示中文了） 命令行执行： git bash 终端输入命令：git config --global core.quotepath false Git log出现乱码 修改 git 配置文件： 编辑 %GIT_HOME%\\etc\\gitconfig 文件，也有些 windows 系统是存放在C:\\Users\\Administrator\\.gitconfig 路径或 安装盘符:\\Git\\mingw64\\etc\\gitconfig，在文件末尾增加以下内容： [gui] encoding = utf-8 # 代码库统一使用utf-8 [i18n] commitencoding = utf-8 # log编码 [svn] pathnameencoding = utf-8 # 支持中文路径 修改 %GIT_HOME%\\etc\\profile 文件，加入如下内容： export LESSCHARSET=utf-8 # 注意：一般来说export LESSCHARSET的值就是utf-8,如果profile文件中没有这一项，请加入。 命令行执行 git config --global gui.encoding utf-8 git config --global i18n.commitencoding utf-8 git config --global i18n.logoutputencoding gbk，在 /etc/profile 中添加：export LESSCHARSET=utf-8 vi/vim查看有中文的文件乱码 修改 %GIT_HOME%\\share\\vim\\vimrc 文件,在文件末尾加入如下内容: set fileencodings=utf-8,ucs-bom,cp936,big5 set fileencoding=utf-8 set termencoding=gbk 输入中文后出现乱码 修改 %GIT_HOME%\\etc\\inputrc 文件，加入： set output-meta on set convert-meta off git bash中使用ls命令乱码 在 git bash 中使用 ls 命令的时候，如果目录和文件带有中文，则会出现乱码，编辑 etc\\git-completion.bash 文件，在文件末尾增加以下内容： #让ls命令能够正常显示中文 alias ls='ls --show-control-chars --color=auto' ipconfig、systeminfo乱码 这是因为命令行的解释说明的中文字符使用的是GBK码，当前的 git bash text 设置是默认的 utf-8 码。 解决：打开 GitBash（git-bash.exe），对窗口 右键 -> Options -> Text -> Locale 改为 zh_CN，Character set 改为 GBK ；键入exit 退出关闭再重新打开。 在 GBK 基础上使用 ls 命令行，发现中文文件夹名有乱码，是由于系统命名文件夹时使用的是 utf-8。 解决：按上面流程，改成utf-8 由于这种随时因各对象字符编码不同造成的乱码，只能使用时自行在option中更改编码类型 github SSH SSH是 Secure Shell 的缩写，是一个应用层的加密网络协议，它不只可以用于远程登录、远程命令执行，还可用于数据传输。当然它由 ssh Client 和 ssh Server 端组成，有很多实现，Ubuntu 上就默认安装的 OpenSSH， Client 端叫做 ssh， Server 端叫做sshd。OpenSSH 只用来做远程登录和命令执行。 使用SSH协议可以连接远程服务器和服务并向它们验证。 利用 SSH密钥可以连接 GitHub，而无需在每次访问时提供用户名或密码。 以下命行中 Git Bash 中执行： 检查现有 SSH 密钥 输入 ls -al ~/.ssh 以查看是否存在现有 SSH 密钥： $ ls -al ~/.ssh # 列出 .ssh 目录中的文件（如果有） 检查目录列表以查看是否已经有 SSH 公钥。 默认情况下，公钥的文件名是以下之一：id_rsa.pub、id_ecdsa.pub、id_ed25519.pub 生成新 SSH 密钥 粘贴下面的文本（替换为您的 GitHub 电子邮件地址）。 $ ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 这将创建以所提供的电子邮件地址为标签的新 SSH 密钥。 提示您“Enter a file in which to save the key（输入要保存密钥的文件）”时，按 Enter 键。 这将接受默认文件位置。 在提示时输入安全密码（可以为空，直接【enter】）。 将 SSH 密钥添加到 ssh-agent 如果已安装 GitHub Desktop，可使用它克隆仓库，而无需处理 SSH 密钥。 它还附带 Git Bash 工具，这是在 Windows 上运行 git 命令的首选方法。 确保 ssh-agent 正在运行： 如果您使用随 GitHub Desktop 一起安装的 Git Shell，则 ssh-agent 应该正在运行。 如果您使用的是其他终端提示符，例如 Git for Windows，您可以根据“使用 SSH 密钥密码”中的“自动启动 ssh-agent”说明进行操作，或者手动启动它： # 在后台启动 ssh-agent $ eval $(ssh-agent -s) > Agent pid 59566 将 SSH 私钥添加到 ssh-agent。 如果您创建了不同名称的密钥，或者您要添加不同名称的现有密钥，请将命令中的 id_rsa 替换为您的私钥文件的名称。 $ ssh-add ~/.ssh/id_rsa 将 SSH 密钥添加到 GitHub 帐户。 新增 SSH 密钥到 GitHub 帐户 将 SSH 密钥复制到剪贴板。在复制密钥时，请勿添加任何新行或空格。 $ pbcopy 在github.com中：个人资料 -> Settings（设置） -> SSH and GPG keys（SSH 和 GPG 密钥） -> New SSH key（新 SSH 密钥）或 Add SSH key（添加 SSH 密钥）。 在 \"Title\"（标题）字段中，为新密钥添加描述性标签。将密钥粘贴到 \"Key\"（密钥）字段。单击 Add SSH key（添加 SSH 密钥）。 如有提示，请确认您的 GitHub 密码。 测试 SSH 连接 打开 Terminal（终端）Terminal（终端）Git Bash。 输入以下内容： $ ssh -T git@github.com # 对 GitHub 尝试 ssh 您可能会看到类似如下的警告： > The authenticity of host 'github.com (IP ADDRESS)' can't be established. > RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. > Are you sure you want to continue connecting (yes/no)? 或类似如下： > The authenticity of host 'github.com (IP ADDRESS)' can't be established. > RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. > Are you sure you want to continue connecting (yes/no)? 验证您看到的消息中的指纹匹配步骤 2 中的消息之一，然后输入 yes： > Hi username! You've successfully authenticated, but GitHub does not > provide shell access. 使用 SSH 密钥密码 您可以保护 SSH 密钥并配置身份验证代理，这样您就不必在每次使用 SSH 密钥时重新输入密码。 使用 SSH 密钥时，如果有人获得您计算机的访问权限，他们也可以使用该密钥访问每个系统。 要添加额外的安全层，可以向 SSH 密钥添加密码。 您可以使用 ssh-agent 安全地保存密码，从而不必重新输入。 添加或更改密码 通过输入以下命令，您可以更改现有私钥的密码而无需重新生成密钥对： $ ssh-keygen -p # Start the SSH key creation process > Enter file in which the key is (/Users/you/.ssh/id_rsa): [Hit enter] > Key has comment '/Users/you/.ssh/id_rsa' > Enter new passphrase (empty for no passphrase): [Type new passphrase] > Enter same passphrase again: [One more time for luck] > Your identification has been saved with the new passphrase. 如果您的密钥已有密码，系统将提示您输入该密码，然后才能更改为新密码。 git常见错误 qpacket_write_wait: Connection to 13.229.188.59 port 22: Broken pipe remote: Enumerating objects: 283, done. remote: Counting objects: 100% (283/283), done. remote: Compressing objects: 100% (18/18), done. qpacket_write_wait: Connection to 13.229.188.59 port 22: Broken pipe fatal: the remote end hung up unexpectedly fatal: early EOF fatal: index-pack failed 问题描述 git pull 或者 git push时，出现 packet_write_wait connection to xx.xx.xx.xx Broken pipe 错误。 这是超时或者 SSH 被强行中断引起的。 解决方法 可以通过配置，让SSH保持连接。可以在服务端配置，让 server 每隔30秒向 client 发送一个 keep-alive 包来保持连接。如果服务端没有权限配置，或者无法配置，可以配置客户端 ssh，使客户端发起的所有会话都保持连接。 客户端配置：在 ~/.ssh/config文件（若没有，就创建一个）中添加： Host * #让 server 每隔30秒向 client 发送一个 keep-alive 包来保持连接 ServerAliveInterval 60 #如果发送 keep-alive 包数量达到 60 次，客户端依然没有反应，则服务端 sshd 断开连接 ClientAliveCountMax 60 如果什么都不操作，该配置可以让连接保持 60s * 60 ， 60min。 LF will be replaced by CRLF CRLF, LF是用来表示文本换行的方式。CR(Carriage Return)代表回车，对应字符 '\\r'；LF(Line Feed)代表换行，对应字符 '\\n'。由于历史原因，不同的操作系统文本使用的换行符各不相同。主流的操作系统一般使用CRLF或者LF作为其文本的换行符。其中，Windows系统使用的是 CRLF，对应字符\\r\\n, Unix系统(包括Linux, MacOS近些年的版本) 使用的是LF。 git工作区默认为CRLF来作为换行符。如果项目文件里有用LF作为换行符，git add 或git commit的时候就会弹出警告，当最终push到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符。 解决方法 Git 提供了一个名为 core.autocrlf 的配置，可以自动完成标准化与转换。它的设置方式如下： git config --global core.autocrlf [true | input | false] # 全局设置 git config --local core.autocrlf [true | input | false] # 针对本项目设置 true 自动完成标准化与转换 input 只做标准化操作，不做转换操作 false 提交与检出的代码都保持文件原有的换行符不变 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-11 21:35:07 "},"tools/Gitbook/":{"url":"tools/Gitbook/","title":"Gitbook","keywords":"","body":"README Gitbook © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-16 00:44:23 "},"tools/Gitbook/01-gitbook入门篇.html":{"url":"tools/Gitbook/01-gitbook入门篇.html","title":"Gitbook入门篇","keywords":"","body":"Gitbook入门篇 什么是GitBook？ GitBook 是一个使用 Git 和 Markdown 来构建书籍的工具。它可以将你的书输出很多格式：PDF，ePub，mobi，或者输出为静态网页。 GitBook 是开源并且完全免费的，它的源码可以在 GitHub 上获取。与格式和工具链相关的问题被发表在 github.com/GitbookIO/gitbook/issues。 gitBook 是一个基于node.js的命令行工具，使用 github/git 和 markdown/asciiDoc 构建精美的电子书。它支持输出静态网页和电子书等多种格式,其中默认输出静态网页格式。 gitbook 不仅支持本地构建电子书,而且可以托管在 gitbook 官网上,并享受在线发布和托管图书的便利,完整的文档请参考 gitbook 新版文档(需FQ) 打开gitbook.com网站需要使用代理。如果还是打不开，请确定你的shadowSocks的PAC是最新的，因为老的PAC可能不包括这个网站。（被坑过） 开始之前，你需要的准备 知识准备 markdown 快速入门 git - 简明指南（入门推荐） 环境检测 检查 git：git --version 检查 node.js：node --version Markdown编辑器：方便本地开发，推荐Typora或gitbook自己的编辑器gitbook editor 最新注册的gitbook账号是无法使用 gitbook-editor 编辑器。 安装 安装：npm i -g gitbook-cli 检查 gitbook ：gitbook --version gitbook-cli 是 GitBook 的一个命令行工具。它将自动安装所需版本的 GitBook 来构建一本书。 注：不要运行npm i -g gitbook安装，如已安装，运行npm uni -g gitbook卸载，重装。 Gitbook命令 初始化 Gitbook 项目 gitbook init gitbook init会在空项目中创建README.md和SUMMARY.md两个文件：README.md文件是项目的介绍文件。 SUMMARY.md是gitbook书籍的目录。 初始化相应的文件目录结构，所以主要是用于开发初始阶段. 启动 Gitbook 项目 gitbook serve [--port 4000] 默认情况下服务器启动后会占用两个端口，一个是对外暴露的 4000 端口，用于浏览器访问项目。另外一个是 35729 端口，用于监听本地文件变化，重启服务器进而实现热加载功能。 本地服务器启动后我们就可以访问 http://localhost:4000 预览静态网站效果。由于能够实时预览电子书效果,并且大多数开发环境搭建在本地而不是远程服务器中，所以主要用于开发调试阶段。 构建 Gitbook 静态网页 gitbook build [entry] [--output] ## gitbook build ./ ./docs -o, --output 输出文件件, 默认为 ./_book -f, --format 产生的书籍的类型, 默认为静态站点, 可用的格式为: site, page, ebook, json --config 配置文件, 默认为 book.js 或 book.json 构建静态网页而不启动本地服务器，默认生成文件存放在 _book/ 目录。在_book文件夹里有一个index.html文件，这个文件就是文档网站的HTM入口，主要用于发布准备阶段。 输出静态网页后可打包上传到服务器，也可以上传到 github 等网站进行托管。 当然输出目录是可配置的,暂不涉及,见高级部分. 其他命令 #切换版本 gitbook [version] #列出当前已安装的版本 gitbook ls #则是列出远程服务器版本 gitbook ls-remote #更新版本 gitbook fetch [versiion] #更新到gitbook的最新版本 gitbook update #生成电子书 gitbook pdf ./ ./aaaa.pdf gitbook epub ./ ./aaaa.epub gitbook mobi ./ ./aaaa.mobi Gitbook配置文件 如果你想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。配置文件写完后，需要重启服务或者重新打包才能应用配置。 gitbook的配置文件名是book.json，首先在项目的根目录中创建book.json文件。book.json主要内容： { \"root\": \"/\", //指定存放 gitbook 文件(除了book.json文件本身)的根目录 \"gitbook\" : \"3.2.3\", //gitbook 版本 //\"title\": \"我的一本书\", //标题 \"page\": { \"title\": \"前端知识库(lizh)\" }, \"author\" : \"lizhao\", //作者 \"description\" : \"\", //描述 \"language\" : \"zh-hans\", //使用的语言，zh-hans是简体中文，会对应到页面的 \"variables\": { \"authorName\": \"lizhao\" }, //指定 Readme、Summary、Glossary 和 Languages 对应的文件名 \"structure\": { //readme: 'README.md', //Readme file name //summary: 'SUMMARY.md', //Summary file name //glossary: 'GLOSSARY.md', //词汇表文件[可选] //languages: 'LANGS.md' //语言文件[可选] }, //使用的插件列表，所有的插件都在这里写出来，然后使用gitbook install来安装 \"plugins\": [ //gitbook 默认自带5个插件 //\"highlight\", //语法高亮插件 //\"search\", //搜索插件 //\"sharing\", //分享插件 //\"font-settings\", //字体设置插件 //livereload\", //热加载插件 \"anchors\", \"expandable-chapters-small\", \"search-plus\", \"toggle-chapters\", \"summary\", \"splitter\", \"theme-comscore\", \"fontsettings\" //\"search-pro\", //高级搜索（支持中文） //\"back-to-top-button\", //chapter-fold, //支持多层目录，点击导航栏的标题名就可以实现折叠扩展。 //page-treeview, 在页面顶部显示目录 //-符号代表去除默认自带的插件 \"-lunr\", \"-search\" ], //插件的配置信息，如果插件需要配置参数，那么在这里填写 \"pluginsConfig\": { \"expandable-chapters-small\":{}, \"fontsettings\": { \"theme\": \"white\", \"family\": \"sans\", \"size\": 2 } }, //目前可以给侧导航栏添加链接信息 \"links\" : { \"sidebar\" : { } }, //自定义页面样式，各种格式对应各自的css文件 \"styles\": { //\"website\": \"styles/website.css\", //\"ebook\": \"styles/ebook.css\", //\"pdf\": \"styles/pdf.css\", //\"mobi\": \"styles/mobi.css\", //\"epub\": \"styles/epub.css\" } } gitbook.com 官网操作 gitbook 官网是官方提供的图书托管的在线平台，分为新版官网(需要FQ) https://www.gitbook.com/ 和旧版官网(无需FQ) https://legacy.gitbook.com 两个网站。 目前均正常提供服务，但令人遗憾的是，两个网站的信息相互独立，而且现在注册的账号默认只能在新版官网中使用，而新版官网的访问速度简直比 github 还要慢，所以国内用户在线访问你的电子书真的需要点技术手段了! 将 github 个人网站项目同步到 gitbook 电子书项目。这样的好处是本地只需要推送到 github ，自动更新 github.io 网站(利用的是github 静态网站托管服务)，然后再自动同步到 gitbook.io 网站。 操作流程如下： 注册并登陆 gitbook.com（需要使用代理） 新建命名空间(电子书) 域名&路径 默认域名是 https://[username].gitbook.io/，如果需要自定义域名，请保证 dns 能够正确解析到该网站。路径是spacename。比如：https://lizh.gitbook.io/knowledge/ 整合Github gitbook 默认提供4种整合方式：GitHub、Slack、Google Analytics、Intercom。 以为以 github 为例，其余三种没接触过，暂不涉及。 选择 github 进行整合 选择目标仓库 登录 github 并授权 -> 选择目标仓库 -> 选择同步分支 -> 选择同步内容。 导入成功 由于 gitbook 电子书内容来自于 github 项目，因此我们只要更新 github 仓库，我们的 gitbook 电子书网站自然也就相应更新了! 美中不足的是,国内无法正常访问 gitbook.com 。现在国内也有类似的产品,有一种产品叫做 看云，还不错! Gitbook插件 插件是 gitbook 的扩展功能，很多炫酷有用的功能都是通过插件完成的。其中插件有官方插件和第三方插件npm之分。根据 gitbook 插件规范, gitbook-plugin- 是功能插件,gitbook-theme- 是主体插件。 基本使用： 先安装到本地： npm install gitbook-plugin-（可略） 插件配置：在 book.json 中 plugins 节点 安装： gitbook install { \"plugins\": [ \"myPlugin\" ], \"pluginsConfig\": { \"myPlugin\": {} } } 常见问题 gitbook build 或 gitbook serve报错 gitbook: 3.2.3 node：v12.2.0 npm：6.9.0 Error: ENOENT: no such file or directory, stat 'xxxx\\_book\\gitbook\\gitbook-plugin-fontsettings\\fontsettings.js' 方法一：将C:\\Users\\[whoami]\\.gitbook\\versions\\3.2.3\\lib\\output\\website\\copyPluginAssets.js第112行confirm: true注释，或改成confirm: false 方法二：关闭杀毒软件 windows系统无法热加载，总是报错 Stopping server events.js:173 throw er; // Unhandled 'error' event ^ Error: EPERM: operation not permitted, lstat 'D:\\MyCode\\gitBook\\_book' Emitted 'error' event at: at FSWatcher._handleError (C:\\Users\\[whoami]\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\index.js:236:10) at ReaddirpReadable.emit (events.js:196:13) at Immediate. (C:\\Users\\[whoami]\\.gitbook\\versions\\3.2.3\\node_modules\\chokidar\\node_modules\\readdirp\\stream-api.js:82:32) at processImmediate (internal/timers.js:439:21) 控制台信息说是操作权限的问题。打开项目，当前项目已经没有 _book 目录，证明发生报错时确实已经删除了 _book 目录，但是某种原因无权再次创建该文件夹而重启失败。结论是 gitbook 是删除 _book 文件夹再新建 _book 文件夹时发生了意外。 解决方法：在启动本地服务器后立即删除 _book 目录，当本地文件发生修改时重启服务就能成功了。 这个官方已知的一个bug，且没有想修复的意思。~只能期待gitbook升级了~ 内容无法在gitbook.com显示 原因：文件夹名称有大写字母 ~题外话~ 搭建文档类站的工具，除了gitbook外，还有以下两种： Docsify docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。 这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件“污染” commit 记录，只需要创建一个 index.html 就可以开始写文档而且直接部署在 GitHub Pages。 插件方面，docsify插件不如Gitbook的丰富，但麻雀虽小五脏俱全，该有的基本也都有，足够使用。 对 SEO 不够友好，因为它是完全的运行时驱动的。 特性： 无需构建，写完文档直接发布 容易使用并且轻量 (压缩后 ~21kB) 智能的全文搜索 提供多套主题 丰富的 API 支持 Emoji 兼容 IE11 支持服务端渲染 SSR (示例) VuePress VuePress 由两部分组成：第一部分是一个极简静态网站生成器，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。 每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。 特性：) 内置的 Markdown 拓展 在 Markdown 中 使用 Vue Vue驱动的自定义主题系统 默认主题 ... 除此外，还有Docute、Hexo... 参数链接 雪之梦技术驿站 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:16:58 "},"tools/Gitbook/02-gitbook插件篇.html":{"url":"tools/Gitbook/02-gitbook插件篇.html","title":"Gitbook插件篇","keywords":"","body":"Gitbook插件篇 插件是 gitbook 的扩展功能，很多炫酷有用的功能都是通过插件完成的。其中插件有官方插件和第三方插件npm之分。根据 gitbook 插件规范, gitbook-plugin- 是功能插件,gitbook-theme- 是主体插件. 安装插件 先安装到本地 npm install gitbook-plugin-（可略） 配置：在 book.json 中 plugins 配置插件名称，pluginsConfig配置插件参数。 安装： gitbook install。 { \"plugins\": [ \"myPlugin\" ], \"pluginsConfig\": { \"myPlugin\": {} } } 一些有趣的插件 donate 打赏插件 文章最下面的按钮，点击可弹出图片 { \"plugins\": [ \"donate\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"微信收款的二维码URL\", \"alipay\": \"支付宝收款的二维码URL\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" } } } disqus 评论插件（需注册账号） discus 是一款集成评论的插件，可以为静态网站添加动态评论，让你的网站动起来! 遗憾的是，discus 插件只有 FQ 才能正常使用，暂时没找到其他较好的替代方案。 gitbook 集成 disqus 插件中最重要的配置项就是注册 disqus.com 网站唯一标识。 { \"plugins\": [\"disqus\"], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"snowdreams1006\" } } } gitalk 评论插件 上述 disqus 评论插件虽然比较好用，但是注册是在 disqus.com 官网，需要特殊手段才能访问，即便成功配置了国内一般也是访问不到的，因此功能相当鸡肋。 gitalk 评论插件解决了这一痛点，利用 github 的开发者接口授权，将讨论区的 issue 变成评论区，和 github 结合的如此紧密，适合用源码托管到 github 这类情况。 实出操作如下： 申请 GitHub Application 授权 登录 github 账号，点击 在线申请 授权应用。 新建应用，首页 url 和授权回调 url 填写相同的首页链接即可，其他情况自定义填写。 应用登记成功后会生成 token 令牌，clientId 和 clientSecret 需要重点保存下来，待会需要用到。 安装并集成到网站 在需要添加评论的页面，添加下述内容引入 gitalk 插件，其中参数来自我们上一步获取的 clientId 和 clientSecret 。 默认应该添加到 .html 页面，当然也可以添加到 .md 页面，毕竟 markdown 语法也支持 html 标签。 var gitalk = new Gitalk({ \"clientID\": \"clientId\", \"clientSecret\": \"clientSecret\", \"repo\": \"GitHub repo\", \"owner\": \"GitHub repo owner\", \"admin\": [\"GitHub repo admin\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); \"clientID\" : [必选] GitHub Application Client ID \"clientSecret\" : [必选] GitHub Application Client Secret \"repo\" : [必选] GitHub repository \"owner\" : [必选] GitHub repository 所有者，可以是个人或者组织 \"admin\" : [必选] GitHub repository 的所有者和合作者 (对这个 repository有写权限的用户) \"id\" : [可选] 页面的唯一标识,默认值: location.href, 长度必须小于50,否则会报错! \"distractionFreeMode\": [可选] 类似 Facebook 评论框的全屏遮罩效果,默认值: false 注意：必须推送到服务器。因为申请应用时填写的域名是线上地址，因而本地测试是不会成功的，会报错。 注意：需要管理员对 Issue 进行初始化创建。 遗憾的是：我们目前仅仅在首页(README.md) 集成了 gitalk 插件，也就是说使用 gitbook build 输出的 index.html 首页才支持评论区，其他页面没有插入上述代码，自然是没有评论区功能的啊！目前并没有找到优雅的解决方案。 解决思路：无非就是在js里面加一段Gitalk的调用代码，这样使用gitbook build命令的时候，所有的页面都会有Gitalk的评论调用。 mygitalk 评论插件 gitbook-plugin-mygitalk 是全网最早发布的基于 gitalk 实现评论插件,用于给 Gitbook 博客网站集成评论功能。 { \"plugins\" : [\"mygitalk\"], \"pluginsConfig\": { \"mygitalk\": { \"clientID\": \"GitHub Application Client ID\", \"clientSecret\": \"GitHub Application Client Secret\", \"repo\": \"GitHub repo\", \"owner\": \"GitHub repo owner\", \"admin\": [\"GitHub repo owner and collaborators, only these guys can initialize github issues\"], \"distractionFreeMode\": false } } } change_girls 可自动切换的背景 添加背景图片，并且可以自动切换 { \"plugins\":[\"change_girls\"], \"pluginsConfig\": { \"change_girls\" : { \"time\" : 10, \"urls\" : [ \"girlUrl1\", \"girlUrl2\",...\"\" ] } } } copyright 版权保护插件 如果你的博客不希望被别人随意转载或者文章希望保留首发网站信息，那么推荐使用copyright插件帮助你进行版权保护。 gitbook-plugin-copyright 版权保护插件实现复制文章时自动追加版权保护信息，并在文章结尾处追加来源信息。 { \"plugins\": [\"copyright\"], \"pluginsConfig\": { \"copyright\": { \"site\": \"\", \"author\": \"\", \"website\": \"\", \"image\": \"\" } } } readmore 阅读更多插件 如果 Gitbook 个人博客流量不错的话，可以考虑转化成公众号流量，readmore 插件是集成OpenWrite提供引流工具，通过关注公众号解锁博客文章，实现粉丝转换!、 { \"plugins\": [\"readmore\"], \"pluginsConfig\": { \"readmore\":{ \"blogId\": \"\", \"name\": \"\", \"qrcode\": \"\", \"keyword\": \"\" } } } advanced-emoji - 支持emoji表情 { \"plugins\": [ \"advanced-emoji\" ] } 一些实用插件 search-plus 中文搜索插件 默认的 search 搜索插件是不支持中文搜索的，而 search-plus 则功能更强大些，两者不能共存，需要禁用或移除 search 插件。 { \"plugins\": [ \"-lunr\", \"-search\", \"search-plus\" ] } expandable-chapters-small 可扩展导航章节 expandable-chapters效果相同，唯一不同的是这个插件的箭头粗。 支持多层目录。点击箭头才能实现收放目录。不如chapter-fold好用。 { \"plugins\": [ \"expandable-chapters-small\" ] } gitbook-plugin-summary 自动生成SUMMARY.md文件 { \"plugins\": [ \"summary\" ] } page-treeview 生成页内目录 生成目录，放在页面顶部 { \"plugins\": [ \"page-treeview\" ], \"pluginsConfig\": { \"page-treeview\": { \"copyright\": \"Copyright &#169; aleen42\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" } } } tbfed-pagefooter 页脚插件 { \"plugins\": [\"tbfed-pagefooter\"], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"&copy username\", \"modify_label\": \"文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } pageview-count 阅读量计数 { \"plugins\": [ \"pageview-count\"] } accordion 折叠模块 这个插件名叫手风琴，可以实现将内容隐藏起来，外部显示模块标题和显示箭头，点击箭头可显示里面的内容。 { \"plugins\": [\"accordion\"] } 用法：编辑内容，用下面的标签括起来 %accordion%模块标题%accordion% 内容部分 %/accordion% hide-element 隐藏元素 可以隐藏不想看到的元素，比如导航栏中Published by GitBook { \"plugins\": [ \"hide-element\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] } } } splitter 侧边栏宽度可调节 { \"plugins\": [ \"splitter\" ] } sharing-plus 分享当前页面，比默认的 sharing 插件多了一些分享方式。 { \"plugins\": [\"-sharing\", \"sharing-plus\"], \"pluginsConfig\": { \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": true, \"pocket\": false, \"qq\": false, \"qzone\": true, \"twitter\": false, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\",\"twitter\", \"weibo\", \"messenger\",\"qq\", \"qzone\",\"viber\",\"whatsapp\" ] } } } klipse 嵌入类似IDE的功能 嵌入一块功能，可在代码段中实时交互，即（输入代码 > 执行结果 { \"plugins\": [\"klipse\"] } klipse 目前支持下面的语言： javascript: evaluation is done with the javascript function eval and pretty printing of the result is done with pretty-format clojure[script]: evaluation is done with Self-Hosted Clojurescript ruby: evaluation is done with Opal C++: evaluation is done with JSCPP python: evaluation is done with Skulpt scheme: evaluation is done with BiwasScheme PHP: evaluation is done with Uniter BrainFuck JSX EcmaScript2017 Google Charts: See Interactive Business Report with Google Charts. github 插件 添加 github 图标链接，方便直接跳转到 github 指定仓库。 { \"plugins\": [\"github\"], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/snowdreams1006/snowdreams1006.github.io\" } } } edit-link 编辑链接插件 如果希望将网页源码暴露出去并接受公众的监督校准的话，使用edit-link插件可以直接链接到源码文件。 { \"plugins\": [\"edit-link\"], \"pluginsConfig\": { \"edit-link\": { \"base\": \"\", \"label\": \"\" } } } back-to-top-button 回到顶部 { \"plugins\": [ \"back-to-top-button\" ] } chapter-fold 导航目录折叠 支持多层目录，点击导航栏的标题名就可以实现折叠扩展。 { \"plugins\": [\"chapter-fold\"] } code 代码添加行号&复制按钮（可选） { \"plugins\" : [ \"code\" ], \"pluginsConfig\": { \"code\": { \"copyButtons\": false } } } insert-logo 插入logo 将logo插入到导航栏上方中 { \"plugins\": [ \"insert-logo\" ] \"pluginsConfig\": { \"insert-logo\": { \"url\": \"images/logo.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" } } } 主题插件 theme-default 主题 theme-default 是 3.0.0 引入的默认主题，大多数插件针对的都是默认主题，如果切换到其他主题或者自定义主题，可能会造成某些情况下不兼容,甚至报错。 默认情况下，左侧菜单不显示层级属性，如果将 showLevel 属性设置为 true 可以显示层级数字。 { \"plugins\": [ \"theme-default\" ] \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true } } } theme-comscore 主题 default 默认主题是黑白的，而 comscore 主题是彩色，即标题和正文颜色有所区分。 \"plugins\": [ \"theme-comscore\" ] flexible-alerts 警报 这个GitBook插件将块引用转换为漂亮的警报。此外，您还可以提供自己的警报类型（比如最后的comment）。 { \"plugins\": [ \"flexible-alerts\" ], \"pluginsConfig\": { \"flexible-alerts\": { \"style\": \"callout\", \"comment\": { \"label\": \"Comment\", \"icon\": \"fa fa-comments\", \"className\": \"info\" } } } } arkdown文件中编辑 > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 上面的[!NOTE]是行匹配模式，默认情况下支持类型NOTE，TIP，WARNING和DANGER。 > [!type|style:xx|label:xx|icon:xx|className:xx|labelVisibility:xx|iconVisibility:xx] > 内容部分 theme-api 插件 如果文档本身是普普通文档模式，切换成 api 文档模式后并不会有太大变化，除非一开始就是接口文档，那样使用 theme-api 插件才能看出效果。 { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"theme\": \"dark\" } } } theme-faq 插件 theme-faq 可以帮助我们构建问答中心，预设好常见问题以及相应答案模式，同时为了方便搜索到问题或答案，一般需要搜索插件的配合。 帮助中心没有工具栏，因此涉及到工具类的插件一律失效或主动移除，同时默认搜索插件也会失效。 { \"plugins\": [ \"theme-faq\", \"-fontsettings\", \"-sharing\", \"-search\", \"search-plus\" ] } 插件开发 GitBook 插件是在 npm 上发布的遵循传统定义的 node 包，除了标准的 node 规范外还有一些 Gitbook 自身定义的相关规范。 目录结构 Gitbook 插件最基本的项目结构至少包括配置文件 package.json 和入口文件 index.js ，其他目录文件根据插件用途自行增减。 实际插件项目略有不同，可能还会有 _layouts 布局目录， asset 资源目录以及自定义 example 示例目录和 docs 文档目录等等。 package.json package.json 是nodejs的配置文件，Gitbook 插件同样遵循该规范，配置文件声明了插件的版本描述性信息，除此之外还有 Gitbook 相关字段，遵循schema准则，基本示例如下： { \"name\": \"gitbook-plugin-mytest\", \"version\": \"0.0.1\", \"description\": \"This is my first GitBook plugin\", \"engines\": { \"gitbook\": \">1.x.x\" }, \"gitbook\": { \"properties\": { \"myConfigKey\": { \"type\": \"string\", \"default\": \"it's the default value\", \"description\": \"It defines my awesome config!\" } } } } 值得注意的是，包名称必须以 gitbook-plugin-开头，包引擎应该包含gitbook。 index.js index.js 是插件运行时的入口，基本示例如下： module.exports = { // 钩子函数 hooks: {}, // 代码块 blocks: {}, // 过滤器 filters: {} }; 专用插件 专用插件可以托管在 GitHub 上，并使用 git urls： { \"plugins\": [ \"myplugin@git+https://github.com/MyCompany/mygitbookplugin.git#1.0.0\" ] } 发布&测试插件 与其他npm插件一样。GitBook 插件可以在npmjs官网上发布。如需发布插件，首先需要在npmjs官网上注册帐户，然后通过命令行发布。 npm publish #在插件的文件夹中，运行 npm link #然后在您的书或者文档的文件夹中执行 npm link gitbook-plugin- 参数链接 雪之梦技术驿站 GitBook插件整理 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:16:58 "},"tools/Gitbook/03-gitbook进阶篇.html":{"url":"tools/Gitbook/03-gitbook进阶篇.html","title":"Gitbook进阶篇","keywords":"","body":"Gitbook进阶篇 集成 github 网站 为什么选择集成到github? 使用零成本: github pages 集成在 github 中, 直接和代码管理绑定在一起, 随着代码更新自动重新部署, 使用非常方便. 免费: 免费提供 http://username.github.io 的域名, 免费的静态网站服务器. 无数量限制: github pages 没有使用的数量限制, 每一个 github repository 都可以部署为一个静态网站. 什么是 GitHub Pages ? Github Pages 是 github 网站推出的一种免费的静态网页托管服务，适合搭建静态的项目主页或个人官网。 其中，网站项目的源码直接托管在 github 仓库中，当仓库文件更新后，该仓库所关联的网站自动更新，从而实现了源码与官网的联动更新。 每个账号有且只有一个主页站点，但允许无限制多的项目站点。 主页站点：https://.github.io/ 项目站点：https://.github.io/repository/ 如何集成 gitbook ? 我们已经知道 Github Pages 是提供静态网站的免费托管，而 gitbook 默认生成的内容就是静态网站。gitbook 默认输出目录 _book/ 包括了静态网站所需的全部资源，其中就包括 index.html 首页文件。我们需要做的就是，这_book下的所有文件复制一份到根目录或./docs（取决于你github中的设置）。以为复制到./docs为例： 每次生成后将 _book/ 整个目录复制到项目根目录或者定的docs gitbook build cp -r _book/* . gitbook build，可以指定输入文件 gitbook build ./ ./docs book.json中设置output参数。（无效，不知道是什么原因。如果你知道，欢迎在下方给我留言） # book.json { \"output\": \"./docs\" } Openwrite OpenWrite（官网：https://www.openwrite.cn）一文多发平台。只需要你使用 markdown 完成内容写作，通过文章扩散工具，就能轻松将文章内容到科技人汇聚的内容平台。从而让各个平台的读者都能看到你的内容，从而了解你，并提升你的综合影响力！ 一文多发 OpenWrite 提供的众多功能中最吸引我的地方莫过于一文多发功能了：我在用的平台它都有，我没用的平台它也有！ 平台整体上使用体验非常不错，大致步骤是先提前登陆各大目标平台，然后通过 OpenWrite 提供的插件自动进行渠道认证，配置各大渠道后就可以愉快发文啦！ 公众号引流 如果你有自己独立博客，也在运营者微信公众号，但是苦于没有很好的手段引导读者关注公众号，那么Openwrite 推出的 ReadMore 工具绝对可以解决燃眉之急。 静态博客网站集成 ReadMore 工具后，全站博客文章内容自动隐藏一半，同时浮现出阅读全文的按钮引导读者点击解锁。 一旦读者想要阅读全文就会主动点击按钮，此时就会自动弹出引导用户关注公众号的弹窗。 接下来读者应该是关注公众号回复关键字获取验证码进而解锁文章。 读者关注公众号后，发送关键字获取文字链接并点击该链接，此时就会获取验证码,离成功只差一步! 再次回到博客平台的受限文章，输入刚刚获取到的验证码，不仅解锁了当前文章，博客内的其他文章也全部自动解锁，并不会造成不好体验,完美！ gitbook集成openwrite 安装 openwrite 插件。即在 book.json 配置，然然gitbook install { \"plugins\" : [\"openwrite\"], \"pluginsConfig\":{ \"openwrite\":{ \"blogId\": \"\", \"name\": \"\", \"qrcode\": \"\", \"keyword\": \"\" } } } 参数链接 雪之梦技术驿站 © lizhao all right reserved，powered by Gitbook文件修订时间： 2021-10-15 23:16:58 "}}